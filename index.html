<!DOCTYPE html>
<head>
<meta charset="UTF-8" />
<title>ä¿®ç¾…ç‹ä¸¸ æ°¸é ã®ç„¦åœŸãƒ‘ã‚ºãƒ«(ãƒãƒƒãƒ3)</title>

  <!-- === Site Icon === -->
  <link rel="icon" href="favicon.png" type="image/png" />

  <!-- === Open Graph (SNS) === -->
  <meta property="og:title" content="ä¿®ç¾…ç‹ä¸¸ æ°¸é ã®ç„¦åœŸãƒ‘ã‚ºãƒ«" />
  <meta property="og:description" content="ã‚ãªãŸã®æŒ‡å…ˆãŒ ç„¦åœŸã«ã€Š è¯ ã€‹ã‚’å’²ã‹ã›ã‚‹ã€‚" />
  <!-- Replace the URL below with your published absolute URL -->
  <meta property="og:image" content="https://shuraomaru.itch.io/match3game/og.jpg" />
  <meta property="og:url" content="https://shuraomaru.itch.io/match3game" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="ä¿®ç¾…ç‹ä¸¸ãƒãƒƒãƒ3ã‚²ãƒ¼ãƒ " />

  <!-- === Twitter Card === -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="ä¿®ç¾…ç‹ä¸¸ æ°¸é ã®ç„¦åœŸãƒ‘ã‚ºãƒ«" />
  <meta name="twitter:description" content="ã‚ãªãŸã®æŒ‡å…ˆãŒ ç„¦åœŸã«ã€Š è¯ ã€‹ã‚’å’²ã‹ã›ã‚‹ã€‚" />
  <meta name="twitter:image" content="https://shuraomaru.itch.io/match3game/og.jpg" />

<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;600;700&display=swap" rel="stylesheet">
<style>
html{ margin:0; padding:0; height:100%; }

.modal-overlay[hidden]{display:none !important;}

  :root{ --bg-0:#070707; --ink:#f5f7fb; --muted:#a3a7b3; --line:#2b2e34; }
  body{ margin:0; color:var(--ink); font-family:"Noto Sans JP",system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Sans","Noto Sans JP",sans-serif;
    background: radial-gradient(1400px 680px at 50% -10%, #1b1c20 0%, #0c0c0e 55%, var(--bg-0) 100%),
               linear-gradient(180deg, #0b0b0c 0%, #09090a 100%); min-height:100dvh; text-align:center; }
  .wrap{ max-width:640px; margin:0 auto 28px; padding:0 16px 16px; }
  .panel{ margin:0 auto; padding:16px 14px; border-radius:16px; background:#121316; border:1px solid var(--line);
    box-shadow:0 18px 60px rgba(0,0,0,.55), 0 1px 0 rgba(255,255,255,.06) inset; backdrop-filter:saturate(120%) blur(8px); }
  html.ios .panel{ backdrop-filter:none !important; }
  html.ios canvas{ box-shadow:0 10px 26px rgba(0,0,0,.55), 0 1px 0 rgba(255,255,255,.04) inset; }
  html.ios .btn, html.ios #rankSelectRow .btn-icon{ transition:none !important; box-shadow:0 1px 0 rgba(255,255,255,.05) inset, 0 8px 18px rgba(0,0,0,.30); }
  html.ios .btn:hover, html.ios .btn.hover-glow{ box-shadow:0 8px 18px rgba(0,0,0,.30); transform:none; }
  html.ios .modal-content{ box-shadow:0 10px 24px rgba(0,0,0,0.55); }

  /* ã‚¿ã‚¤ãƒˆãƒ«ã‚µã‚¤ã‚ºï¼B */
  h1{ display:none; }
  .subtitle{ display:none; }
  .hud{ display:flex; gap:10px; justify-content:space-between; align-items:center; margin:0; padding:8px 10px 6px; flex-wrap:wrap; }
  .badge{ background:linear-gradient(180deg,#1c1d22,#14151a); border:1px solid var(--line); border-radius:999px; padding:8px 14px; font-weight:700; }
  .rank-progress{ font-size:12px; font-weight:400; margin-left:8px; opacity:0.8; }
canvas{ display:block; margin:18px auto; width:min(96vw, 480px); height:auto; aspect-ratio:1/1; box-sizing:border-box; background:#111; border-radius:14px; border:1px solid var(--line);
   box-shadow:0 16px 40px rgba(0,0,0,.6), 0 1px 0 rgba(255,255,255,.05) inset; touch-action:none; }

  /* === Mobile-only fit: keep board within screen (no desktop impact) === */
  @media (max-width: 520px){
    .wrap{ padding-left:8px; padding-right:8px; }
    .panel{ padding-left:12px; padding-right:12px; }
    canvas{ width:100%; max-width:100%; }
  }

 .panel{ overflow:hidden; } /* ã¯ã¿å‡ºã—ã‚’å·¦å³å‡ç­‰ã«ã‚¯ãƒªãƒƒãƒ— */
  .row{ display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin:16px 0 12px; }
  .btn{ display:inline-flex; align-items:center; gap:.4em; font-weight:600; font-size:14px;
    background:linear-gradient(180deg,#202126,#14151a); color:#fff; border:1px solid var(--line);
    border-radius:999px; padding:8px 12px; cursor:pointer; user-select:none;
    /* â˜…ç™ºå…‰åŠ¹æœ */
    box-shadow:0 1px 0 rgba(255,255,255,.06) inset, 0 10px 24px rgba(0,0,0,.35), 0 0 0 rgba(127, 183, 255, 0);
    transition:transform .08s ease, box-shadow .18s ease, border-color .2s ease, background .2s ease; }
  /* â˜…ç™ºå…‰åŠ¹æœ (Hover) */
  .btn:hover, .btn.hover-glow{ 
    transform:translateY(-1px); border-color:#3c4048; 
    box-shadow:0 14px 28px rgba(0,0,0,.44), 0 0 10px rgba(127, 183, 255, 0.5); /* ãƒ›ãƒãƒ¼æ™‚ã®ç™ºå…‰ */
  }
  .btn:active{ transform:translateY(0); box-shadow:0 6px 14px rgba(0,0,0,.44) inset; }
  .btn-kanki{ background:linear-gradient(180deg,#233246,#17212c); border-color:#2b3b4f; }
  .btn-shodo{ background:linear-gradient(180deg,#3a1b1e,#1d0e10); border-color:#4b2a2f; }
  /* â˜…ç™ºå…‰åŠ¹æœ (Active) */
  .btn.active{ outline:2px solid #7fb7ff; box-shadow:0 14px 28px rgba(0,0,0,.44), 0 0 15px rgba(127, 183, 255, 0.8); }
  .btn-shuffle{ background:linear-gradient(180deg,#44224a,#2c1430); border-color:#5c3563; }
  .btn-mini{ padding:4px 8px; font-size:12px; }
  .status{ margin:6px 0 10px; font-size:12.5px; color:var(--muted); }

  #titleRow{
    margin:2px 4px 0;
    font-size:11px;
    color:var(--muted);
    text-align:left;
  }
/* ã‚³ãƒ³ãƒœæŠ€åãƒ©ãƒ™ãƒ« */
  #comboTextRow{
  width:90%;
  max-width:260px;
  margin:2px auto 0;
  text-align:center;

  /* â˜…ã“ã“ãŒé‡è¦ï¼šãƒ†ã‚­ã‚¹ãƒˆã®æœ‰ç„¡ã‚„ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºå¤‰æ›´ã§ã‚‚ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆãŒå‹•ã‹ãªã„ */
  height:17px;
  line-height:17px;
  min-height:17px;

  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;

  display:flex;
  align-items:center;
  justify-content:center;
}

/* ã‚³ãƒ³ãƒœæŠ€åãƒ©ãƒ™ãƒ«ã®ãƒ•ã‚©ãƒ³ãƒˆï¼ç¸å–ã‚Šï¼ˆæºçœŸã‚´ã‚·ãƒƒã‚¯ Heavyæƒ³å®šï¼‰ */
  #comboTextLabel{
    display:inline-block;
    max-width:100%;
    font-family: "æºçœŸã‚´ã‚·ãƒƒã‚¯ Heavy","Yu Gothic","Meiryo",system-ui,sans-serif;
    font-size:17px;          /* å°‘ã—å°ã•ã‚ã«ã—ã¦ã€Œåœ°ä¹‹å¢é›²ã€ã¾ã§åã‚ã‚‹ */
    font-weight:900;
    color:#111111;           /* é»’ã«è¿‘ã„æ–‡å­—è‰² */
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }

  #comboGaugeLabel{
    margin:2px 4px 0;
    font-size:10px;
    color:var(--muted);
    text-align:left;
  }
  #comboGaugeTicks{
    width:90%;
    max-width:260px;
    margin:2px auto 0;
    font-size:9px;
    color:var(--muted);
    display:flex;
    justify-content:space-between;
    pointer-events:none;
  }

  #comboGauge{
    width:90%;
    max-width:260px;
    height:4px;
    margin:4px auto 0;
    border-radius:999px;
    background:rgba(255,255,255,0.08);
    overflow:hidden;
  }
  #comboGaugeFill{
    width:0%;
    height:100%;
    border-radius:999px;
    background:linear-gradient(90deg,#ff6b6b,#ffa94d);
    transition:width .12s ease-out;
  }


  /* æ–°è¦ï¼šãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ã®è‰² */
  .btn-reset{ 
    background:linear-gradient(180deg,#6e2222,#421515); 
    border-color:#a53939; color:#ffeded; 
    /* ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ã®ãƒ›ãƒãƒ¼æ™‚ã®ç™ºå…‰ã‚’èµ¤ç³»ã« */
    box-shadow:0 1px 0 rgba(255,255,255,.06) inset, 0 10px 24px rgba(0,0,0,.35), 0 0 0 rgba(255, 100, 100, 0);
  }
  .btn-reset:hover, .btn-reset.hover-glow{ 
    transform:translateY(-1px); border-color:#c84f4f; 
    box-shadow:0 14px 28px rgba(0,0,0,.44), 0 0 10px rgba(255, 100, 100, 0.5); /* èµ¤ç³»ç™ºå…‰ */
  }
  .btn-reset:active{ transform:translateY(0); box-shadow:0 6px 14px rgba(0,0,0,.44) inset; }


  /* æ“ä½œæ–¹æ³•ï¼ */
  details.help{ text-align:left; background:linear-gradient(180deg,#14151a,#111217); border:1px solid var(--line);
                border-radius:14px; padding:12px 14px; margin:14px 0; box-shadow:0 12px 32px rgba(0,0,0,.35) inset; }
  details.help summary{ cursor:pointer; font-weight:700; }
  details.help ul{ margin:8px 0 0 18px; } details.help li{ margin:4px 0; line-height:1.6; }
  small.note{ opacity:.75; display:block; margin-top:6px; }

  /* ãƒ¢ãƒ¼ãƒ€ãƒ«å…±é€šã‚¹ã‚¿ã‚¤ãƒ«ï¼ˆå›³é‘‘ç”¨ã‚’ãƒ™ãƒ¼ã‚¹ã«èª¿æ•´ï¼‰ */
  .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.85); display: none; justify-content: center; align-items: center; z-index: 1000; }
  .modal-overlay.open { display: flex; }
  /* â˜…ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®ä¸Šã«é‡ã­ã¦è¡¨ç¤ºã™ã‚‹ãŸã‚ã€å›³é‘‘ã¨æ“ä½œèª¬æ˜ã®Z-indexã‚’ä¸Šã’ã‚‹ */
  /* Z-index: 10010 (indexModal) < 10012 (charModal, howtoModal) */
  /* â˜…ä¿®æ­£: .openã‚¯ãƒ©ã‚¹ãŒãªãã¦ã‚‚z-indexã‚’é©ç”¨ã—ã€ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚ˆã‚Šå‰é¢ã«è¡¨ç¤ºã•ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹ */
  #charModal { z-index: 20000; } 
  #howtoModal { z-index: 20000; }
  
  .modal-content { background:#191b1f; padding:25px; border-radius:12px; max-width:90%; max-height:80%; overflow-y:auto; position:relative; color:var(--ink); text-align:left; border:1px solid var(--line); box-shadow:0 12px 30px rgba(0,0,0,0.6); }
  
  /* ã‚¯ãƒ­ãƒ¼ã‚ºãƒœã‚¿ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’çµ±ä¸€ */
  .close-btn { 
    position:absolute; top:10px; right:15px; z-index:1000; 
    display:inline-block; width:36px; height:36px;
    background:transparent url("images/closebutton.png") center/contain no-repeat;
    border:none;padding:0;margin:0;box-shadow:none;border-radius:0;
    color:transparent;text-indent:-9999px;overflow:hidden;cursor:pointer;
  }
  .close-btn:hover{filter:brightness(1.1);}

  /* å›³é‘‘å›ºæœ‰ */
  .char-modal-content { /* å›³é‘‘ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã¯å°‘ã—åºƒã‚ */
    max-width: 90%;
    max-height: 80%;
    width: min(92vw, 720px); 
    padding: 25px;
  }
  .char-list { display:grid; grid-template-columns:repeat(auto-fit,minmax(140px,1fr)); gap:15px;margin-top:20px; }
  .char-item { border:1px solid #333; padding:10px; border-radius:8px; background:#222; opacity:0.5; transition:opacity .3s; }
  .char-item.unlocked{ opacity:1; }
  .char-item h4 { margin:0 0 5px 0; font-size:16px; }
  .char-item p { margin:0; font:12px; color:var(--muted); }
  .char-item img { width:40px; height:40px; margin-right:10px; border-radius:4px; vertical-align:middle; }
  .char-item .title-row { display:flex; align-items:center; }

/* === å›³é‘‘ï¼šãƒ­ãƒƒã‚¯ä¸­ã¯å®Œå…¨ãƒ–ãƒ©ã‚¤ãƒ³ãƒ‰è¡¨ç¤º === */
.char-item.locked{ 
  opacity:1;
  background:#1b1b1b;
}
.char-item.locked .title-row img,
.char-item.locked .char-tag,
.char-item.locked p,
.char-item.locked small{
  display:none !important;
}
.char-item.locked .title-row::before{
  content:"";
  display:inline-block;
  width:40px; height:40px;
  margin-right:10px;
  border-radius:4px;
  background:#0e0e0e;
  border:1px solid #333;
}

  /* å›³é‘‘ã®ã‚¿ã‚° */
  .char-tag{ display:inline-block; font-size:10px; padding:3px 6px; border-radius:4px; font-weight:700; border:1px solid #444; margin-left:6px; }
  .char-tag.yellow{ background:#4d4200; border-color:#6b5e00; color:#ffd900; } /* å¼ç¥=é»„è‰² */
  .char-tag.blue  { background:#0c2a4a; border-color:#174a7a; color:#7fc8ff; }/* ä¿®ç¾…ç‹ä¸¸=é’ */
  .char-tag.red   { background:#3a0c12; border-color:#5a1c22; color:#ff8a8a; }/* ãŠé‚ªé­”=èµ¤ */
  .char-tag.neutral{ background:#333; color:#ccc; }
  .char-tag.orange{ background:#4a2a00; border-color:#6a3a00; color:#ffb25f; }/* ã—ã‚…ã‚‰ã¡ã‚ƒã‚“=æ©™ */

  /* æœ€çµ‚ãƒ©ãƒ³ã‚¯æ™‚ï¼šç‰¹æ®Šé¸æŠè¡Œã®ã‚¢ã‚¤ã‚³ãƒ³ãƒœã‚¿ãƒ³ */
  #rankSelectRow .btn-icon{
    display:inline-flex; align-items:center; gap:4px; padding:2px 4px; border-radius:10px;
    font-size:12px; line-height:0; border:1px solid var(--line); background:linear-gradient(180deg,#222,#16171b);
    cursor:pointer; user-select:none;
    /* â˜…ç™ºå…‰åŠ¹æœ */
    box-shadow:0 1px 0 rgba(255,255,255,.06) inset, 0 10px 24px rgba(0,0,0,.35), 0 0 0 rgba(127, 183, 255, 0);
    transition:transform .08s ease, box-shadow .18s ease, border-color .2s ease, background .2s ease;
  }

  #rankSelectRow .btn-icon:hover{ transform:translateY(-1px); border-color:#3c4048; box-shadow:0 14px 28px rgba(0,0,0,.44), 0 0 10px rgba(127, 183, 255, 0.5); }
  #rankSelectRow .btn-icon.active{ outline:2px solid #7fb7ff; box-shadow:0 14px 28px rgba(0,0,0,.44), 0 0 15px rgba(127, 183, 255, 0.8); }

#rankSelectRow { 
  gap: 14px;
}
  #rankSelectRow .btn-icon img{ width:40px; height:40px; border-radius:3px; display:block; }
  
.panel{ overflow: hidden; }
.panel > .row + .row { margin-top: 10px; }
.panel > .row:not(#rankSelectRow) {
  justify-content: center;
  gap: 12px;
  width: 100%;
}
details.help summary,
details.help ul,
details.help li {
  text-align: left;
}

/* === ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒœã‚¿ãƒ³ï¼‹ãƒ¢ãƒ¼ãƒ€ãƒ«  === */
/* å³ä¸Šã«å›ºå®šã™ã‚‹ãƒœã‚¿ãƒ³ï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼‰ */
#indexBtn{
  position:fixed;top:10px;right:10px;width:40px;height:40px;
  display:inline-grid;place-items:center;border-radius:10px;border:1px solid var(--line);
  /* ã‚¢ã‚¤ã‚³ãƒ³ã¯é©å®œå¤‰æ›´ã—ã¦ãã ã•ã„ã€‚ã“ã“ã§ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®howtoã‚¢ã‚¤ã‚³ãƒ³ã‚’æµç”¨ */
  background:rgba(20,20,20,.9) url("images/howtobutton.png") center/28px 28px no-repeat;
  color:transparent;cursor:pointer;z-index:10005; border-color:#4169E1;
  /* â˜…ç™ºå…‰åŠ¹æœ */
  box-shadow:0 0 0 rgba(127, 183, 255, 0);
  transition: box-shadow .2s ease, border-color .2s ease, background .2s ease;
}
#indexBtn:hover{
  border-color:#7fb7ff;
  box-shadow:0 0 8px rgba(127, 183, 255, 0.6);
}

#indexModal[hidden]{display:none;}
#indexModal{position:fixed;inset:0;display:grid;place-items:center;background:rgba(0,0,0,.8);z-index:10010;}
#indexModal .index-panel{
  background:#111;color:var(--ink);border:1px solid var(--line);border-radius:14px;
  width:min(92vw,360px);max-height:90vh;box-shadow:0 10px 28px rgba(0,0,0,.6);
  position:relative;padding:25px;text-align:center;
}
#indexModal .index-panel h2{margin:0 0 20px; font-size:24px;}
/* ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹å†…ã®ãƒœã‚¿ãƒ³ãƒªã‚¹ãƒˆ */
#indexModal .btn-list{display:grid; gap:12px;}
#indexModal .btn-list .btn{ 
  width:100%; justify-content:center; 
  padding:12px 16px; /* ãƒœã‚¿ãƒ³ã‚’å¤§ãã */
  font-size:16px; 
}
/* BGM/SEãƒœã‚¿ãƒ³ã¯å°ã•ãå·¦å³ã«ä¸¦ã¹ã‚‹ */
#indexModal .btn-group{display:flex; gap:10px;}
#indexModal .volume-group{
  flex-direction:column;
  align-items:stretch;
}
.volume-row{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:8px;
  margin-bottom:6px;
}
.volume-text{
  font-size:14px;
  min-width:70px;
  text-align:left;
}
.volume-row input[type="range"]{
  flex:1;
  touch-action: none;           /* iOS/Chromeã§ãƒ‰ãƒ©ãƒƒã‚°ã‚’ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æ‰±ã„ã«ã—ãªã„ */
  -webkit-tap-highlight-color: transparent;
}
#indexModal .btn-group .btn{ flex:1; padding:10px 12px; font-size:15px; }

/* è¦šé†’ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ«ã¨ãƒãƒ¼ã‚¸ãƒ³ */
#indexModal #resetRankBtn{ 
  margin-top: 30px; /* ä»–ã®ãƒœã‚¿ãƒ³ã¨é–“éš”ã‚’ç©ºã‘ã‚‹ */
  padding:12px 16px; 
  font-size:16px; 
}


/* === æ“ä½œèª¬æ˜ãƒ¢ãƒ¼ãƒ€ãƒ« (howtoModal) === */
#howtoModal[hidden]{display:none;} /* è¿½åŠ  */
#howtoModal .modal-content { 
  width:min(92vw,720px); max-height:90vh; padding:14px 14px 10px; /* å›³é‘‘ã‚ˆã‚Šè–„ã */
}
#howtoModal .howto-img-wrap{position:relative;display:grid;place-items:center;aspect-ratio:16/9;background:#000;border-radius:10px;overflow:hidden;}
#howtoModal img#howtoImg{width:100%;height:auto;object-fit:contain;user-select:none;-webkit-user-drag:none;}
#howtoModal .howto-nav{position:absolute;top:50%;transform:translateY(-50%);width:44px;height:44px;border-radius:9999px;border:1px solid var(--line);background:rgba(28,28,28,.9);color:var(--ink);cursor:pointer;z-index:10;}
#howtoModal .howto-nav.prev{left:8px;}
#howtoModal .howto-nav.next{right:8px;}
#howtoModal .howto-caption{margin-top:8px;text-align:center;font-size:13px;opacity:.9;}


/* === ãƒ©ãƒ³ã‚¯ç¢ºèªãƒ¢ãƒ¼ãƒ€ãƒ« (æ–°è¦) === */
#resetConfirmModal[hidden]{display:none;}
#resetConfirmModal{position:fixed;inset:0;display:grid;place-items:center;background:rgba(0,0,0,.9);z-index:10015;}
#resetConfirmModal .modal-content {
  max-width: 320px;
  padding: 30px 20px 20px;
  text-align: center;
  background:#201111; /* èµ¤é»’ç³»ã®èƒŒæ™¯ */
  border-color:#4d2020;
}
#resetConfirmModal h3 {
  margin: 0 0 20px;
  font-size: 18px;
  color: #ffc0c0;
}
#resetConfirmModal .confirm-btns {
  display: flex;
  justify-content: space-around;
  margin-top: 20px;
}
#resetConfirmModal .confirm-btns .btn {
  width: 45%;
  font-size: 15px;
}
/* ã¯ã„ãƒœã‚¿ãƒ³ã¯èµ¤ç³» */
#resetConfirmModal #confirmResetYes {
    background: linear-gradient(180deg,#6e2222,#421515);
    border-color: #a53939;
    color: #ffeded;
}

/* hide debug status */
#status{ display:none !important; }


/* â˜…BGM/SE ãƒˆã‚°ãƒ«ï¼šä»–ãƒœã‚¿ãƒ³ã¨è¦ªå’Œã™ã‚‹å°å‹ãƒ”ãƒ«ï¼ˆã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ãŒé•·ãã¦ã‚‚ON/OFFã—ã‚„ã™ãï¼‰ */
.vol-toggle{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap:.35em;
  font-weight:600;
  font-size:13px;

  min-width:70px; /* æ—¢å­˜ã®ãƒ©ãƒ™ãƒ«å¹…ã‚’ç¶­æŒ */
  height:28px;
  padding:0 10px;

  background:linear-gradient(180deg,#202126,#14151a);
  color:#fff;
  border:1px solid var(--line);
  border-radius:999px;

  cursor:pointer;
  user-select:none;
  -webkit-tap-highlight-color: transparent;

  box-shadow:0 1px 0 rgba(255,255,255,.06) inset, 0 10px 18px rgba(0,0,0,.35);
  transition:transform .08s ease, box-shadow .18s ease, border-color .2s ease, background .2s ease;
}
.vol-toggle:hover{
  transform:translateY(-1px);
  border-color:#3c4048;
  box-shadow:0 14px 24px rgba(0,0,0,.44), 0 0 10px rgba(127, 183, 255, 0.35);
}
.vol-toggle:active{
  transform:translateY(0);
  box-shadow:0 6px 14px rgba(0,0,0,.44) inset;
}
.vol-toggle:focus{ outline:none; }

/* ãƒŸãƒ¥ãƒ¼ãƒˆçŠ¶æ…‹ã®è¦–èªæ€§ï¼ˆã‚¢ã‚¤ã‚³ãƒ³è‡ªä½“ã¯JSå´ã§ğŸ”ˆ/ğŸ”Šåˆ‡æ›¿ï¼‰ */
.vol-toggle.is-muted{
  opacity:.78;
  background:linear-gradient(180deg,#1a1b20,#101116);
  border-color:#2b2e37;
}


/* â˜…å¤–æ ã®ä¸Šä¸‹éš™é–“ã‚¼ãƒ­ï¼‹é»’èƒŒæ™¯ã‚’ç¢ºå®Ÿã«å…¨é¢è¡¨ç¤º */
html, body{
  height:100%;
  min-height:100dvh;
  margin:0;
  padding:0;
  background:#000;
  /* ç”»åƒèƒŒæ™¯ã‚’ä½¿ã†å ´åˆã¯ä¸‹ã®è¡Œã‚’ONã«ã—ã¦ãã ã•ã„ */
}
.wrap{
  margin-top:0 !important;
  padding-top:0 !important;
  margin-bottom:0 !important;
  padding-bottom:0 !important;
  min-height:100dvh;
}
.panel{
  margin-bottom:0 !important;
  padding-bottom:0 !important;
}


/* === ALL MAX UNLOCK UI === */
#allmaxOverlay{
  position: fixed;
  inset: 0;
  background: radial-gradient(circle at center, rgba(255,255,255,0.08), rgba(0,0,0,0.92) 70%);
  backdrop-filter: blur(4px);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}
#allmaxPanel{
  position: relative;
  padding: 28px 26px 30px;
  width: min(90vw, 360px);
  background: linear-gradient(180deg, rgba(20,20,25,0.95), rgba(10,10,12,0.98));
  border-radius: 14px;
  box-shadow: 0 0 0 1px rgba(120,200,255,0.25), 0 0 30px rgba(120,200,255,0.25);
  text-align: center;
  color: #eaf6ff;
}
#allmaxPanel h2{
  margin: 0 0 14px;
  font-size: 18px;
  letter-spacing: 0.12em;
  color: #bfe9ff;
  text-shadow: 0 0 6px rgba(120,200,255,0.8);
}
#allmaxInput{
  width: 100%;
  margin-top: 10px;
  padding: 10px 12px;
  font-size: 15px;
  border-radius: 8px;
  border: 1px solid rgba(120,200,255,0.4);
  background: rgba(0,0,0,0.6);
  color: #eaf6ff;
  outline: none;
}
#allmaxInput::placeholder{ color: rgba(200,230,255,0.4); }
#allmaxError{
  margin-top: 10px;
  font-size: 13px;
  color: #ffb0b0;
  display: none;
}
#allmaxImage{
  max-width: 90vw;
  max-height: 80vh;
  border-radius: 14px;
  box-shadow: 0 0 0 1px rgba(255,255,255,0.15), 0 0 40px rgba(120,200,255,0.35);
  display: none;
}
#allmaxClose{
  position: absolute;
  top: 10px;
  right: 12px;
  font-size: 18px;
  color: #bfe9ff;
  cursor: pointer;
  opacity: 0.8;
  user-select: none;
}
#allmaxClose:hover{ opacity: 1; }

#titleLabel.allmax-ready{
  cursor: pointer;
  text-shadow: 0 0 6px rgba(120,200,255,0.9), 0 0 14px rgba(120,200,255,0.35);
}
#titleLabel.allmax-ready:hover{
  filter: brightness(1.08);
}

/* === ALL MAX (input row centered + image strictly contained) === */
#allmaxInputArea{
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  gap:10px;
}
#allmaxInputRow{
  display:flex;
  justify-content:center;
  align-items:center;
  gap:10px;
  width:100%;
}
#allmaxInput{
  width:min(72vw, 240px);
}
#allmaxOkBtn{
  padding:10px 14px;
  font-size:15px;
  border-radius:8px;
  border:1px solid rgba(120,200,255,0.4);
  background:rgba(0,0,0,0.6);
  color:#eaf6ff;
  cursor:pointer;
}
#allmaxOkBtn:hover{ filter:brightness(1.08); }
#allmaxImage{
  display:none;
  width:100% !important;
  max-width:100% !important;
  height:auto !important;
  object-fit:contain !important;
}
#allmaxOverlay.allmax-unlocked #allmaxImage{ display:block !important; }



/* === Mobile/iPhone: range slider hit target enlargement === */
.slider-hit{ display:flex; align-items:center; width:100%; }
@media (max-width: 900px){
  .slider-hit{
    padding: 14px 6px;           /* expands touch target vertically & slightly horizontally */
    margin: -10px -6px;          /* keep layout unchanged while enlarging hit area */
    touch-action: none;
  }
  .slider-hit input[type="range"]{
    height: 32px;                /* bigger control box helps iOS hit testing */
    width: 100%;
    -webkit-appearance: none;
    appearance: none;
    background: transparent;
  }
  .slider-hit input[type="range"]::-webkit-slider-runnable-track{
    height: 10px;
  }
  .slider-hit input[type="range"]::-webkit-slider-thumb{
    -webkit-appearance: none;
    appearance: none;
    width: 26px;
    height: 26px;
    margin-top: -8px;            /* centers thumb on 10px track */
  }
  .slider-hit input[type="range"]::-moz-range-track{ height: 10px; }
  .slider-hit input[type="range"]::-moz-range-thumb{ width: 26px; height: 26px; }
}


/* === FIX: skill-name text should not push the board === */
#skillNameContainer, .skill-name-container {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 72px;              /* å›ºå®šé«˜ã•ï¼šãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚·ãƒ•ãƒˆé˜²æ­¢ */
  pointer-events: none;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
}
#skillNameText, .skill-name-text {
  max-width: 100%;
  white-space: nowrap;
  text-overflow: ellipsis;
}


/* === FIX: make range sliders visible on mobile (track/thumb were transparent) === */
input[type="range"]::-webkit-slider-runnable-track{
  background: rgba(255,255,255,0.22);
  border: 1px solid rgba(255,255,255,0.18);
  border-radius: 999px;
}
input[type="range"]::-webkit-slider-thumb{
  background: rgba(245,247,251,0.92);
  border: 1px solid rgba(0,0,0,0.35);
  border-radius: 999px;
}
input[type="range"]::-moz-range-track{
  background: rgba(255,255,255,0.22);
  border: 1px solid rgba(255,255,255,0.18);
  border-radius: 999px;
}
input[type="range"]::-moz-range-thumb{
  background: rgba(245,247,251,0.92);
  border: 1px solid rgba(0,0,0,0.35);
  border-radius: 999px;
}


/* === FIX: mobile range sliders visibility (track/thumb) === */
@media (max-width: 900px){
  .slider-hit input[type="range"]::-webkit-slider-runnable-track{
    background: rgba(255,255,255,0.22);
    border: 1px solid rgba(255,255,255,0.18);
    border-radius: 999px;
  }
  .slider-hit input[type="range"]::-webkit-slider-thumb{
    background: rgba(245,247,251,0.92);
    border: 1px solid rgba(0,0,0,0.35);
    border-radius: 999px;
  }
  .slider-hit input[type="range"]::-moz-range-track{
    background: rgba(255,255,255,0.22);
    border: 1px solid rgba(255,255,255,0.18);
    border-radius: 999px;
  }
  .slider-hit input[type="range"]::-moz-range-thumb{
    background: rgba(245,247,251,0.92);
    border: 1px solid rgba(0,0,0,0.35);
    border-radius: 999px;
  }
}


/* === FIX: restore desktop slider look (no top/bottom borders) === */
@media (min-width: 901px){
  input[type="range"]::-webkit-slider-runnable-track{ border: none !important; }
  input[type="range"]::-webkit-slider-thumb{ border: none !important; }
  input[type="range"]::-moz-range-track{ border: none !important; }
  input[type="range"]::-moz-range-thumb{ border: none !important; }
}


/* === FIX: range fill bar (track fill) === */
input[type="range"]{
  background-image: linear-gradient(rgba(255,255,255,0.55), rgba(255,255,255,0.55));
  background-repeat: no-repeat;
  background-size: 50% 100%; /* JSã§æ›´æ–° */
}
@media (max-width: 900px){
  .slider-hit input[type="range"]{
    background-image: linear-gradient(rgba(255,255,255,0.55), rgba(255,255,255,0.55));
    background-repeat: no-repeat;
    background-size: 50% 100%;
  }
}

input[type="range"]{
  flex:1;
  touch-action: none;           /* iOS/Chromeã§ãƒ‰ãƒ©ãƒƒã‚°ã‚’ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æ‰±ã„ã«ã—ãªã„ */
  -webkit-tap-highlight-color: transparent;
}
input[type="range"]{
    height: 32px;                /* bigger control box helps iOS hit testing */
    width: 100%;
    -webkit-appearance: none;
    appearance: none;
    background: transparent;
  }
input[type="range"]::-webkit-slider-runnable-track{
    height: 10px;
  }
input[type="range"]::-webkit-slider-thumb{
    -webkit-appearance: none;
    appearance: none;
    width: 26px;
    height: 26px;
    margin-top: -8px;            /* centers thumb on 10px track */
  }
input[type="range"]::-moz-range-track{ height: 10px; }
input[type="range"]::-moz-range-thumb{ width: 26px; height: 26px; }
input[type="range"]::-webkit-slider-runnable-track{
  background: rgba(255,255,255,0.22);
  border: 1px solid rgba(255,255,255,0.18);
  border-radius: 999px;
}
input[type="range"]::-webkit-slider-thumb{
  background: rgba(245,247,251,0.92);
  border: 1px solid rgba(0,0,0,0.35);
  border-radius: 999px;
}
input[type="range"]::-moz-range-track{
  background: rgba(255,255,255,0.22);
  border: 1px solid rgba(255,255,255,0.18);
  border-radius: 999px;
}
input[type="range"]::-moz-range-thumb{
  background: rgba(245,247,251,0.92);
  border: 1px solid rgba(0,0,0,0.35);
  border-radius: 999px;
}
input[type="range"]::-webkit-slider-runnable-track{
    background: rgba(255,255,255,0.22);
    border: 1px solid rgba(255,255,255,0.18);
    border-radius: 999px;
  }
input[type="range"]::-webkit-slider-thumb{
    background: rgba(245,247,251,0.92);
    border: 1px solid rgba(0,0,0,0.35);
    border-radius: 999px;
  }
input[type="range"]::-moz-range-track{
    background: rgba(255,255,255,0.22);
    border: 1px solid rgba(255,255,255,0.18);
    border-radius: 999px;
  }
input[type="range"]::-moz-range-thumb{
    background: rgba(245,247,251,0.92);
    border: 1px solid rgba(0,0,0,0.35);
    border-radius: 999px;
  }
input[type="range"]::-webkit-slider-runnable-track{ border: none !important; }
input[type="range"]::-webkit-slider-thumb{ border: none !important; }
input[type="range"]::-moz-range-track{ border: none !important; }
input[type="range"]::-moz-range-thumb{ border: none !important; }
input[type="range"]{
  background-image: linear-gradient(rgba(255,255,255,0.55), rgba(255,255,255,0.55));
  background-repeat: no-repeat;
  background-size: 50% 100%; /* JSã§æ›´æ–° */
}
input[type="range"]{
    background-image: linear-gradient(rgba(255,255,255,0.55), rgba(255,255,255,0.55));
    background-repeat: no-repeat;
    background-size: 50% 100%;
  }
/* === Mobile slider uses PC style === */
@media (max-width: 900px){
  .slider-hit input[type="range"]{
    all: unset;
  }
  .slider-hit input[type="range"]{
    flex: 1;
    touch-action: none;
    -webkit-tap-highlight-color: transparent;
  }
}


/* === FINAL RESET: restore native range slider appearance (match original PC) === */
input[type="range"]{
  all: revert;
  appearance: auto;
  -webkit-appearance: auto;
  background: initial;
}


/* === FIX: thumb vertical centering with small per-engine nudge ===
   Native range metrics differ across OS/engines; a 1px nudge is the most stable way
   to achieve optical centering without redesigning the slider. */
:root{
  --range-track-h: 4px;
  --range-thumb-h: 16px;
  --range-thumb-nudge: 1px; /* +down. Set 0px if already centered */
}
/* WebKit / Blink */
input[type="range"]::-webkit-slider-thumb{
  margin-top: calc((var(--range-track-h) - var(--range-thumb-h)) / 2 + var(--range-thumb-nudge));
}
/* Firefox */
input[type="range"]::-moz-range-thumb{
  margin-top: calc((var(--range-track-h) - var(--range-thumb-h)) / 2 + var(--range-thumb-nudge));
}


/* === iOS: keep native range interaction reliable === */
@supports (-webkit-touch-callout: none){
  @media (max-width: 900px){
    .slider-hit{ touch-action: pan-y; }
    input[type="range"]{ touch-action: pan-y; }
  }
}

</style>
<style>
/* === BGM selection glow colors === */
.btn.bgm1-active{ outline:2px solid rgba(120,200,150,.85); box-shadow:0 0 15px rgba(120,200,150,.7); }
.btn.bgm2-active{ outline:2px solid rgba(240,120,120,.85); box-shadow:0 0 15px rgba(240,120,120,.7); }
/* FX canvas safety */
#fxCanvas{ background:transparent!important; pointer-events:none; z-index:1!important; display:none; }

/* hide debug status */
#status{ display:none !important; }
</style>

<!-- howto responsive fit override -->
<style id="howto-fit-override">
#howtoModal .modal-content{
  width: min(94vw, 640px);
  max-height: 92vh;
  overflow: hidden;
}
#howtoModal .howto-img-wrap{
  width: 100%;
  height: auto;
  max-height: 85vh;
  aspect-ratio: auto;
  display: grid;
  place-items: center;
  background: #000;
  border-radius: 10px;
  overflow: hidden;
}
#howtoModal .howto-img-wrap img,
#howtoModal img#howtoImg{
  max-width: 100%;
  max-height: 85vh;
  width: auto;
  height: auto;
  object-fit: contain;
  user-select: none;
  -webkit-user-drag: none;
  display: block;
}
</style>

<!-- howto nav shift override: move prev/next half outside so they don't cover the image -->
<style id="howto-nav-shift-override">
/* ç”»åƒå¤–å´ã«ãƒœã‚¿ãƒ³ã‚’ãšã‚‰ã™ãŸã‚ã€ãƒ©ãƒƒãƒ‘ãƒ¼ã®ã¯ã¿å‡ºã—ã‚’è¨±å¯ */
#howtoModal .howto-img-wrap{
  overflow: visible !important;
  position: relative;
}

/* ã‚ˆãã‚ã‚‹ã‚»ãƒ¬ã‚¯ã‚¿ç¾¤ã«ã¾ã¨ã‚ã¦é©ç”¨ï¼ˆã©ã‚Œã‹ã«ãƒãƒƒãƒã™ã‚Œã°å‹•ãï¼‰ */
#howtoModal .howto-prev, 
#howtoModal .howto-next,
#howtoModal .howto-nav .prev, 
#howtoModal .howto-nav .next,
#howtoModal #howtoPrev, 
#howtoModal #howtoNext,
#howtoModal .btn-prev,
#howtoModal .btn-next{
  position: absolute !important;
  top: 50% !important;
  transform: translateY(-50%) !important;
  z-index: 5;
}

/* å·¦ãƒœã‚¿ãƒ³ï¼šè‡ªåˆ†ã®ç›´å¾„ã¶ã‚“å¤–ã¸ï¼ˆ= è¿½åŠ ã§åŠåˆ†å¤–å´ã«ï¼‰ */
#howtoModal .howto-prev,
#howtoModal .howto-nav .prev,
#howtoModal #howtoPrev,
#howtoModal .btn-prev{
  left: 0 !important;
  transform: translate(calc(-27.5% - 8px), -50%) !important; 
}

/* å³ãƒœã‚¿ãƒ³ï¼šè‡ªåˆ†ã®ç›´å¾„ã¶ã‚“å¤–ã¸ */
#howtoModal .howto-next,
#howtoModal .howto-nav .next,
#howtoModal #howtoNext,
#howtoModal .btn-next{
  right: 0 !important;
  transform: translate(calc(27.5% + 8px), -50%) !important;
}
</style>
<!-- howto arrow color override -->
<style id="howto-arrow-color-override">
/* 1) ãƒ†ã‚­ã‚¹ãƒˆã‚„ã‚¢ã‚¤ã‚³ãƒ³ãƒ•ã‚©ãƒ³ãƒˆã§ä½œã‚‰ã‚ŒãŸçŸ¢å°ã‚’èµ¤ã« */
#howtoModal .howto-prev,
#howtoModal .howto-next,
#howtoModal .howto-nav .prev,
#howtoModal .howto-nav .next,
#howtoModal #howtoPrev,
#howtoModal #howtoNext,
#howtoModal .btn-prev,
#howtoModal .btn-next{
  color: #ff3b3b !important;  /* é®®ã‚„ã‹ãªèµ¤ */
}

/* 2) ç–‘ä¼¼è¦ç´ ã§çŸ¢å°ã‚’å‡ºã—ã¦ã„ã‚‹å ´åˆï¼ˆ::before ãªã©ï¼‰ */
#howtoModal .howto-prev::before,
#howtoModal .howto-next::before,
#howtoModal .howto-nav .prev::before,
#howtoModal .howto-nav .next::before,
#howtoModal #howtoPrev::before,
#howtoModal #howtoNext::before,
#howtoModal .btn-prev::before,
#howtoModal .btn-next::before{
  color: #ff3b3b !important;
}

/* 3) SVGã‚¢ã‚¤ã‚³ãƒ³ã‚’ä½¿ã£ã¦ã„ã‚‹å ´åˆ */
#howtoModal .howto-prev svg,
#howtoModal .howto-next svg,
#howtoModal .howto-nav .prev svg,
#howtoModal .howto-nav .next svg,
#howtoModal #howtoPrev svg,
#howtoModal #howtoNext svg,
#howtoModal .btn-prev svg,
#howtoModal .btn-next svg{
  fill: #ff3b3b !important;
  stroke: #ff3b3b !important; /* ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³å‹ã§ã‚‚èµ¤ã« */
}
</style>

</head>
<body>
  
<script>
/* Storage helper (polyfill) */
window.store = window.store || {
  get: function(k, def){ try{ var v = localStorage.getItem(k); return (v===null||v===undefined)?def:JSON.parse(v); }catch(e){ try{ var v2 = localStorage.getItem(k); return (v2===null||v2===undefined)?def:v2; }catch(e2){ return def; } } },
  set: function(k, v){ try{ localStorage.setItem(k, JSON.stringify(v)); }catch(e){ try{ localStorage.setItem(k, String(v)); }catch(e2){} } },
  del: function(k){ try{ localStorage.removeItem(k); }catch(e){} }
};
</script>

<div class="wrap">
    <div class="panel">
      <div class="hud">
        <div class="badge" id="score">æš—èºå€¤:  </div>
        <div class="badge" id="rank">ä¿®ç¾…ç‹ä¸¸: ã€€ <span class="rank-progress" id="rankProgress"></span></div>
      </div>
      <div id="titleRow"><span id="titleLabel"></span></div>
      <div id="comboGaugeContainer">
  <div id="comboTextRow"><span id="comboTextLabel"></span></div>

  <div id="comboGauge">
    <div id="comboGaugeFill"></div>
  </div>

  <div id="comboGaugeTicks">
    <span>1</span><span>2</span><span>3</span>
    <span>4</span><span>5</span><span>X</span>
  </div>
</div>


      <canvas id="gameCanvas"></canvas>
      <div class="row" id="rankSelectRow" style="display:none;"></div>

      <div class="row">
        <button class="btn btn-kanki" id="btnKanki" onclick="setMode('kanki'); userGesture(); onClickSE()">æ­“å–œ</button>
        <button class="btn btn-shodo" id="btnShodo" onclick="setMode('shodo'); userGesture(); onClickSE()">ç„¦åœŸ</button>
        <button class="btn" id="pauseBtn" onclick="togglePause(); onClickSE()">â¸ ä¸€æ™‚åœæ­¢</button>
      </div>

      <div class="status" id="status">status: ready</div>



      <small class="note">â’¸ 2010 Guild Noir. ã€€ä¿®ç¾…ç‹ä¸¸Â®</small>

      <div id="charModal" class="modal-overlay" onclick="if(event.target.id === 'charModal') closeCharModal()" hidden>
        <div class="modal-content char-modal-content">
          <button class="close-btn" onclick="closeCharModal()" aria-label="é–‰ã˜ã‚‹"></button>
          <h2>ğŸ‘¤ ä¿®ç¾…ç‹ä¸¸ é¡•ç¾åé‘‘</h2>
          <div id="char-list" class="char-list"></div>
        </div>
      </div>
    </div>
  </div>

  <audio id="bgm1" src="audio/bgm1.mp3" loop preload="auto"></audio>
  <audio id="bgm2" src="audio/bgm2.mp3" loop preload="auto"></audio>
  <audio id="se_index" src="audio/se_index.mp3" preload="auto"></audio>
<audio id="se_vertical"   src="audio/se_vertical.mp3"   preload="auto"></audio>
  <audio id="se_horizontal" src="audio/se_horizontal.mp3" preload="auto"></audio>
  <audio id="se_circle"     src="audio/se_circle.mp3"     preload="auto"></audio>
  <audio id="se_cross"      src="audio/se_cross.mp3" preload="auto"></audio>
  <audio id="se_pop"        src="audio/se_pop.mp3"        preload="auto"></audio>
  <audio id="se_item"       src="audio/se_item.mp3"       preload="auto"></audio>
  <audio id="se_itemskill"  src="audio/se_itemskill.mp3"  preload="auto"></audio>
  <audio id="se_whoosh"     src="audio/se_whoosh.mp3" preload="auto"></audio>
  <audio id="se_shine"      src="audio/se_shine.mp3"  preload="auto"></audio>
  <audio id="se_push"       src="audio/se_push.mp3"   preload="auto"></audio>
  <audio id="se_bell"       src="audio/se_bell.mp3"    preload="auto"></audio>
  <audio id="se_rumble"     src="audio/se_rumble.mp3"  preload="auto"></audio>
  <audio id="se_not"       src="audio/se_not.mp3"  preload="auto"></audio>
  <audio id="vo_rank0" src="audio/vo_rank0.mp3" preload="auto"></audio>
  <audio id="vo_rank1" src="audio/vo_rank1.mp3" preload="auto"></audio>
  <audio id="vo_rank2" src="audio/vo_rank2.mp3" preload="auto"></audio>
  <audio id="vo_rank3" src="audio/vo_rank3.mp3" preload="auto"></audio>
  <audio id="vo_rank4" src="audio/vo_rank4.mp3" preload="auto"></audio>
  <audio id="vo_rank5" src="audio/vo_rank5.mp3" preload="auto"></audio>
  <audio id="vo_reset" src="audio/vo_reset.mp3" preload="auto"></audio>
ã€€<!-- â˜…ã“ã“ã‹ã‚‰é€£é–ãƒœã‚¤ã‚¹ -->
<audio id="vo_combo3" src="audio/vo_combo3.mp3" preload="auto"></audio>
<audio id="vo_combo4" src="audio/vo_combo4.mp3" preload="auto"></audio>
<audio id="vo_combo5" src="audio/vo_combo5.mp3" preload="auto"></audio>
<audio id="vo_comboX" src="audio/vo_comboX.mp3" preload="auto"></audio>

<button id="indexBtn" title="ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹" aria-label="ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹"></button>
<div id="indexModal" role="dialog" aria-modal="true" aria-label="ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ¡ãƒ‹ãƒ¥ãƒ¼" hidden class="modal-overlay">
  <div class="index-panel">
    <button class="close-btn" onclick="closeIndexModal(); onClickSE()" aria-label="é–‰ã˜ã‚‹"></button>
    <h2>âš™ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹</h2>
    <div class="btn-list">
      <div class="btn-group volume-group">
        <div class="volume-row">
          <button type="button" class="volume-text vol-toggle" id="bgmBtnIndex">BGMğŸ”Š</button>
          <div class="slider-hit"><input type="range" id="bgmSlider" min="0" max="100" step="1"></div>
        </div>
        <div class="volume-row">
          <button type="button" class="volume-text vol-toggle" id="seBtnIndex">SEğŸ”Š</button>
          <div class="slider-hit"><input type="range" id="seSlider" min="0" max="100" step="1"></div>
        </div>
      </div>
      <button class="btn" id="bgmSelectBtn" onclick="toggleBGMSelect(); onClickSE()">â™ª1 / â™ª2 BGMåˆ‡æ›¿</button>
      
      <button class="btn" id="btnCharIntroIndex" onclick="openCharModal(); onClickSE()">ğŸ‘¤ ä¿®ç¾…ç‹ä¸¸ é¡•ç¾åé‘‘</button>
      
      <button class="btn" id="openHowtoBtn" onclick="openHowto(); onClickSE()">â“˜ æ“ä½œèª¬æ˜</button>
      
      <button class="btn btn-reset" id="resetRankBtn" onclick="openResetConfirmModal(); onClickSE()">
        ğŸ”¥ è¦šé†’ãƒ©ãƒ³ã‚¯ã®ãƒªã‚»ãƒƒãƒˆ
      </button>
    </div>
  </div>
</div>

<div id="resetConfirmModal" role="dialog" aria-modal="true" aria-label="è¦šé†’ãƒ©ãƒ³ã‚¯ã®ãƒªã‚»ãƒƒãƒˆç¢ºèª" hidden>
  <div class="modal-content">
    <h3>è¦šé†’ãƒ©ãƒ³ã‚¯ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ</h3>
    <p>ã“ã‚Œã¾ã§ã®è¦šé†’ãƒ©ãƒ³ã‚¯ã¨æš—èºå€¤ãŒåˆæœŸåŒ–ã•ã‚Œã¾ã™ã€‚</p>
    <div class="confirm-btns">
      <button class="btn" id="confirmResetNo" onclick="closeResetConfirmModal(); onClickSE()">ã„ã„ãˆ</button>
      <button class="btn btn-reset" id="confirmResetYes" onclick="resetRank(); onClickSE()">ã¯ã„</button>
    </div>
  </div>
</div>


<div id="howtoModal" role="dialog" aria-modal="true" aria-label="æ“ä½œæ–¹æ³•" hidden class="modal-overlay">
  <div class="modal-content">
    <button class="close-btn" id="howtoCloseBtn" onclick="closeHowto()" aria-label="é–‰ã˜ã‚‹"></button> <div class="howto-img-wrap">
      <button class="howto-nav prev" id="howtoPrev" aria-label="å‰ã®ç”»åƒ" onclick="prevHowtoPage()">â—€</button>
      <img id="howtoImg" alt="æ“ä½œæ–¹æ³•" />
      <button class="howto-nav next" id="howtoNext" aria-label="æ¬¡ã®ç”»åƒ" onclick="nextHowtoPage()">â–¶</button>
    </div>
    <div class="howto-caption"><span id="howtoCounter">1 / 1</span></div>
  </div>
</div>


<script>
"use strict";

/* ===== æ°¸ç¶šåŒ– ===== */
const store = { get(k,d){try{const v=localStorage.getItem(k);return v===null?d:JSON.parse(v);}catch(_){return d}}, set(k,v){try{localStorage.setItem(k,JSON.stringify(v));}catch(_){}} };
const IS_IOS = (/iP(hone|od|ad)/.test(navigator.userAgent) || (navigator.platform==='MacIntel' && navigator.maxTouchPoints>1));

/* ===== ã‚µã‚¦ãƒ³ãƒ‰ï¼ˆBGM2ç³»çµ±ï¼‹SEãƒ—ãƒ¼ãƒ«ï¼‰ ===== */
const bgm1 = document.getElementById("bgm1");
const bgm2 = document.getElementById("bgm2");
let activeBGM = store.get("activeBGM", 1) === 2 ? bgm2 : bgm1;
let bgmOn = !!store.get("bgmOn", false);
let bgmMuted = !!store.get("bgmMuted", false); // OFFãƒœã‚¿ãƒ³ç”¨ï¼šå†ç”Ÿã¯ç¶­æŒã—ã¤ã¤ãƒŸãƒ¥ãƒ¼ãƒˆ
let bgmPlayPending = false;
let bgmPlayToken = 0;


let bgmEverStarted = false;
/* â˜…ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹å†…ã®BGM/SEãƒœã‚¿ãƒ³ã«å¤‰æ›´ */
const bgmBtn = document.getElementById("bgmBtnIndex"); // BGM ON/OFFãƒœã‚¿ãƒ³

if (bgmBtn){
  bgmBtn.addEventListener("click", ()=>{ try{ toggleBGM(); }catch(_){ } try{ onClickSE(); }catch(_){ } });
}

const seBtn  = document.getElementById("seBtnIndex");  // SE ON/OFFãƒœã‚¿ãƒ³

if (seBtn){
  seBtn.addEventListener("click", ()=>{ try{ toggleSE(); }catch(_){ } try{ onClickSE(); }catch(_){ } });
}

const isIOS = /iP(hone|od|ad)/.test(navigator.userAgent);
const bgmSelectBtn = document.getElementById("bgmSelectBtn"); // BGMåˆ‡æ›¿ãƒœã‚¿ãƒ³
const bgmSlider = document.getElementById("bgmSlider");
const seSlider  = document.getElementById("seSlider");

function updateBgmIcon(vol){
  if(!bgmBtn) return;
  let base = Number(vol);
  if (!isFinite(base)) base = Number(store.get("bgmVol", BGM_DEFAULT_VOL));
  const isOn = (!bgmMuted && base > 0);
const icon = isOn ? "ğŸ”Š" : "ğŸ”‡";
  bgmBtn.textContent = "BGM" + icon;
}
function updateSeIcon(vol){
  if(!seBtn) return;
  const icon = (vol && vol > 0) ? "ğŸ”Š" : "ğŸ”‡";
  seBtn.textContent = "SE" + icon;
}



// === range fill helper (keep the â€œä¼¸ã³ç¸®ã¿â€ visual) ===
function updateRangeFill(el){
  try{
    if(!el) return;
    const min = Number(el.min||0);
    const max = Number(el.max||100);
    const v = Number(el.value||0);
    const t = (v - min) / Math.max(1e-9, (max - min));
    const pct = Math.max(0, Math.min(1, t)) * 100;

    // New: CSS var driven (mobile custom range)
    try{ el.style.setProperty('--fill-pct', pct + '%'); }catch(_){ }

    // Back-compat: backgroundSize directly (if used)
    try{
      const trackH = getComputedStyle(el).getPropertyValue('--track-h').trim() || '4px';
      el.style.backgroundSize = (pct + '% ' + trackH);
    }catch(_){ }
  }catch(_){}
}

// === Helper: force UI refresh on some mobile browsers after programmatic value changes ===
function dispatchRangeInput(el){
  try{
    if(!el) return;
    const ev = new Event('input', { bubbles:true });
    el.dispatchEvent(ev);
  }catch(_){}
}

function onBgmSliderChange(v){
  if (IS_IOS){ try{ ensureGraph(); connectKnownAudio(); }catch(_){ } }

  v = Number(v);
  if (isNaN(v)) v = 0;
  const vol = Math.max(0, Math.min(100, v)) / 100;// åæ˜ ï¼ˆBGMã¯ãƒŸãƒ¥ãƒ¼ãƒˆæ™‚ã‚‚ã€Œpauseã—ãªã„ã€ï¼å†é–‹å®‰å®šæ€§å„ªå…ˆï¼‰
  setBGMVol(vol);
  try{ if(bgmSlider) updateRangeFill(bgmSlider); }catch(_){ }
bgmOn = vol > 0;
  // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼æ“ä½œã¯ã€ŒéŸ³é‡ãã®ã‚‚ã®ã€ã‚’æ„å‘³ã™ã‚‹ãŸã‚ã€ãƒœã‚¿ãƒ³ãƒŸãƒ¥ãƒ¼ãƒˆçŠ¶æ…‹ã¯è§£é™¤
  bgmMuted = false;
  store.set("bgmMuted", false);
  store.set("bgmOn", bgmOn);
  store.set("bgmVol", vol);
  if (vol > 0) store.set("bgmLast", vol);

  updateBgmIcon(vol);

  if (bgmOn){
    try{ safeStartBGM(currentBGM()); }catch(_){}
  } else {
    // 0ã®å ´åˆã¯åœæ­¢ã›ãšãƒŸãƒ¥ãƒ¼ãƒˆã®ã¿ï¼ˆiOS/Chromeã®å†é–‹ä¸å®‰å®šã‚’å›é¿ï¼‰
    try{
      // æ—¢ã«å†ç”Ÿä¸­ãªã‚‰ãã®ã¾ã¾ã€‚åœæ­¢ã—ã¦ã„ã‚‹å ´åˆã‚‚ã“ã“ã§ã¯å†ç”Ÿé–‹å§‹ã—ãªã„ã€‚
      // ï¼ˆONå¾©å¸°æ™‚ã« safeStartBGM ãŒèµ°ã‚‹ï¼‰
    }catch(_){}
  }
}

function onSeSliderChange(v){
  if (IS_IOS){ try{ ensureGraph(); }catch(_){ } }

  v = Number(v);
  if (isNaN(v)) v = 0;
  const pct = Math.max(0, Math.min(100, v));
  const vol = pct / 100;

  if (vol <= 0){
    Sound.enabled = false;
  } else {
    Sound.enabled = true;
    setSEVol(vol);
    // æœ€å¾Œã®é0å€¤ã‚’ä¿å­˜ï¼ˆSEãƒœã‚¿ãƒ³ONå¾©å¸°ç”¨ï¼‰
    store.set("seLastPct", pct);
  }

  // UIåæ˜ 
  try{ if(seSlider) seSlider.value = String(pct); }catch(_){ }
  try{ if(seSlider) updateRangeFill(seSlider); }catch(_){ }

  store.set("seOn", Sound.enabled);
  store.set("seVol", Sound.vol);
  // WebAudioãƒã‚¹éŸ³é‡ï¼ˆiOSã§audio.volumeãŒåŠ¹ã‹ãªã„ã‚±ãƒ¼ã‚¹ã®ãŸã‚ï¼‰
  try{ var g = ensureGraph(); if (g && g.se && g.se.gain) g.se.gain.value = Sound.enabled ? Sound.vol : 0; }catch(_){ }
  updateSeIcon(Sound.enabled ? Sound.vol : 0);
}

// attach slider events
if (bgmSlider){
  bgmSlider.addEventListener("input", e => { onBgmSliderChange(e.target.value); });
  bgmSlider.addEventListener("change", ()=>{ try{ onClickSE(); }catch(_){ } });
}
if (seSlider){
  seSlider.addEventListener("input", e => { onSeSliderChange(e.target.value); });
  seSlider.addEventListener("change", ()=>{ try{ onClickSE(); }catch(_){ } });
}
// iOS/Chromeã§rangeã®ãƒ‰ãƒ©ãƒƒã‚°ãŒéˆã„/åå¿œã—ãªã„å¯¾ç­–ï¼špointer/touchç§»å‹•ã§å€¤ã‚’ç›´æ¥æ›´æ–°ã™ã‚‹
function enhanceRangeSlider(el, onValue){
  if (!el) return;
  try{ if (el.dataset && el.dataset.rangeDirect==='1') return; }catch(_){ }
  try{ if (el.dataset) el.dataset.rangeDirect='1'; }catch(_){ }
  const hit = el.closest(".slider-hit") || el;
  try{ hit.style.touchAction = "none"; }catch(_){}
  const setFromClientX = (clientX)=>{
    const r = hit.getBoundingClientRect();
    const x = Math.min(r.right, Math.max(r.left, clientX));
    const t = (x - r.left) / Math.max(1, (r.width));
    const min = Number(el.min || 0);
    const max = Number(el.max || 100);
    const step = Number(el.step || 1);
    let val = min + t * (max - min);
    // stepã«ã‚¹ãƒŠãƒƒãƒ—
    val = Math.round(val / step) * step;
    val = Math.max(min, Math.min(max, val));
    el.value = String(val);
    try{ updateRangeFill(el); }catch(_){ }
try{ onValue(el.value); }catch(_){}
    try{ if(dragging) onSliderDragSE(); }catch(_){ }
  };

  let dragging = false;

  const onDown = (e)=>{
    dragging = true;
    try{ e.preventDefault(); }catch(_){}
    const p = e.touches ? e.touches[0] : e;
    if (p) setFromClientX(p.clientX);
  };
  const onMove = (e)=>{
    if (!dragging) return;
    try{ e.preventDefault(); }catch(_){}
    const p = e.touches ? e.touches[0] : e;
    if (p) setFromClientX(p.clientX);
  };
  const onUp = (e)=>{
    if (!dragging) return;
    dragging = false;
    try{ e.preventDefault(); }catch(_){}
    // ã¤ã¾ã¿æ“ä½œçµ‚äº†æ™‚ã«ä¸€åº¦ã ã‘ã‚¯ãƒªãƒƒã‚¯SE
    try{ onClickSE(); }catch(_){}
  };

  hit.addEventListener("pointerdown", onDown, { passive:false });
  window.addEventListener("pointermove", onMove, { passive:false });
  window.addEventListener("pointerup", onUp, { passive:false });

  hit.addEventListener("touchstart", onDown, { passive:false });
  window.addEventListener("touchmove", onMove, { passive:false });
  window.addEventListener("touchend", onUp, { passive:false });
}
enhanceRangeSlider(bgmSlider, onBgmSliderChange);
enhanceRangeSlider(seSlider, onSeSliderChange);


// === Native input fallback (iOS reliability): ensure volume changes on real range events ===
try{
  if (bgmSlider){
    bgmSlider.addEventListener("input", (e)=>{ try{ onBgmSliderChange(e.target.value); }catch(_){ } }, {passive:true});
  }
  if (seSlider){
    seSlider.addEventListener("input", (e)=>{ try{ onSeSliderChange(e.target.value); }catch(_){ } }, {passive:true});
  }
}catch(_){}


const BGM_DEFAULT_VOL = 0.35;
const SE_DEFAULT_VOL  = 0.25;
    
function makePool(baseEl, n){
  // baseEl: an existing <audio> element in the DOM
  const arr = [baseEl.cloneNode(true)];
  try{ arr[0].pause(); }catch(_){}
  try{ arr[0].currentTime = 0; }catch(_){}
  for(let i=1;i<n;i++){
    const clone = baseEl.cloneNode(true);
    try{ clone.pause(); }catch(_){}
    try{ clone.currentTime = 0; }catch(_){}
    arr.push(clone);
  }
  let idx = 0;
  return {
    play(vol){
      const el = arr[idx++ % arr.length];
      try{ el.pause(); }catch(_){}
      try{ el.currentTime = 0; }catch(_){}
      try{ el.volume = vol; }catch(_){ }
      // iOSã®ã¿ï¼šSEãƒã‚¹ã¸æ¥ç¶šï¼ˆã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’ç¢ºå®Ÿã«åŠ¹ã‹ã›ã‚‹ï¼‰
      if (IS_IOS){ try{ var g = ensureGraph(); if (g) connectToBus(el, g.se); }catch(_){ } }
      el.play().catch(()=>{});
    }
  };
}
const SE_BANK = {
  vertical:document.getElementById("se_vertical"),
  horizontal:document.getElementById("se_horizontal"),
  circle:document.getElementById("se_circle"),
  cross:document.getElementById("se_cross"),
  pop:document.getElementById("se_pop"),
  item:document.getElementById("se_item"),
  itemskill:document.getElementById("se_itemskill"),
  whoosh:document.getElementById("se_whoosh"),
  rumble:document.getElementById("se_rumble"),
  shine:document.getElementById("se_shine"),
  push:document.getElementById("se_push"), 
  index:document.getElementById("se_index"), /* index open */
  /* â˜…push.mp3ã‚’è¿½åŠ  */
  bell:document.getElementById("se_bell"),
  not:document.getElementById("se_not"),
  scream:document.getElementById("se_scream"),
};
const Sound={
  enabled:store.get("seOn", true),
  vol:store.get("seVol", SE_DEFAULT_VOL),
  pools:{},
  // SEã”ã¨ã®è£œæ­£ï¼ˆåŒã˜ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã§ã‚‚ç´ æéŸ³åœ§å·®ã‚’å¸åï¼‰
  mul:{ rumble: 0.60 },
  // é€£æ‰“/åŒæ™‚ç™ºç«ã§â€œéŸ³é‡ãŒçªå‡ºâ€ã—ã‚„ã™ã„SEã¯é–“å¼•ã
  _last:{},
  init(){
    for(const k in SE_BANK){
      if(SE_BANK[k]) this.pools[k]=makePool(SE_BANK[k],6);
    }
  },
  play(n, volMul=1){
    if(!this.enabled) return;
    const p=this.pools[n];
    if(!p) return;

    // rumbleã¯åŒãƒ•ãƒ¬ãƒ¼ãƒ å¤šé‡ç™ºç«ã§åŠ ç®—çš„ã«å¤§ãããªã‚Šã‚„ã™ã„ã®ã§ãƒ¬ãƒ¼ãƒˆåˆ¶é™
    if (n==="rumble"){
      const now = (typeof performance!=='undefined' && performance.now) ? performance.now() : Date.now();
      const prev = this._last.rumble || 0;
      if (now - prev < 120) return; // 120msä»¥å†…ã¯ç„¡è¦–
      this._last.rumble = now;
    }

    const m = (this.mul && this.mul[n]!=null) ? this.mul[n] : 1;
    const g = window.__audioGraph;
    const v = (g && g.se && g.se.gain) ? (volMul * m) : (this.vol * volMul * m);
    p.play(v);
  },
};
Sound.init();

/* ===== Voice priority & stable playback (Ducking + Gesture Queue) ===== */
window.Sound = Sound; // expose for other helper scripts

let __voiceCurrent = null;
let __ducking = false;
let __duckReleaseTimer = null;


// iOSã§audio.volumeãŒåŠ¹ã‹ãªã„/ç«¯æœ«ä¾å­˜ã«ãªã‚‹å ´åˆã«å‚™ãˆã€WebAudio(GainNode)ã§éŸ³é‡åˆ¶å¾¡ã™ã‚‹
function connectToBus(el, bus){
  try{
    if (!IS_IOS) return;
    if (!el || !bus) return;
    const g = window.__audioGraph;
    if (!g || !g.ctx || !g.sources) return;
    if (g.sources.has(el)) return;
    const src = g.ctx.createMediaElementSource(el);
    src.connect(bus);
    g.sources.set(el, src);
  }catch(_){}
}
function connectKnownAudio(){
  try{
    if (!IS_IOS) return;
    const g = ensureGraph();
    if (!g) return;
    // BGMè¦ç´ ï¼ˆ2æ›²ï¼‰ã‚’å¿…ãšãƒã‚¹ã¸
    try{ if (bgm1) connectToBus(bgm1, g.bgm); }catch(_){}
    try{ if (bgm2) connectToBus(bgm2, g.bgm); }catch(_){}
  }catch(_){}
}

function __clamp01(x){ x = Number(x); return isFinite(x) ? Math.max(0, Math.min(1, x)) : 0; }

function __applyBgmVolume(){
  const base = __clamp01(store.get("bgmVol", BGM_DEFAULT_VOL));
  const iosLimit = (typeof IS_IOS!=="undefined" && IS_IOS) ? 0.8 : 1.0;
  const eff  = ((bgmOn && !bgmMuted) ? (base * iosLimit) : 0) * (__ducking ? 0.25 : 1);

  // WebAudioãƒã‚¹ãŒã‚ã‚Œã°Gainã§åˆ¶å¾¡ï¼ˆiOSã§ç¢ºå®Ÿï¼‰
  try{
    const g = window.__audioGraph;
    if (g && g.bgm && g.bgm.gain){
      g.bgm.gain.value = eff;
      return;
    }
  }catch(_){}

  // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
  try{ bgm1.volume = eff; }catch(_){}
  try{ bgm2.volume = eff; }catch(_){}
}

function __applySeVolume(){
  const eff = __getSeEffectiveVol();
  try{
    const g = window.__audioGraph;
    if (g && g.se && g.se.gain){
      g.se.gain.value = eff;
      return;
    }
  }catch(_){}
}

function __getSeEffectiveVol(){
  const base = __clamp01(store.get("seVol", SE_DEFAULT_VOL));
  if (!Sound.enabled) return 0;
  return base * (__ducking ? 0.6 : 1);
}

function __setElementVolumeSafe(el, vol){
  try{ el.volume = __clamp01(vol); }catch(_){}
}

function __fade(fnSet, from, to, ms){
  from = Number(from); to = Number(to); ms = Math.max(0, Number(ms)||0);
  const t0 = performance.now();
  function step(now){
    const t = ms ? Math.min(1, (now - t0) / ms) : 1;
    const v = from + (to - from) * t;
    try{ fnSet(v); }catch(_){}
    if (t < 1) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

// Gesture queue: if play() is blocked, retry on next user gesture once.
const __gestureQueue = [];
let __gestureHooked = false;
function __hookGestureOnce(){
  if (__gestureHooked) return;
  __gestureHooked = true;
  const flush = ()=>{
    while(__gestureQueue.length){
      const fn = __gestureQueue.shift();
      try{ fn(); }catch(_){}
    }
  };
  window.addEventListener("pointerdown", flush, { passive:true });
  window.addEventListener("touchstart",  flush, { passive:true });
  window.addEventListener("mousedown",   flush, { passive:true });
}
__hookGestureOnce();

function __playMedia(el){
  if (!el) return;
  try{
    const p = el.play();
    if (p && typeof p.catch === "function"){
      p.catch(()=>{
        // iOSå¯¾ç­–ï¼šã‚¸ã‚§ã‚¹ãƒãƒ£å¾…ã¡ã ã‘ã«ã›ãšã€çŸ­ã„ãƒªãƒˆãƒ©ã‚¤ã‚‚è¡Œã†ï¼ˆé€£é–ä¸­ã«å–ã‚Šã“ã¼ã•ãªã„ï¼‰
        try{ el.load && el.load(); }catch(_){}
        try{
          if (!el.__retrying){
            el.__retrying = true;
            setTimeout(()=>{ try{ el.play().catch(()=>{}); }catch(_){ } }, 60);
            setTimeout(()=>{ try{ el.play().catch(()=>{}); }catch(_){ } finally{ el.__retrying = false; } }, 260);
          }
        }catch(_){ el.__retrying = false; }
        __gestureQueue.push(()=>{ try{ el.play().catch(()=>{}); }catch(_){ } });
      });
    }
  }catch(_){
    try{ el.load && el.load(); }catch(__){}
    try{
      if (!el.__retrying){
        el.__retrying = true;
        setTimeout(()=>{ try{ el.play().catch(()=>{}); }catch(_){ } }, 60);
        setTimeout(()=>{ try{ el.play().catch(()=>{}); }catch(_){ } finally{ el.__retrying = false; } }, 260);
      }
    }catch(__){ el.__retrying = false; }
    __gestureQueue.push(()=>{ try{ el.play().catch(()=>{}); }catch(_){ } });
  }
}

window.__playMediaSafe = __playMedia;
window.__getSeEffectiveVol = __getSeEffectiveVol;

function __setBgmVolPair(v){
  v = __clamp01(v);
  try{ bgm1.volume = v; }catch(_){}
  try{ bgm2.volume = v; }catch(_){}
}
function __getBgmBaseVol(){
  const base = __clamp01(store.get("bgmVol", BGM_DEFAULT_VOL));
  return (bgmOn && !bgmMuted) ? base : 0;
}
let __duckToken = 0;

function __startDucking(){
  // Smooth "attack" to avoid sudden drops (ear-fatiguing)
  if (__duckReleaseTimer){ clearTimeout(__duckReleaseTimer); __duckReleaseTimer = null; }
  const token = ++__duckToken;
  const base  = __getBgmBaseVol();
  const target = __clamp01(base * 0.25);

  // Mark ducking active for SE/voice scaling
  __ducking = true;

  // Fade from current -> target
  const from = __clamp01((bgm1 && typeof bgm1.volume === 'number') ? bgm1.volume : base);
  __fade((v)=>{ if(token===__duckToken) __setBgmVolPair(v); }, from, target, 220);
}

function __releaseDucking(ms){
  // Smooth "release" and keep ducking until voice actually ends
  if (__duckReleaseTimer){ clearTimeout(__duckReleaseTimer); __duckReleaseTimer = null; }
  const token = ++__duckToken;
  const base = __getBgmBaseVol();
  const from = __clamp01((bgm1 && typeof bgm1.volume === 'number') ? bgm1.volume : (base*0.25));
  const to   = __clamp01(base);
  __duckReleaseTimer = setTimeout(()=>{
    __ducking = false;
    __fade((v)=>{ if(token===__duckToken) __setBgmVolPair(v); }, from, to, 420);
  }, Math.max(0, Number(ms)||0));
}

// Public: play voice by element id (combo/rank/reset etc.)
window.playVoiceById = function(voiceId){
  try{
    const el = document.getElementById(voiceId);
    if (!el) return;

    if (__voiceCurrent && __voiceCurrent !== el){
      try{ __voiceCurrent.pause(); }catch(_){}
    }
    __voiceCurrent = el;

    __startDucking();

    const baseSe = __clamp01(store.get("seVol", SE_DEFAULT_VOL));
    // Voice gain is intentionally louder than SE so that voice remains intelligible.
    const voiceBoost = Number(store.get("voiceBoost", 2.2));
    const voiceFloor = Number(store.get("voiceFloor", 0.45));
    const voiceVol = __clamp01(baseSe<=0 ? 0 : Math.max(voiceFloor, baseSe * voiceBoost));
    __setElementVolumeSafe(el, voiceVol);
    try{ var g=ensureGraph(); if(g) connectToBus(el, g.se); }catch(_){ }

    try{ el.currentTime = 0; }catch(_){}
    __playMedia(el);

    // Release ducking when the voice really ends (and do it gently).
    el.onended = ()=>{ try{ __releaseDucking(120); }catch(_){ } };

    // Safety: if 'ended' does not fire (rare on some mobile browsers), release after duration.
    try{
      const d = Number(el.duration);
      const ms = (isFinite(d) && d > 0) ? Math.min(7000, Math.max(800, d*1000 + 180)) : 4200;
      if (__duckReleaseTimer){ clearTimeout(__duckReleaseTimer); __duckReleaseTimer = null; }
      __duckReleaseTimer = setTimeout(()=>{
        if (el === __voiceCurrent){ try{ __releaseDucking(120); }catch(_){ } }
      }, ms);
    }catch(_){}
}catch(_){}
};


function setBGMVol(v){ const nv=Number(v); store.set("bgmVol", nv); __applyBgmVolume(); }
function setSEVol(v){ const nv=Number(v); Sound.vol=nv; store.set("seVol", nv); __applySeVolume(); }

function toggleSE(){
  if (!seSlider){
    Sound.enabled = !Sound.enabled;
    store.set("seOn", Sound.enabled);
    updateSeIcon(Sound.enabled ? Sound.vol : 0);
    return;
  }

  const nowPct = Number(seSlider.value || "0");
  if (nowPct > 0){
    // OFF: ç¾åœ¨å€¤ã‚’è¨˜æ†¶ã—ã¦0ã¸ï¼ˆè¡¨ç¤ºã‚‚è¿½å¾“ï¼‰
    store.set("seLastPct", nowPct);
    seSlider.value = "0";
    try{ updateRangeFill(seSlider); }catch(_){ }
    dispatchRangeInput(seSlider);
    onSeSliderChange(0);
    return;
  }

  // ON: ç›´å‰ã®å€¤ã¸å¾©å¸°ï¼ˆãªã‘ã‚Œã°ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰
  const last = Number(store.get("seLastPct", 50));
  const restore = (isNaN(last) || last <= 0) ? 50 : Math.max(1, Math.min(100, last));
  seSlider.value = String(restore);
  try{ updateRangeFill(seSlider); }catch(_){ }
  dispatchRangeInput(seSlider);
  onSeSliderChange(restore);
}

function pauseAllBGM(){
  try{ if(bgm1) bgm1.pause(); }catch(_){}
  try{ if(bgm2) bgm2.pause(); }catch(_){}
  // cancel any pending start attempts
  bgmPlayToken++;
  bgmPlayPending = false;
}
function currentBGM(){ return activeBGM===bgm2?bgm2:bgm1; }
function safeStartBGM(bgmEl){
  try{
    if (IS_IOS){ try{ ensureGraph(); }catch(_){ } }

    if (!bgmEl) return;
    // é‡è¤‡å†ç”Ÿé˜²æ­¢ï¼šã‚¿ãƒ¼ã‚²ãƒƒãƒˆä»¥å¤–ã®BGMã¯å¿…ãšåœæ­¢
    try{
      if (bgm1 && bgmEl!==bgm1){ bgm1.pause(); }
      if (bgm2 && bgmEl!==bgm2){ bgm2.pause(); }
    }catch(_){ }
if (!bgmOn) return;

    // å¸¸ã«ã€Œç‰‡æ–¹ã ã‘ã€å†ç”Ÿã™ã‚‹ï¼ˆå¤šé‡å†ç”Ÿé˜²æ­¢ï¼‰
    const other = (bgmEl === bgm1) ? bgm2 : bgm1;
    try{ if(other && !other.paused) other.pause(); }catch(_){}

    // æ—¢ã«å†ç”Ÿä¸­ãªã‚‰ä½•ã‚‚ã—ãªã„
    try{ if(!bgmEl.paused) return; }catch(_){}

    // ç›´è¿‘ã®é–‹å§‹è¦æ±‚ãŒå‡¦ç†ä¸­ãªã‚‰é‡ã­ãªã„
    if (bgmPlayPending) return;

    bgmPlayPending = true;
    const token = ++bgmPlayToken;

    const p = bgmEl.play();
    if (p && typeof p.then === "function"){
      p.then(()=>{ bgmEverStarted = true; }).catch(()=>{}).finally(()=>{
        if (bgmPlayToken === token){
          bgmPlayPending = false;
        }
      });
    } else {
      bgmPlayPending = false;
    }
  }catch(_){
    bgmPlayPending = false;
  }
}

function updateBGMSelectButton(){
  const which = activeBGM === bgm2 ? 2 : 1;
  bgmSelectBtn.textContent = (which === 1) ? "â™ª1 BGMåˆ‡æ›¿" : "â™ª2 BGMåˆ‡æ›¿";
  // ã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼šã©ã¡ã‚‰ã‚’é¸ã‚“ã§ã„ã‚‹ã‹è‰²ã§åŒºåˆ¥ã—ãŸã„å ´åˆã®ã‚¯ãƒ©ã‚¹åˆ¶å¾¡
  try{
    bgmSelectBtn.classList.remove('bgm1-active','bgm2-active');
    if (which === 1) bgmSelectBtn.classList.add('bgm1-active');
    else bgmSelectBtn.classList.add('bgm2-active');
  }catch(_){}
}

/* â˜…BGMåˆ‡æ›¿ï¼ˆâ™ª1/â™ª2ã®åˆ‡ã‚Šæ›¿ãˆãƒœã‚¿ãƒ³ã®ãƒ­ã‚¸ãƒƒã‚¯ï¼‰ */
function toggleBGMSelect(){
  const newWhich = activeBGM === bgm1 ? 2 : 1;
  selectBGM(newWhich);
  updateBGMSelectButton();
}

function toggleBGM(){
  if (!bgmSlider){
    bgmOn = !bgmOn;
    store.set("bgmOn", bgmOn);
    updateBgmIcon(bgmOn ? bgmVol : 0);
    if (bgmOn){
      try{ safeStartBGM(currentBGM()); }catch(_){}
    }
    return;
  }

  const nowPct = Number(bgmSlider.value || "0");

  if (nowPct > 0){
    // OFF: ç¾åœ¨ä½ç½®ã‚’ä¿å­˜ã—ã¦0ã¸ï¼ˆè¡¨ç¤º=fillã‚‚0ï¼‰ã€‚éŸ³ã¯ãƒŸãƒ¥ãƒ¼ãƒˆæ‰±ã„ã€‚
    store.set("bgmLastPct", nowPct);
    bgmSlider.value = "0";
    try{ updateRangeFill(bgmSlider); }catch(_){}
    try{ dispatchRangeInput(bgmSlider); }catch(_){}
    try{ onBgmSliderChange(0); }catch(_){}
    updateBgmIcon(0);
    return;
  }

  // ON: ç›´å‰ã®ä½ç½®ã¸å¾©å¸°ï¼ˆãªã‘ã‚Œã° bgmLast/bgmVol ã‹ã‚‰å¾©å…ƒã€æœ€çµ‚çš„ã«25ï¼‰
  let lastPct = Number(store.get("bgmLastPct", NaN));
  if (isNaN(lastPct) || lastPct <= 0){
    const lastVol = Number(store.get("bgmLast", NaN)); // 0..1
    if (!isNaN(lastVol) && lastVol > 0) lastPct = Math.round(lastVol * 100);
  }
  if (isNaN(lastPct) || lastPct <= 0){
    const vol = Number(store.get("bgmVol", bgmVol || 0.25)); // 0..1
    lastPct = Math.round(Math.max(0.01, Math.min(1, vol)) * 100);
  }
  lastPct = Math.max(1, Math.min(100, lastPct));

  bgmSlider.value = String(lastPct);
  try{ updateRangeFill(bgmSlider); }catch(_){}
  try{ dispatchRangeInput(bgmSlider); }catch(_){}
  try{ onBgmSliderChange(lastPct); }catch(_){}
}

function selectBGM(which){
  pauseAllBGM();
  activeBGM = (which===2)?bgm2:bgm1;
  store.set("activeBGM", which);
  setBGMVol(store.get("bgmVol", BGM_DEFAULT_VOL));
  try{ activeBGM.currentTime = 0; }catch(_){}

  updateBGMSelectButton(); // è¡¨ç¤ºæ›´æ–°ï¼ˆãƒ©ãƒ™ãƒ«/è‰²ï¼‰

  if(bgmOn){
    // å†ç”Ÿã¯å¿…ãšã‚¬ãƒ¼ãƒ‰ä»˜ãã§é–‹å§‹
    safeStartBGM(currentBGM());
  } else { 
    pauseAllBGM(); 
    updateBgmIcon(0);
  }
}

/* åˆå›ã‚¸ã‚§ã‚¹ãƒãƒ£ã§BGM/SEè§£ç¦ */

let audioUnlocked=false;
function unlockAllSE(){
  if(audioUnlocked) return;
  audioUnlocked = true;

  // iOSã§â€œè§£ç¦â€ç›®çš„ã«å…¨audioã‚’playã™ã‚‹ã¨ã€ä¸€æ–‰å†ç”Ÿï¼ˆå…¨éƒ¨é³´ã‚‹ï¼‰ãƒã‚°ã‚’èª˜ç™ºã—ã‚„ã™ã„ã€‚
  // ã“ã“ã§ã¯ preload ã®ã¿ã«ç•™ã‚ã‚‹ã€‚
  const audioElements = Array.from(document.querySelectorAll('audio'));
  for (const a of audioElements){
    if (!a) continue;
    try{
      try{ a.pause(); }catch(_){}
      try{ a.currentTime = 0; }catch(_){}
      try{ a.load(); }catch(_){}
    }catch(_){}
  }
}

function userGesture(){
  // ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œã‚’å¥‘æ©Ÿã«ã‚¢ãƒ³ãƒ­ãƒƒã‚¯ã—ã€BGMãŒæœ‰åŠ¹ãªã‚‰ã€Œã‚¬ãƒ¼ãƒ‰ä»˜ãã€ã§é–‹å§‹ã‚’è©¦ã¿ã‚‹ã€‚
  // currentTimeã®ãƒªã‚»ãƒƒãƒˆã¯è¡Œã‚ãªã„ï¼ˆé‡é£›ã³/å¤šé‡å†ç”Ÿã®åŸå› ï¼‰
  unlockAllSE();
  try{
    const base = store.get("bgmVol", BGM_DEFAULT_VOL);
    if (!bgmMuted && base > 0){
      safeStartBGM(currentBGM());
    }
  }catch(_){}
}

(function initAudio(){
  // BGMåˆæœŸãƒœãƒªãƒ¥ãƒ¼ãƒ ã‚’å–å¾—ã—ã¦åæ˜ 
  const initBgmVol = store.get("bgmVol", BGM_DEFAULT_VOL);
  setBGMVol(initBgmVol);

  // SEåˆæœŸçŠ¶æ…‹ï¼šã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã¨ã‚¢ã‚¤ã‚³ãƒ³ã¸åæ˜ 
  if (seSlider){
    if (!Sound.enabled){
      seSlider.value = 0;
      updateSeIcon(0);
    } else {
      const seVol = Sound.vol || SE_DEFAULT_VOL;
      seSlider.value = Math.round(seVol * 100);
      try{ updateRangeFill(seSlider); }catch(_){ }
updateSeIcon(seVol);
    }
  } else {
    updateSeIcon(Sound.enabled ? Sound.vol : 0);
  }

  // BGMã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã¨ã‚¢ã‚¤ã‚³ãƒ³ã¸åæ˜ 
  if (bgmSlider){
    bgmSlider.value = Math.round(initBgmVol * 100);
    try{ updateRangeFill(bgmSlider); }catch(_){ }
updateBgmIcon(initBgmVol);
  } else {
    updateBgmIcon(bgmOn ? initBgmVol : 0);
  }

  // ãƒŸãƒ¥ãƒ¼ãƒˆçŠ¶æ…‹ã‚‚å«ã‚ã¦æœ‰åŠ¹éŸ³é‡ã‚’åæ˜ 
  try{ __applyBgmVolume(); }catch(_){ }

const which=store.get("activeBGM",1);
  activeBGM = which===2?bgm2:bgm1;
  updateBGMSelectButton(); /* BGMåˆ‡æ›¿ãƒœã‚¿ãƒ³ã®è¡¨ç¤ºæ›´æ–° */

  if(bgmOn){
    // å†ç”Ÿå‰ã«å¿…ãšéã‚¢ã‚¯ãƒ†ã‚£ãƒ–BGMã‚’åœæ­¢ï¼ˆé‡ãªã‚Šé˜²æ­¢ï¼‰
    try{ pauseAllBGM(); }catch(_){ }
    // å†ç”Ÿã¯å¿…ãšã‚¬ãƒ¼ãƒ‰ä»˜ãã§é–‹å§‹
    try{ safeStartBGM(currentBGM()); }catch(_){ }
  } else {
    pauseAllBGM();
    updateBgmIcon(0);
  }
})();

/* â˜…SEå†ç”Ÿã®ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆé–¢æ•° */
const onClickSE = ()=>Sound.play('push', .9);

// ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼æ“ä½œä¸­ã®SEï¼ˆé€£æ‰“æŠ‘åˆ¶ï¼‰
let __sliderSELast = 0;
function onSliderDragSE(){
  try{
    if(!Sound || !Sound.enabled) return;
    const t = (typeof performance!=='undefined' && performance.now) ? performance.now() : Date.now();
    if (t - __sliderSELast < 90) return; // ä½“æ„Ÿé‡è¦–ï¼šéå‰°é€£æ‰“ã‚’é˜²ã
    __sliderSELast = t;
    Sound.play('push', 0.35);
  }catch(_){ }
}

/* ===== DOM & åŸºæœ¬è¨­å®šï¼ˆA åŸºæº–ï¼‰ ===== */
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d", { alpha:true });
// PCã®é§’æç”»ã‚’ã‚·ãƒ£ãƒ¼ãƒ—ã«ï¼ˆè² è·ã¯DPRè¨­å®šã«ä¾å­˜ï¼‰
ctx.imageSmoothingEnabled = true;
ctx.imageSmoothingQuality = "high";
const $pauseBtn = document.getElementById("pauseBtn");
const $score = document.getElementById("score");
const $rank = document.getElementById("rank");
let $rankProgress = document.getElementById("rankProgress");
const $status = document.getElementById("status");
/* â˜…IDã‚’char-modalã‹ã‚‰charModalã«å¤‰æ›´ */
const $charModal = document.getElementById("charModal");
const $charList = document.getElementById("char-list");

/* â˜…ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ¡ãƒ‹ãƒ¥ãƒ¼DOM */
const $indexBtn = document.getElementById('indexBtn');
const $indexModal = document.getElementById('indexModal');
const $openHowtoBtn = document.getElementById('openHowtoBtn');
const $btnCharIntroIndex = document.getElementById('btnCharIntroIndex');

/* â˜…ãƒªã‚»ãƒƒãƒˆãƒ¢ãƒ¼ãƒ€ãƒ«DOM */
const $resetConfirmModal = document.getElementById('resetConfirmModal');

/* â˜…æ“ä½œèª¬æ˜ãƒ¢ãƒ¼ãƒ€ãƒ«DOM (Howto) */
const $howtoModal = document.getElementById('howtoModal');
const $howtoImg = document.getElementById('howtoImg');
const $howtoCounter = document.getElementById('howtoCounter');
const $howtoPrev = document.getElementById('howtoPrev');
const $howtoNext = document.getElementById('howtoNext');


const size = 7;
let logicalSize = 400;
let tileSize = logicalSize/size;
let isMobileViewport = window.matchMedia && window.matchMedia('(max-width: 900px)').matches;
let dprRaw = (window.devicePixelRatio || 1);
let DPR = isMobileViewport ? Math.min((typeof IS_IOS!=="undefined" && IS_IOS)?1.5:2, dprRaw) : Math.max(2, Math.min(3, dprRaw));
let paused = false;
let isKanki = true;
const DRAG_THRESHOLD = 0.35;

/* ===== ç”»åƒ (çœç•¥: å¤‰æ›´ãªã—) ===== */
const IMG = { 
  "SANZU": new Image(), "MUTSU": new Image(), "HANZO": new Image(), "CHIEKO": new Image(), "KUJAKU": new Image(),
  "SHURACHAN": new Image(), "REKUSHURA": new Image(),
  "S_BIR": new Image(), "S_NE0": new Image(), "S_SHU": new Image(), "S_REQ": new Image(), "S_UNK": new Image(),
  "J_NEM": new Image(), "J_SHI": new Image(), "J_PRO": new Image(),
  "PATH_SANZU": "images/sanzu.png",
  "PATH_MUTSU": "images/mutsu.png",
  "PATH_HANZO": "images/hanzo.png",
  "PATH_CHIEKO": "images/chieko.png",
  "PATH_KUJAKU": "images/kujaku.png",
  "PATH_SHURACHAN": "images/shurachan.png",
  "PATH_REKUSHURA": "images/requshura.png",
  "PATH_S_BIR": "images/special_bir.png",
  "PATH_S_NE0": "images/special_ne0.png",
  "PATH_S_SHU": "images/special_shu.png",
  "PATH_S_REQ": "images/special_req.png",
  "PATH_S_UNK": "images/special_unk.png",
  "PATH_J_NEM": "images/nemu.png",
  "PATH_J_SHI": "images/shinjuro.png",
  "PATH_J_PRO": "images/propaganda.png",
  "BG": new Image(), "PATH_BG": "images/boad_bg.png"
};
function loadImages(done){ 
    // Resilient loader for case-sensitive hosts (GitHub Pages)
  const triedFallback = new Set();
  function tryFallback(key){
    const el = IMG[key];
    const p  = IMG["PATH_"+key];
    if (!p || triedFallback.has(key)) return false;
    triedFallback.add(key);
    let url = p;

    // Special known typo fallback: boad_bg.png -> board_bg.png
    if (key === "BG" && /images\/boad_bg\.png$/i.test(p)){
      url = p.replace(/boad_bg\.png$/i, "board_bg.png");
      try{ el.src = url; return true; }catch(_){}
    }
// Special fallback for Neoretro asset naming variations
if (key === "S_NE0"){
  const candidates = [
    "images/neoretro.png",
    "images/Neoretro.png",
    "images/special_neoretro.png",
    "images/special_ne0.png"
  ];
  for (const c of candidates){
    if (c === p) continue;
    try{ el.src = c; return true; }catch(_){}
  }
}


    // General fallback: lowercased basename for case mismatches (e.g., KUJAKU.png vs kujaku.png)
    const m = p.match(/^(.*\/)([^\/]+)$/);
    if (m){
      const dir = m[1], base = m[2];
      const lower = dir + base.toLowerCase();
      if (lower !== p){
        try{ el.src = lower; return true; }catch(_){}
      }
    }
    return false;
  }
let loaded=0; const keys=Object.keys(IMG).filter(k=>!k.startsWith('PATH_')); const total=keys.length;
  if(total===0){ done(); return; }
  keys.forEach(k=>{
    IMG[k].onload = ()=>{ if(++loaded===total) done(); };
    IMG[k].onerror = ()=>{
      // attempt fallback once; otherwise count and continue
      if (!tryFallback(k)){
        if(++loaded===total) done();
        if (/\bdebugload=1\b/.test(location.search)){
          (window.__missingAssets ||= []).push(IMG["PATH_"+k] || k);
        }
      }
    };
    const p=IMG["PATH_"+k]; if(p) IMG[k].src=p;
  });}

/* ===== ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼å›³é‘‘ (çœç•¥: å¤‰æ›´ãªã—) ===== */
const CHARACTERS = [ 
  { sym: "CHIEKO", name: "ç¾æ¯’ä¸¸", tag: "å¼ç¥", desc: "ä¿®ç¾…ç‹ä¸¸ã®æœ€å¤ã®å¼ç¥ã€‚/ é€šå¸¸ã®æš—èºã‚’æ‹…ã†ã€‚", image: "CHIEKO", unlock: { key: "initial" } },
  { sym: "SANZU", name: "ä¸‰é€”", tag: "å¼ç¥", desc: "ä¿®ç¾…ç‹ä¸¸ã®çŸ›ãŸã‚‹å¼ç¥ã€‚/ é€šå¸¸ã®æš—èºã‚’æ‹…ã†ã€‚", image: "SANZU", unlock: { key: "initial" } },
  { sym: "HANZO", name: "ãƒãƒ³ã‚¾ã‚¦", tag: "å¼ç¥", desc: "ä¿®ç¾…ç‹ä¸¸ã®å…ˆé™£ãŸã‚‹å¼ç¥ã€‚/ é€šå¸¸ã®æš—èºã‚’æ‹…ã†ã€‚", image: "HANZO", unlock: { key: "initial" } },
  { sym: "MUTSU", name: "é™¸å¥¥æ€ªç«¥", tag: "å¼ç¥", desc: "ä¿®ç¾…ç‹ä¸¸ã®ç›¾ãŸã‚‹å¼ç¥ã€‚/ é€šå¸¸ã®æš—èºã‚’æ‹…ã†ã€‚", image: "MUTSU", unlock: { key: "initial" } },
  { sym: "KUJAKU", name: "ã‚¯ã‚¸ãƒ£ã‚¯", tag: "å¼ç¥", desc: "ä¿®ç¾…ç‹ä¸¸ã®ç›Ÿç´„ãŸã‚‹å¼ç¥ã€‚/ é€šå¸¸ã®æš—èºã‚’æ‹…ã†ã€‚", image: "KUJAKU", unlock: { key: "initial" } },

  { sym: "S_BIR", name: "ãƒŸãƒŸãƒƒã‚¯", tag: "ä¿®ç¾…ç‹ä¸¸", desc: "ã‹ã¤ã¦äººã¨å…±ã«åœ¨ã£ãŸä¿®ç¾…ç‹ä¸¸ã€‚/ ç¸¦åˆ—æ¶ˆå»ã€‚", image: "S_BIR", unlock: { key: "rank", value: 0 } }, /* 0ã«ä¿®æ­£ */
  { sym: "S_NE0", name: "ãƒã‚ªãƒ¬ãƒˆãƒ­", tag: "ä¿®ç¾…ç‹ä¸¸", desc: "äººã®å§¿ã‚’è¾ã‚ãŸä¿®ç¾…ç‹ä¸¸ã€‚/ ç¸¦åˆ—æ¶ˆå»ï¼ˆåå­—å¼·åŒ–ãƒ¢ãƒ¼ãƒ‰ã§ç¸¦åˆ—+ä¸¡éš£ï¼‰ã€‚", image: "S_NE0", unlock: { key: "rank", value: 1 } },
  { sym: "S_SHU", name: "ã‚·ãƒ³ã‚®ãƒ¥ãƒ©", tag: "ä¿®ç¾…ç‹ä¸¸", desc: "ãƒã‚ªãƒ¬ãƒˆãƒ­ã‚’æ–¬ã‚Šæ¨ã¦é¡•ç¾ã—ãŸå­˜åœ¨ã€‚/ åºƒç¯„å›²ã‚’å††å½¢ã«æ¶ˆå»ã™ã‚‹ã€‚", image: "S_SHU", unlock: { key: "rank", value: 2 } },
  { sym: "S_REQ", name: "ãƒ¬ã‚¯ã‚¤ã‚¨ãƒ ", tag: "ä¿®ç¾…ç‹ä¸¸", desc: "æ–°ãŸãªå¢ƒåœ°ã‚’æ±‚ã‚ã¦ç”Ÿã¾ã‚ŒãŸå­˜åœ¨ã€‚/ æ¨ªåˆ—æ¶ˆå»ï¼ˆåå­—å¼·åŒ–ãƒ¢ãƒ¼ãƒ‰ã§æ¨ªåˆ—+ä¸Šä¸‹éš£ï¼‰ã€‚", image: "S_REQ", unlock: { key: "rank", value: 3 } },
  { sym: "S_UNK", name: "ã‚¢ãƒ³ãƒã‚¦ãƒ³", tag: "ä¿®ç¾…ç‹ä¸¸", desc: "æœªã è¦‹ã¬å…ˆã®å¢ƒåœ°ã€‚/ æ–œã‚âœ•åˆ—ã‚’æ¶ˆå»ã€‚", image: "S_UNK", unlock: { key: "rank", value: 4 } },

  { sym: "SHURACHAN", name: "ã—ã‚…ã‚‰ã¡ã‚ƒã‚“", tag: "ä¼¼çµµ", desc: "ã‚·ãƒ³ã‚®ãƒ¥ãƒ©ã®è‡ªç”»åƒã€‚/ åŒç¨®é§’ã‚’4ã¤æ¶ˆå»ã§å¬å–šã€‚åå­—åˆ—æ¶ˆå»ã€‚", image: "SHURACHAN", unlock: { key: "spawn", value: "SHURACHAN" } },
  { sym: "REKUSHURA", name: "ãƒ¬ã‚¯ã—ã‚…ã‚‰", tag: "ä¼¼çµµ", desc: "ãƒ¬ã‚¯ã‚¤ã‚¨ãƒ ã®è‡ªç”»åƒã€‚/ åŒç¨®é§’ã‚’5ã¤ä»¥ä¸Šæ¶ˆå»ã§å¬å–šã€‚é¸æŠã—ãŸé§’ã‚’ç›¤é¢ã‹ã‚‰å…¨ã¦æ¶ˆå»ã€‚", image: "REKUSHURA", unlock: { key: "spawn", value: "REKUSHURA" } },

  { sym: "J_NEM", name: "åˆæ­“", tag: "æ‚”æ¨", desc: "ä¿®ç¾…ç‹ä¸¸ã‚’æ¨ã‚€å¨˜ã€‚/ é§’ç§»å‹•ã§ããšã€éš£æ¥ã™ã‚‹æ¶ˆå»ã§HPã‚’å‰Šã‚‹ã€‚HP:1", image: "J_NEM", unlock: { key: "juso_spawn", value: true } },
  { sym: "J_SHI", name: "è¾°åéƒ", tag: "æ…™æ„§", desc: "ç­‘å‰å¿å…«å‰£è¡†ã®å‰å…ƒç· ã€‚/ é§’ç§»å‹•ã§ããšã€éš£æ¥ã™ã‚‹æ¶ˆå»ã§HPã‚’å‰Šã‚‹ã€‚HP:3", image: "J_SHI", unlock: { key: "juso_spawn", value: true } },
  { sym: "J_PRO", name: "ãƒ—ãƒ­ãƒ‘ã‚¬ãƒ³ãƒ€", tag: "è„…å¨", desc: "é¡å†™ã—ã®ä¸–ç•Œã«ä½ã‚€æ­£ç¾©ã®ä¿®ç¾…ç‹ä¸¸ã€‚/ é§’ç§»å‹•ã§ããšã€éš£æ¥ã™ã‚‹æ¶ˆå»ã§HPã‚’å‰Šã‚‹ã€‚HP:5", image: "J_PRO", unlock: { key: "juso_spawn", value: true } },

];
let unlockedChars = store.get("unlockedChars", { initial: true, juso_spawn: false, SHURACHAN: false, REKUSHURA: false });
// ãƒ©ãƒ³ã‚¯ãŒãƒŸãƒŸãƒƒã‚¯ï¼ˆ0ï¼‰ã®ã¨ãã¯ã€ä»¥å‰ã¯å‘ªè©›ãƒ–ãƒ­ãƒƒã‚¯å›³é‘‘ã‚’å†ãƒ­ãƒƒã‚¯ã—ã¦ã„ãŸãŒã€
// ä¸€åº¦è§£æ”¾ã—ãŸå›³é‘‘ã¯ãƒªã‚»ãƒƒãƒˆã—ã¦ã‚‚ä¿æŒã—ãŸã„ã®ã§ã€ã“ã“ã§ã¯ä½•ã‚‚ã—ãªã„ã€‚
try{
  let _rankForJusoReset = (typeof store!=='undefined' && store.get) ? store.get("rankIndex",0) : 0;
  // no-op: unlock çŠ¶æ…‹ã¯ç¶­æŒã•ã‚Œã‚‹
}catch(_){}


function unlockCharBySpawn(sym){
  try{
    if (!unlockedChars) unlockedChars = { initial: true, juso_spawn: false, SHURACHAN: false, REKUSHURA: false };
    if (!unlockedChars[sym]){
      unlockedChars[sym] = true;
      if (typeof store!=='undefined' && store.set){
        store.set("unlockedChars", unlockedChars);
      }
      if (typeof updateCharModalContent==='function'){
        updateCharModalContent();
      }
    }
  }catch(_){}
}

function tagClassByChar(ch){ /* (çœç•¥: å¤‰æ›´ãªã—) */
  if (Array.isArray(SPECIALS) && SPECIALS.includes(ch.sym)) return "blue";
  if (ch.sym === "J_NEM") return "red";
  if (ch.sym === "J_SHI") return "red";
  if (ch.sym === "J_PRO") return "red";
  if (ch.sym === "SHURACHAN") return "orange";
  if (ch.sym === "REKUSHURA") return "orange";
  return "yellow";
}
function updateCharModalContent(){ /* (çœç•¥: å¤‰æ›´ãªã—) */
  if(!$charList) return; let html="";
  CHARACTERS.forEach(ch=>{
    let locked=false, note="";
    if(ch.unlock.key==="rank" && rankIndex<ch.unlock.value){ locked=true; note=`Rank ${ch.unlock.value} ã§è§£æ”¾`; }
    else if(ch.unlock.key==="juso_spawn" && !unlockedChars.juso_spawn){ locked=true; note=`å‘ªè©›ãƒ–ãƒ­ãƒƒã‚¯ã®å‡ºç¾ã§è§£æ”¾`; }
    else if(ch.unlock.key==="spawn"){
      if (!unlockedChars || !unlockedChars[ch.sym]){
        locked=true; note=`åˆå‡ºç¾ã§è§£æ”¾`;
      }
    }
    const src = IMG["PATH_"+(ch.image||ch.sym)] || "";
    const tagHtml = `<span class="char-tag ${tagClassByChar(ch)}">${ch.tag}</span>`;
 if(locked){

  // â˜…ãƒ–ãƒ©ã‚¤ãƒ³ãƒ‰ï¼šåå‰/ã‚¿ã‚°/èª¬æ˜/è§£æ”¾æ¡ä»¶ã‚’éš ã™
  html += `<div class="char-item locked">
    <div class="title-row">
      <!-- ç”»åƒã¯CSSã§æ¶ˆã—ã€ãƒ€ãƒŸãƒ¼æ ã¯::beforeã§è¡¨ç¤º -->
      <h4>ï¼Ÿï¼Ÿï¼Ÿ</h4>
    </div>
  </div>`;
}else{
  html += `<div class="char-item unlocked">
    <div class="title-row"><img src="${src}" onerror="this.style.display='none';" alt="">
      <h4>${ch.name} ${tagHtml}</h4>
    </div>
    <p>${ch.desc}</p>
  </div>`;
}
  });
  $charList.innerHTML=html;
}


let wasPausedBeforeIndex = false; // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’é–‹ãå‰ã®ãƒãƒ¼ã‚ºçŠ¶æ…‹ã‚’ä¿å­˜
let wasPausedBeforeChildModal = false; // å­ãƒ¢ãƒ¼ãƒ€ãƒ«ï¼ˆå›³é‘‘/æ“ä½œèª¬æ˜ï¼‰ã‚’é–‹ãå‰ã®ãƒãƒ¼ã‚ºçŠ¶æ…‹ã‚’ä¿å­˜
let isIndexOpen = false;

/* â˜…ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ¡ãƒ‹ãƒ¥ãƒ¼é–¢é€£ */
function openIndexModal(){
  // â˜…é–‹ãï¼šindex ã ã‘ï¼ˆãªã‘ã‚Œã° push ã«1å›ã ã‘ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
  try {
    if (Sound && Sound.play) {
      Sound.play('index');           
    } else if (typeof onClickSE === 'function') {
      onClickSE();                   // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆ1å›ã ã‘ï¼‰
    }
  } catch(e) {}

  if (!isIndexOpen) { // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒé–‰ã˜ã¦ã„ã‚‹å ´åˆã®ã¿ã€ãƒãƒ¼ã‚ºçŠ¶æ…‹ã‚’ä¿å­˜
    wasPausedBeforeIndex = paused;
    if (!paused) togglePause();
    isIndexOpen = true;
  }
  $indexModal.hidden = false;
  $indexModal.classList.add('open');
}

function closeIndexModal(){
  // â˜…é–‰ã˜ã‚‹ï¼špushï¼ˆonClickSEï¼‰ã ã‘
  try { if (typeof onClickSE === 'function') onClickSE(); } catch(e) {}

  $indexModal.hidden = true;
  $indexModal.classList.remove('open');
  isIndexOpen = false;

  // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’é–‹ãå‰ã®çŠ¶æ…‹ã«æˆ»ã™
  if (paused && !wasPausedBeforeIndex) {
    togglePause();
  }
}


/* â˜…ã‚­ãƒ£ãƒ©å›³é‘‘ã‚’é–‹ããƒ»é–‰ã˜ã‚‹ */
function openCharModal(){ 
  // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒé–‹ã„ã¦ã„ã‚‹å‰æ
  wasPausedBeforeChildModal = paused; 
  if (!paused) togglePause();
  
  updateCharModalContent(); 
  $charModal.classList.add("open"); 
  $charModal.hidden = false;
}
function closeCharModal(){
   onClickSE && onClickSE(); try{ window.playSEPush && window.playSEPush(); }catch(e){};
 
  $charModal.classList.remove("open"); 
  $charModal.hidden = true;
  $indexModal.style.filter = "none";
  
  // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒé–‹ã„ã¦ã„ã‚Œã°ã€ãƒãƒ¼ã‚ºçŠ¶æ…‹ã¯ç¶­æŒï¼ˆã‚²ãƒ¼ãƒ ã¯ãƒãƒ¼ã‚ºã®ã¾ã¾ï¼‰
  if (isIndexOpen) {
    // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒé–‹ã„ã¦ã„ã‚‹ãŸã‚ã€ä½•ã‚‚ã—ãªã„ï¼ˆpaused = trueã®ã¾ã¾ï¼‰
    return;
  }

  // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒé–‰ã˜ã¦ã„ã‚Œã°ã€ã‚²ãƒ¼ãƒ é–‹å§‹å‰ã®çŠ¶æ…‹ã«æˆ»ã™
  if (paused && !wasPausedBeforeChildModal) { 
    togglePause(); 
  }
}

/* â˜…æ“ä½œèª¬æ˜ã®ãƒ‡ãƒ¼ã‚¿ */
const HOWTO_IMAGES = [
  "images/howto1.png",
  "images/howto2.png",
  "images/howto3.png",
  "images/howto4.png"

];
const HOWTO_CAPTIONS = [
  "æ“ä½œæ–¹æ³•1",
  "æ“ä½œæ–¹æ³•2",
ã€€"æ“ä½œæ–¹æ³•3",
  "æ“ä½œæ–¹æ³•4"
];
let howtoIdx = 0;

function showHowtoPage(i){
  const len = HOWTO_IMAGES.length;
  if(len === 0){
    $howtoImg.src = "";
    $howtoImg.alt = "æ“ä½œèª¬æ˜ã®ç”»åƒãŒã‚ã‚Šã¾ã›ã‚“ã€‚";
    $howtoCounter.textContent = "0 / 0";
    $howtoPrev.style.display = $howtoNext.style.display = 'none';
    return;
  }

  howtoIdx = (i + len) % len;
  $howtoImg.src = HOWTO_IMAGES[howtoIdx];
  $howtoImg.alt = HOWTO_CAPTIONS[howtoIdx] || "æ“ä½œèª¬æ˜";
  $howtoCounter.textContent = `${howtoIdx + 1} / ${len}`;
  $howtoPrev.style.display = $howtoNext.style.display = '';
}
function prevHowtoPage(){ onClickSE(); showHowtoPage(howtoIdx - 1); }
function nextHowtoPage(){ onClickSE(); showHowtoPage(howtoIdx + 1); }

/* â˜…æ“ä½œèª¬æ˜ã‚’é–‹ããƒ»é–‰ã˜ã‚‹ (Howtoã‚¹ã‚¯ãƒªãƒ—ãƒˆå†…ã‹ã‚‰ã‚‚å‘¼ã³å‡ºã•ã‚Œã‚‹ãŸã‚ã€ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«é–¢æ•°ã‚’å®šç¾©) */
window.openHowto = function(){ 
  wasPausedBeforeChildModal = paused; 
  if (!paused) togglePause();

  const modal = document.getElementById("howtoModal");
  modal.removeAttribute("hidden");  // â† hiddenå±æ€§ã‚’é™¤å»
  modal.style.display = "flex";     // â† è¡¨ç¤ºã‚’å¼·åˆ¶
  modal.classList.add("open");

  showHowtoPage(0); // â† æœ€åˆã®ãƒšãƒ¼ã‚¸ã‚’ç¢ºå®Ÿã«è¡¨ç¤º

  // $indexModal.style.filter = "blur(4px)"; // â† ãƒ–ãƒ©ãƒ¼ã‚’ç„¡åŠ¹åŒ–

  window.addEventListener('keydown', onHowtoKey, {passive:true});
};

window.closeHowto = function(){ 
  $howtoModal.hidden = true; 
  $howtoModal.classList.remove("open");
  $indexModal.style.filter = "none";
  
  // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆã‚’å‰Šé™¤
  window.removeEventListener('keydown', onHowtoKey);
  
  // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒé–‹ã„ã¦ã„ã‚Œã°ã€ãƒãƒ¼ã‚ºçŠ¶æ…‹ã¯ç¶­æŒï¼ˆã‚²ãƒ¼ãƒ ã¯ãƒãƒ¼ã‚ºã®ã¾ã¾ï¼‰
  if (isIndexOpen) {
    // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒé–‹ã„ã¦ã„ã‚‹ãŸã‚ã€ä½•ã‚‚ã—ãªã„ï¼ˆpaused = trueã®ã¾ã¾ï¼‰
    return;
  }

  // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒé–‰ã˜ã¦ã„ã‚Œã°ã€ã‚²ãƒ¼ãƒ é–‹å§‹å‰ã®çŠ¶æ…‹ã«æˆ»ã™
  if (paused && !wasPausedBeforeChildModal) { 
    togglePause(); 
  }
}

/* Howtoã®ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œ */
function onHowtoKey(e){
  if(e.key==='ArrowLeft') prevHowtoPage();
  else if(e.key==='ArrowRight') nextHowtoPage();
  else if(e.key==='Escape') window.closeHowto();
}


/* ===== è¦šé†’ãƒªã‚»ãƒƒãƒˆé–¢é€£ (æ–°è¦) ===== */
function openResetConfirmModal(){
  $indexModal.hidden = true; // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’é–‰ã˜ã‚‹
  $resetConfirmModal.hidden = false;
}
function closeResetConfirmModal(){
  $resetConfirmModal.hidden = true;
  $indexModal.hidden = false; // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«æˆ»ã‚‹
}
function resetRank(){
  closeResetConfirmModal();
  // ãƒ©ãƒ³ã‚¯ã€é€²æ—ã€ã‚¹ã‚³ã‚¢ã‚’ãƒªã‚»ãƒƒãƒˆ
  score = 0;
  rankIndex = 0;
  rankProgress = 0;
  store.set("score",score);
  store.set("rankIndex",rankIndex);
  store.set("rankProgress",rankProgress);

  // ç›¤é¢ã‚’åˆæœŸåŒ–ï¼ˆæ—¢å­˜æç”»ã¯æ¶ˆãˆã‚‹ï¼‰
  initGame(true);

  // ---- å†æç”»å¯¾ç­–ï¼šé™æ­¢çŠ¶æ…‹ã§ä¸€æšã ã‘æç”» ----
  // ã‚¢ãƒ‹ãƒ¡çŠ¶æ…‹ã‚’ã‚¯ãƒªã‚¢ã—ã¦è½ä¸‹ç­‰ã‚’æŠ‘æ­¢
  if (typeof animState === "undefined" || animState === null) { try{ animState = "idle"; }catch(e){} }
  animState = "idle";

  if (typeof size === "undefined" || size === null) { try{ size = 7; }catch(e){} } // å¿µã®ãŸã‚
  if (typeof yAnim === "undefined" || !yAnim) yAnim = [];
  if (typeof yVel  === "undefined" || !yVel ) yVel  = [];

  for (let r = 0; r < size; r++) {
    if (!yAnim[r]) yAnim[r] = [];
    if (!yVel[r])  yVel[r]  = [];
    for (let c = 0; c < size; c++) {
      yAnim[r][c] = 0;
      yVel[r][c]  = 0;
    }
  }

  // ãƒãƒ¼ã‚ºä¸­ã¯ãƒ«ãƒ¼ãƒ—å†é–‹ã›ãšã«ä¸€åº¦ã ã‘æç”»ã€‚ãƒãƒ¼ã‚ºã§ãªã‘ã‚Œã°é€šå¸¸ãƒ«ãƒ¼ãƒ—
  try {
    if (typeof paused !== "undefined" && paused) {
      if (typeof drawGame === "function") drawGame();
    } else {
      if (typeof gameLoop === "function") gameLoop();
    }
  } catch(e){ /* no-op */ }

  // UIæ›´æ–°ãƒ»ãƒœã‚¤ã‚¹é¡
  try { if (typeof updateScoresUI === "function") updateScoresUI(); } catch(e){}
  try { if (typeof updateStatus === "function") updateStatus("status: è¦šé†’ãƒ©ãƒ³ã‚¯ã¨æš—èºå€¤ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸã€‚"); } catch(e){}
  try{ window.playVoiceById && window.playVoiceById("vo_reset"); }catch(_){}
}


/* ===== ãƒ©ãƒ³ã‚¯ãƒ»ç¨®åˆ¥ (çœç•¥: å¤‰æ›´ãªã—) ===== */
const RANKS = [ /* (çœç•¥: å¤‰æ›´ãªã—) */
  { key:"S_BIR", name:"ãƒŸãƒŸãƒƒã‚¯", score: 100 },
  { key:"S_NE0", name:"ãƒã‚ªãƒ¬ãƒˆãƒ­", score: 200 },
  { key:"S_SHU", name:"ã‚·ãƒ³ã‚®ãƒ¥ãƒ©", score: 300 },
  { key:"S_REQ", name:"ãƒ¬ã‚¯ã‚¤ã‚¨ãƒ ", score: 400 },
  { key:"S_UNK", name:"ã‚¢ãƒ³ãƒã‚¦ãƒ³", score: 500 }
];
const MAX_RANK_INDEX = RANKS.length - 1;
const NORMALS=["SANZU","MUTSU","HANZO","CHIEKO","KUJAKU"];
const SPECIALS=RANKS.map(r=>r.key);
const JUSOS=["J_NEM", "J_SHI", "J_PRO"];
const RANK_THRESH = [3, 3, 3, 3, 2];//ãƒ©ãƒ³ã‚¯ã‚¢ãƒƒãƒ—é—˜å€¤
const SPECIAL_POINTS = { "S_BIR": 10, "S_NE0": 20, "S_SHU": 30, "S_REQ": 40, "S_UNK": 50 };

let board=[], yAnim=[], score=store.get("score",0), rankIndex=store.get("rankIndex",0), rankProgress=store.get("rankProgress",0);
let slashes=[], specialSlashes=[], particles=[], trails=[],
  shuraCracks = [], // ç‰¹æ®Šé§’ï¼ˆãƒŸãƒŸãƒƒã‚¯ç­‰ï¼‰æ¶ˆå»ï¼šé»’é„ï¼‹ä½å½©åº¦èµ¤äº€è£‚ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤
 auroraBeams=[]; // Bã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆè¦ç´ 
let flameParts = [];
// â˜…é€£é–çµ‚äº†ã®æ®‹éŸ¿ï¼ˆç«ã®ç²‰ãŒä¸Šã¸èˆã„ä¸ŠãŒã£ã¦åæŸï¼SEãªã—ï¼‰
let chainAfterglowEmbers = [];
// â˜…ä¸Šæ˜‡ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ã€Œç›¤é¢å¹…ã„ã£ã±ã„ã®å…‰ã®å±¤ã€
let chainAfterglowSheets = [];

 // é€£é–ãƒ¬ãƒ™ãƒ«é€£å‹•ã®ç«ã®ç²‰ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
let flamePillars = []; // ãƒ¬ãƒ™ãƒ«6ä»¥ä¸Šç”¨ã®ç”»é¢ç«¯ãƒ»æ¥­ç«ã®ç«æŸ±
let flameRipples = []; // ä¿®ç¾…ç‹ä¸¸å¿…æ®ºæ™‚ã®ç«ã®ç²‰æ³¢ç´‹
let flameRains = []; // ãƒ¬ãƒ™ãƒ«6ä»¥ä¸Šç”¨ã®ç«ã®é›¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
let bgPulse = null;               // èƒŒæ™¯è„ˆå‹•ç”¨
let auroraTriggeredThisMove = false; // ã“ã®ä¸€æ‰‹ã§ã‚ªãƒ¼ãƒ­ãƒ©ã‚’å‡ºã—ãŸã‹
let vanishMask=null, vanishP=0, animState="idle";
let drag={active:false,start:null,t:null}, swapPair=null;
let lastMoveAnchor=null; // æœ€å¾Œã«ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå‹•ã‹ã—ãŸé§’ã®åˆ°é”å…ˆ(ã‚®ãƒŸãƒƒã‚¯ä¸­å¿ƒ)

let jusoHP=[], currentObstacleCount=0;
let pendingShuraItem = null, pendingShuraItemPos = null;

let jusoShake=[]; // 0..1 ã®æ¸›è¡°ãƒ‘ãƒ¯ãƒ¼

let lastShuraItemKind = null;
let lastShuraItemMask  = null;
let lastRekCrossCombo = false;
let rekCrossStage = 0;          // 0:ãªã— 1:åå­—å¾Œ 2:å…¨æ¶ˆå»å¾Œ
let rekCrossSyms = null;        // Set<string> / Array
 // ãƒ¬ã‚¯Ã—ã—ã‚…ã‚‰ã®2æ®µéšæ¼”å‡ºãƒ•ãƒ©ã‚°
let isCascadeMatch = false;    // ãƒ‰ãƒ­ãƒƒãƒ—å¾Œã®ã‚«ã‚¹ã‚±ãƒ¼ãƒ‰ãƒãƒƒãƒä¸­ã‹ã©ã†ã‹

let isBgmReady = false; // BGMã®æº–å‚™å®Œäº†ãƒ•ãƒ©ã‚°

/* â˜…ãƒ©ãƒ³ã‚¯MAXåˆ°é”ãƒ•ãƒ©ã‚°ã‚’è¿½åŠ  (æ°¸ç¶šåŒ–) */
let hasReachedMaxRank = store.get("hasReachedMaxRank", false);

/* === é€£é–ãƒ¡ãƒ¼ã‚¿ãƒ¼ãƒ»ç§°å·ç”¨ === */
let comboCount = 0;
let comboLabel = "";
// === 6é€£é–ä»¥ä¸Šï¼šæ¼”å‡ºã®ç›´å‰ã«ã€Œæ²ˆé»™ãƒ•ãƒ¬ãƒ¼ãƒ ï¼ˆæç”»åœæ­¢ï¼‰ã€ã‚’æŒŸã‚€ï¼ˆå®‰å®šå„ªå…ˆï¼‰ ===
let comboFreezeUntil = 0;           // performance.now() ã®æ™‚åˆ»ï¼ˆmsï¼‰
// é€£é–æ¼”å‡ºï¼ˆã‚ªãƒ¼ãƒ­ãƒ©/ç«æŸ±/ç«ã®é›¨/ç«ã®ç²‰ç­‰ï¼‰ã‚’ freeze å¾Œã«é–‹å§‹ã™ã‚‹ãŸã‚ã®é…å»¶ã‚­ãƒ¥ãƒ¼
let pendingComboAurora = false;
let pendingComboAuroraDue = 0;
let pendingComboLevel = 0;
let pendingComboAnchor = null;


// â˜…é€£é–ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ç™ºå‹•ä½ç½®ï¼ˆç›´è¿‘ã®æ¶ˆå»ãƒã‚¹ã‚¯ä¸­å¿ƒï¼‰
let comboEffectAnchor = { x: null, y: null };

let comboLabelTimer = 0;
let suppressComboVoice = false; // ãƒ©ãƒ³ã‚¯ã‚¢ãƒƒãƒ—æ™‚ã«é€£é–ãƒœã‚¤ã‚¹ã‚’æŠ‘åˆ¶ã™ã‚‹ãƒ•ãƒ©ã‚°

function resetComboForNewMove(){
  comboCount = 0;
  auroraTriggeredThisMove = false; // ä¸€æ‰‹ã”ã¨ã«ã‚ªãƒ¼ãƒ­ãƒ©ç™ºå‹•ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
  updateComboGauge();
}

function registerComboStep(){
  // é€£é–ã‚«ã‚¦ãƒ³ãƒˆã ã‘ã‚’é€²ã‚ã¦ã‚²ãƒ¼ã‚¸ã‚’æ›´æ–°ã™ã‚‹ï¼ˆæ¼”å‡ºã¯æœ€çµ‚åˆ¤å®šå´ã§ã¾ã¨ã‚ã¦ç™ºç«ï¼‰
  comboCount++;
  updateComboGauge();
}

function endComboIfAny(){
  if (comboCount >= 2){
    const info = getComboInfo(comboCount);
    if (info && info.name){
      // ã‚³ãƒ³ãƒœæŠ€åã‚’è¡¨ç¤ºæ¬„ã«è¡¨ç¤º
      if (typeof setComboText === 'function'){
        try { setComboText(info.name); } catch(_){}
      }
      // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ¬„ã«æŠ€åã‚’å‡ºã™ï¼ˆä»»æ„ãƒ»ãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
      if (typeof updateStatus === 'function'){
        try { updateStatus('status: ' + info.name); } catch(_){}
      }

      // â˜…ãƒœã‚¤ã‚¹å†ç”Ÿéƒ¨åˆ†ï¼ˆãƒ©ãƒ³ã‚¯ã‚¢ãƒƒãƒ—ç›´å¾Œã¯æŠ‘åˆ¶ï¼‰
      if (!suppressComboVoice && info.voiceId){ try{ window.playVoiceById && window.playVoiceById(info.voiceId); }catch(_){ } }
      // ä¸€åº¦ãƒã‚§ãƒƒã‚¯ã—ãŸã‚‰ãƒ•ãƒ©ã‚°ã¯ãƒªã‚»ãƒƒãƒˆ
      suppressComboVoice = false;
    }
  }


  // â˜…ã‚³ãƒ³ãƒœæœ€çµ‚åˆ¤å®šæ™‚ï¼šé€£é–æ•°ã«å¿œã˜ã¦ä¸€åº¦ã ã‘æ¼”å‡ºã‚’ç™ºç”Ÿã•ã›ã‚‹
  if (comboCount >= 3){
    try{
      // 6é€£é–ä»¥ä¸Šï¼šå¤§æ¼”å‡ºã®ç›´å‰ã«ã€Œæ²ˆé»™ãƒ•ãƒ¬ãƒ¼ãƒ ï¼ˆç´„0.1ç§’ï¼‰ã€ã‚’æŒ¿å…¥ã—ã€è§£æ”¾å¾Œã«ã¾ã¨ã‚ã¦é–‹å§‹
      if (comboCount >= 6){
        const now = (typeof performance!=='undefined' && performance.now) ? performance.now() : Date.now();
        comboFreezeUntil = now + 100; // 0.1ç§’ï¼ˆå®‰å…¨å´ï¼‰
        pendingComboAurora = true;
        pendingComboAuroraDue = comboFreezeUntil;
        pendingComboLevel = comboCount;
        pendingComboAnchor = (comboEffectAnchor && typeof comboEffectAnchor.x==='number' && typeof comboEffectAnchor.y==='number')
          ? { x: comboEffectAnchor.x, y: comboEffectAnchor.y }
          : null;
      } else {
        // é€šå¸¸ã¯ force=false ã§ã‚ªãƒ¼ãƒ­ãƒ©ç”Ÿæˆï¼‹ç«ã®ç²‰ãƒ»ç«æŸ±ãƒ»ç«ã®é›¨ã¾ã§ã¾ã¨ã‚ã¦è¡Œã†
        triggerAurora(false, comboEffectAnchor, comboCount);
      }
    }catch(_){}
  }
  // â˜…é€£é–çµ‚äº†ã®æ®‹éŸ¿ï¼ˆSEãªã—ï¼‰
  if (comboCount >= 4){
    try{ spawnChainAfterglowEmbers(comboCount, comboEffectAnchor); }catch(_){ }
  }

// ã‚³ãƒ³ãƒœã®ç‰‡ä»˜ã‘
  comboCount = 0;
  updateComboGauge();
}


// é€£é–çµ‚äº†ã®æ®‹éŸ¿ï¼šç«ã®ç²‰ãŒä¸Šã¸èˆã„ä¸ŠãŒã£ã¦åæŸï¼ˆSEãªã—ï¼‰
function spawnChainAfterglowEmbers(chainCount, anchor){
  const now = (typeof performance!=='undefined' && performance.now) ? performance.now() : Date.now();
  const count = (chainCount >= 6) ? 260 : 160; // 6é€£é–ä»¥ä¸Šã¯å¤šã‚
  const max = 900;
  if (chainAfterglowEmbers.length > max) chainAfterglowEmbers.splice(0, chainAfterglowEmbers.length - max);

  // é€£é–4ä»¥ä¸Šï¼šç›¤é¢ä¸‹ã‹ã‚‰å¹…ã„ã£ã±ã„ã«ç«‹ã¡ä¸ŠãŒã‚‹ã€Œå…‰ã®å±¤ã€ã‚’1æšã ã‘ç”Ÿæˆ
  if (chainCount >= 4){
    const maxSheets = 12;
    if (chainAfterglowSheets.length > maxSheets) chainAfterglowSheets.splice(0, chainAfterglowSheets.length - maxSheets);
    const lifeS = (chainCount === 4) ? 240 : ((chainCount >= 6) ? 80 : (chainCount === 5 ? 70 : 60));
    chainAfterglowSheets.push({
      life: lifeS, maxLife: lifeS,
      chain: chainCount
    });
  }


  for (let i=0;i<count;i++){
    const ax = (anchor && typeof anchor.x==='number') ? anchor.x : (logicalSize*0.5);
    const ay = (anchor && typeof anchor.y==='number') ? anchor.y : (logicalSize*0.55);
    const x = (chainCount >= 4)
      ? (Math.random() * logicalSize)
      : Math.max(0, Math.min(logicalSize, ax + (Math.random()-0.5) * tileSize * 4.2));
    // é€£é–4ä»¥ä¸Šã¯ã€Œç›¤é¢ä¸‹ã‹ã‚‰ç«‹ã¡ä¸ŠãŒã‚‹ã€è¦‹ãˆæ–¹ã«å›ºå®š
    const y = (chainCount >= 4)
      ? (logicalSize - tileSize*(0.25 + Math.random()*1.4*1.5))
      : Math.max(0, Math.min(logicalSize, ay + tileSize*(0.6 + Math.random()*1.6*1.5)));
    const vx = (Math.random()-0.5) * ((chainCount === 4) ? 0.95 : 0.55);
    const vy = (chainCount === 4)
      ? (-(1.35 + Math.random()*2.10))
      : (-(0.85 + Math.random()*1.65)); // ä¸Šæ˜‡
    const life = (chainCount === 4)
      ? (240 + Math.random()*20) // ç´„4ç§’
      : ((chainCount >= 6) ? (180 + Math.random()*140) : (140 + Math.random()*110)); // é•·ã‚
    const r0 = (chainCount >= 6) ? (1.25 + Math.random()*2.6) : (1.05 + Math.random()*2.0); // æœ€å¤§ã‚µã‚¤ã‚ºã‚’æ‹¡å¤§ï¼ˆãƒãƒ©ã¤ãã‚ã‚Šï¼‰
    chainAfterglowEmbers.push({
      x, y, vx, vy,
      life, maxLife: life,
      r0,
      t0: now,
      chain: chainCount,   // â˜…é€£é–æ•°ï¼ˆ3ã¯é£›æ•£ãªã—ã€4ä»¥ä¸Šã¯çªé¢¨é£›æ•£ï¼‰
      exploded: false,     // â˜…é£›æ•£ã‚’ä¸€åº¦ã ã‘
      flick: Math.random()*Math.PI*2,
      reachedCeil: false,
      explodeAt: now + (chainCount >= 6 ? 520 : 460) // é£›æ•£ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚’æƒãˆã‚‹
    });
  }
}

function updateComboGauge(){
  const bar = document.getElementById("comboGaugeFill");
  if (!bar) return;
  const maxStep = 6;
  const step = Math.min(Math.max(comboCount, 0), maxStep);
  const pct = (step / maxStep) * 100;
  bar.style.width = pct + "%";
}

function getComboInfo(n){
  if (n < 3) return { name:"", voiceId:null };
  if (n === 3) return { name:"é€£é–Ã—3ã€Œæ…Ÿå“­å‰£ãƒ»å®µé—‡ã€", voiceId:"vo_combo3" };
  if (n === 4) return { name:"é€£é–Ã—4ã€Œæ…Ÿå“­å‰£ãƒ»å› æœå»»å¤©ã€", voiceId:"vo_combo4" };
  if (n === 5) return { name:"é€£é–Ã—5ã€Œæ…Ÿå“­å‰£ãƒ»åœ°ä¹‹å¢é›²ã€", voiceId:"vo_combo5" };
  return { name:`é€£é–Ã—${n}ã€Œæ…Ÿå“­å‰£ãƒ»æ•µåœ‹é™ä¼ã€`, voiceId:"vo_comboX" };
}

function getTitleByScore(s){
  if (s < 1000) return "ç§°å·ï¼šåã‚‚ç„¡ãæ¬ ç‰‡(1/8)";
  if (s < 5000) return "ç§°å·ï¼šå½±ã®è¦‹ç¿’ã„(2/8)";
  if (s < 20000) return "ç§°å·ï¼šæ¥­ç«ã®ä¸ç¨š(3/8)";
  if (s < 50000) return "ç§°å·ï¼šæ¯”è‰¯å‚ã®é˜²äºº(4/8)";
  if (s < 100000) return "ç§°å·ï¼šé»„æ˜ã®å¯©å•å®˜(5/8)";
  if (s < 300000) return "ç§°å·ï¼šè¡€ç…™ã®å‚è¦³è€…(6/8)";
  if (s < 1000000) return "ç§°å·ï¼šç„¡æ˜ã®æ”¯é…è€…(7/8)";
  return "ç§°å·ï¼šæ°¸é ã®è¦³æ¸¬è€…(MAX)";
}


/* === æœ€çµ‚ãƒ©ãƒ³ã‚¯ï¼šç‰¹æ®Šãƒ–ãƒ­ãƒƒã‚¯é¸æŠ  === */
let selectedSpecialOverride = store.get("selectedSpecialOverride", null); // nullæ™‚ã¯é€šå¸¸ã®ãƒ©ãƒ³ã‚¯ä¾å­˜
function voiceForSpecial(sym){ /* (çœç•¥: å¤‰æ›´ãªã—) */
  if(sym==="S_BIR") return document.getElementById("vo_rank0");
  if(sym==="S_NE0") return document.getElementById("vo_rank1");
  if(sym==="S_SHU") return document.getElementById("vo_rank2");
  if(sym==="S_REQ") return document.getElementById("vo_rank3");
  if(sym==="S_UNK") return document.getElementById("vo_rank4");
  return null;
}
function stopAllRankVoices(){ /* (çœç•¥: å¤‰æ›´ãªã—) */
  ["vo_rank1","vo_rank2","vo_rank3","vo_rank4"].forEach(id=>{
    const a = document.getElementById(id);
    if(a){ try{ a.pause(); a.currentTime = 0; }catch(_){} }
  });
}

function buildRankSelectButtons(){ /* (çœç•¥: å¤‰æ›´ãªã—) */
  const row = document.getElementById('rankSelectRow');
  if(!row || row.dataset.built==="1") return;
  const specials = ["S_BIR","S_NE0","S_SHU","S_REQ","S_UNK"];
  specials.forEach(sym=>{
    const btn = document.createElement('button');
    btn.className = 'btn-icon';
    const img = document.createElement('img');
    img.src = IMG["PATH_"+sym] || "";
    img.alt = sym;
    btn.appendChild(img);
    btn.addEventListener('click', ()=>{
      if(!hasReachedMaxRank) return; // â˜…ãƒã‚§ãƒƒã‚¯ã‚’hasReachedMaxRankã«å¤‰æ›´
      selectedSpecialOverride = sym;
      try{ store.set("selectedSpecialOverride", selectedSpecialOverride); }catch(_){}
      [...row.children].forEach(el=>el.classList.remove('active'));
      btn.classList.add('active');

      stopAllRankVoices();
      const v = voiceForSpecial(sym);
      if (v){
        try{ window.playVoiceById && window.playVoiceById(v.id); }catch(_){}
      }
    });
    row.appendChild(btn);
  });

  // â˜…å†èª­è¾¼æ™‚ï¼šä¿å­˜ã•ã‚Œã¦ã„ã‚‹é¸æŠçŠ¶æ…‹ã‚’ãƒœã‚¿ãƒ³ã«åæ˜ 
  if (selectedSpecialOverride){
    try{
      [...row.children].forEach(el=>{
        const imgEl = el.querySelector('img');
        if (imgEl && imgEl.alt === selectedSpecialOverride){
          el.classList.add('active');
        }
      });
    }catch(_){}
  }
  row.dataset.built="1";
}
/* ===== RankMAX (Rank 5) ã®åç§°å®šç¾© ===== */
// NORMALSã¨SPECIALSã«ç¶šã„ã¦ã€ãƒ©ãƒ³ã‚¯ã®åç§°ä¸€è¦§ã‚’å®šç¾©ã—ã¾ã™ã€‚
// rankIndex (1-based) ã‹ã‚‰åç§°ã‚’å–å¾—ã§ãã‚‹ã‚ˆã†ã«ã€é…åˆ—ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’èª¿æ•´ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
// rankIndex 0: ãƒŸãƒŸãƒƒã‚¯
// rankIndex 1: ãƒã‚ªãƒ¬ãƒˆãƒ­
// rankIndex 2: ã‚·ãƒ³ã‚®ãƒ¥ãƒ©
// rankIndex 3: ãƒ¬ã‚¯ã‚¤ã‚¨ãƒ 
// rankIndex 4: ã‚¢ãƒ³ãƒã‚¦ãƒ³
// rankIndex 5: æ°¸é ã®ç„¦åœŸ (Rank MAX)
const RANK_TITLES = [
  "ãƒŸãƒŸãƒƒã‚¯", // rankIndex = 0 or 1 (åˆæœŸå€¤/Rank 1ã¨ã—ã¦ä½¿ç”¨ã™ã‚‹æƒ³å®š)
  "ãƒã‚ªãƒ¬ãƒˆãƒ­", // rankIndex = 1
  "ã‚·ãƒ³ã‚®ãƒ¥ãƒ©", // rankIndex = 2
  "ãƒ¬ã‚¯ã‚¤ã‚¨ãƒ ", // rankIndex = 3
  "ã‚¢ãƒ³ãƒã‚¦ãƒ³", // rankIndex = 4 (MAX_RANK_INDEXã«ç›¸å½“)
  "æ°¸é ã®ç„¦åœŸ" // rankIndex = 5 (Rank MAX)
];

// rankIndexã‹ã‚‰ãƒ©ãƒ³ã‚¯åã‚’å–å¾—ã™ã‚‹ãŸã‚ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
function getRankName(index) {
  // rankIndexãŒé…åˆ—ã®ç¯„å›²å¤–ã®å ´åˆã¯ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
  if (index < 0 || index >= RANK_TITLES.length) {
    return `Rank ${index}`;
  }
  return RANK_TITLES[index];
}

// ã‚³ãƒ³ãƒœï¼ã‚·ãƒ£ãƒƒãƒ•ãƒ«æ¡ˆå†…ãƒ†ã‚­ã‚¹ãƒˆç”¨ã®è¡¨ç¤ºé–¢æ•°
function setComboText(msg){
  var el = document.getElementById("comboTextLabel");
  if (!el) return;

  // æ—§ã‚¿ã‚¤ãƒãƒ¼åœæ­¢
  if (window.comboTextTimerId){
    try { clearTimeout(window.comboTextTimerId); } catch(_){}
    window.comboTextTimerId = null;
  }

  // ãƒ†ã‚­ã‚¹ãƒˆã¨ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ä¸€æ—¦ãƒªã‚»ãƒƒãƒˆ
  el.textContent = msg || "";
  el.style.fontFamily = '"æºçœŸã‚´ã‚·ãƒƒã‚¯ Heavy","Yu Gothic","Meiryo",system-ui,sans-serif';
  el.style.fontWeight = "900";
  el.style.color      = "#111111";
  el.style.textShadow =
    "-1px -1px 0 #e64545,"+
    " 1px -1px 0 #e64545,"+
    "-1px  1px 0 #e64545,"+
    " 1px  1px 0 #e64545";

  if (!msg){
    return;
  }

  // ç›¤é¢ã‚·ãƒ£ãƒƒãƒ•ãƒ«æ™‚ã ã‘é»„è‰²å¤ªå­—ã«å¤‰æ›´
  var duration = 5000; // è¡¨ç¤ºæ™‚é–“ï¼ˆmsï¼‰
  if (msg === "ç›¤é¢ã‚’ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã—ã¾ã—ãŸã€‚"){
    el.style.color      = "#ffd966"; // å°‘ã—æŸ”ã‚‰ã‹ã„ã‚´ãƒ¼ãƒ«ãƒ‰
    el.style.textShadow = "0 0 4px rgba(0,0,0,0.7)";
    duration = 5000;
  }

  window.comboTextTimerId = setTimeout(function(){
    var el2 = document.getElementById("comboTextLabel");
    if (el2){
      el2.textContent = "";
    }
    window.comboTextTimerId = null;
  }, duration);
}

function updateStatus(text){ if($status) $status.textContent=text; }
function updateScoresUI(){
  // æš—èºå€¤
  $score.textContent = `æš—èºå€¤: ${score}`;
  // å³ä¸Šãƒ©ãƒ³ã‚¯ï¼ˆAï¼‰
  const label = (rankIndex===MAX_RANK_INDEX && hasReachedMaxRank) ? `ä¿®ç¾…ç‹ä¸¸: æ°¸é ã®ç„¦åœŸ ` : `ä¿®ç¾…ç‹ä¸¸: ${RANKS[rankIndex].name} `;
  if ($rank.firstChild) $rank.firstChild.textContent = label; else $rank.textContent = label;
  $rankProgress = document.getElementById("rankProgress") || (()=>{
    const sp=document.createElement('span'); sp.className='rank-progress'; sp.id='rankProgress'; $rank.appendChild(sp); return sp;
  })();
  if (rankIndex===MAX_RANK_INDEX){
    $rankProgress.textContent = hasReachedMaxRank ? 'MAX' : `(${unknownStageProgress}/${UNKNOWN_THRESH})`;
  } else {
    $rankProgress.textContent = `(${rankProgress}/${RANK_THRESH[rankIndex]})`;
  }
  
  // æœ€çµ‚ãƒ©ãƒ³ã‚¯ã§é¸æŠè¡Œã‚’è¡¨ç¤º (ãƒªã‚»ãƒƒãƒˆå¾Œã‚‚éè¡¨ç¤ºã«ã—ãªã„)
  const selRow = document.getElementById('rankSelectRow');
  if(selRow){
    // â˜…ãƒ©ãƒ³ã‚¯MAXã«åˆ°é”ã—ãŸã“ã¨ãŒã‚ã‚Œã°ã€å¸¸ã«ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
    // keep hasReachedMaxRank untilé—˜å€¤é”æˆ; do not auto-set here
    
    if(hasReachedMaxRank){
      buildRankSelectButtons();
      selRow.style.display='';
      /* ãƒ©ãƒ³ã‚¯MAXã§ãªã‘ã‚Œã°ã€ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã‚’ã‚¯ãƒªã‚¢ã—ã€ãƒœã‚¿ãƒ³ã®é¸æŠã‚’å¤–ã™ */
      if(rankIndex!==MAX_RANK_INDEX) { 
        selectedSpecialOverride=null; 
        try{ store.set("selectedSpecialOverride", selectedSpecialOverride); }catch(_){}
        [...selRow.children].forEach(el=>el.classList.remove('active'));
      }
    }else{
      selRow.style.display='none';
    }
  }
  const titleEl = document.getElementById("titleLabel");
  if (titleEl) titleEl.textContent = getTitleByScore(score);
  // æ°¸ç¶š
  store.set("score",score); store.set("rankIndex",rankIndex); store.set("rankProgress",rankProgress);
}

/* ===== ç›¤é¢ (çœç•¥: å¤‰æ›´ãªã—) ===== */
function get(r,c){ return (r>=0 && r<size && c>=0 && c<size) ? board[r][c] : null; }
function set(r,c,v){ if(r>=0 && r<size && c>=0 && c<size) board[r][c]=v; }
function swap(r1,c1,r2,c2){ [board[r1][c1],board[r2][c2]]=[board[r2][c2],board[r1][c1]]; }
function getInitialBlock(){
  // é€šå¸¸é§’ã®ã¿ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆï¼ˆã—ã‚…ã‚‰ã¡ã‚ƒã‚“ï¼ãƒ¬ã‚¯ã—ã‚…ã‚‰ã¯ãƒãƒƒãƒç”±æ¥ã®ã‚¢ã‚¤ãƒ†ãƒ å°‚ç”¨ï¼‰
  const base = NORMALS;
  return base[Math.floor(Math.random()*base.length)];
}

function initBoard(){ /* (çœç•¥: å¤‰æ›´ãªã—) */
  board = Array.from({length:size},()=>Array(size).fill(0));
  jusoHP= Array.from({length:size},()=>Array(size).fill(0));
  yAnim = Array.from({length:size},()=>Array(size).fill(0));
  yVel  = Array.from({length:size},()=>Array(size).fill(0));
  jusoShake = Array.from({length:size},()=>Array(size).fill(0));
  for(let r=0;r<size;r++){
    for(let c=0;c<size;c++){
      let b;
      do{ b=getInitialBlock(); }
      while((c>=2 && get(r,c-1)===b && get(r,c-2)===b) || (r>=2 && get(r-1,c)===b && get(r-2,c)===b));
      set(r,c,b);
      if (b==="SHURACHAN" || b==="REKUSHURA"){ unlockCharBySpawn(b); }
    }
  }
  currentObstacleCount=0;
  prepareDrop();
}

/* ===== å…¥åŠ› (çœç•¥: å¤‰æ›´ãªã—) ===== */
function getGridPos(x,y){ /* (çœç•¥: å¤‰æ›´ãªã—) */
  const rect=canvas.getBoundingClientRect(), nx=x-rect.left, ny=y-rect.top;
  const scale = logicalSize/rect.width;
  const gc=Math.floor(nx*scale/tileSize), gr=Math.floor(ny*scale/tileSize);
  if(gc<0||gc>=size||gr<0||gr>=size) return null;
  return {r:gr,c:gc};
}
function onStart(x,y){ /* (çœç•¥: å¤‰æ›´ãªã—) */
  userGesture();
  if (paused || animState !== "idle" || swapPair) return;
  const pos=getGridPos(x,y); if(pos){ drag.active=true; drag.start=pos; drag.t={...pos,px:x,py:y}; }
}
function onMove(x,y){ /* (çœç•¥: å¤‰æ›´ãªã—) */
  if(!drag.active || !drag.t) return;
  const rect=canvas.getBoundingClientRect(), scale=logicalSize/rect.width;
  const distSq=(x-drag.t.px)**2+(y-drag.t.py)**2;
  if(distSq<(tileSize*0.35/scale)**2) return;
  const dx=x-drag.t.px, dy=y-drag.t.py;
  let dirX=0, dirY=0;
  if(Math.abs(dx)>Math.abs(dy)) dirX=dx>0?1:-1; else dirY=dy>0?1:-1;
  const {r,c}=drag.start, nr=r+dirY, nc=c+dirX;
  if(nr>=0 && nr<size && nc>=0 && nc<size){
    if (JUSOS.includes(get(r,c)) || JUSOS.includes(get(nr,nc))) {
      // è§¦ã‚ŒãŸJUSOå´ã«å°åˆ»ã¿ã‚·ã‚§ã‚¤ã‚¯
      if (JUSOS.includes(get(r,c)))  triggerJusoShake(r, c, 1.0);
      if (JUSOS.includes(get(nr,nc))) triggerJusoShake(nr, nc, 1.0);
      // æ‹’å¦SE
      if (!window.__seNotCooldown) {
  Sound.play('not', 1.0);
  window.__seNotCooldown = true;
  setTimeout(() => window.__seNotCooldown = false, 300); // 0.3ç§’é–“ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³
}
      return;
    }
    drag.active=false; swapAndStart(r,c,nr,nc);
  }
}
function onEnd(){ drag.active=false; drag.start=null; drag.t=null; }

/* ===== ãƒ¢ãƒ¼ãƒ‰ãƒ»ä¸€æ™‚åœæ­¢(çœç•¥: å¤‰æ›´ãªã—) ===== */
function setMode(mode){ /* (çœç•¥: å¤‰æ›´ãªã—) */
  isKanki=(mode==='kanki');
  document.getElementById("btnKanki").classList.toggle("active",isKanki);
  document.getElementById("btnShodo").classList.toggle("active",!isKanki);
  updateStatus(`status: ãƒ¢ãƒ¼ãƒ‰ã‚’ã€Œ${isKanki?'æ­“å–œ':'ç„¦åœŸ'}ã€ã«è¨­å®šã—ã¾ã—ãŸã€‚`);
}
function togglePause(){ 
  paused=!paused; 
  $pauseBtn.textContent=paused?"â–¶ å†é–‹":"â¸ ä¸€æ™‚åœæ­¢"; 
  if(!paused) gameLoop(); 
}

/* ===== ãƒãƒƒãƒåˆ¤å®šï½æ¶ˆå» (çœç•¥: å¤‰æ›´ãªã—) ===== */
let lastMatchVH={v:false,h:false};
function findMatches(checkOnly=true){ /* (çœç•¥: å¤‰æ›´ãªã—) */
  lastMatchVH={v:false,h:false};
  const matches=new Set(); const isBlocked=(b)=> JUSOS.includes(b) || b===null || b==="SHURACHAN" || b==="REKUSHURA";
  // ç¸¦
  for(let c=0;c<size;c++) for(let r=0;r<=size-3;r++){
    const b=get(r,c); if(isBlocked(b)) continue;
    let len=1; for(let i=r+1;i<size;i++){ if(get(i,c)===b) len++; else break; }
    if(len>=3){ for(let i=0;i<len;i++) matches.add(`${r+i},${c}`); r+=len-1; lastMatchVH.v=true; }
  }
  // æ¨ª
  for(let r=0;r<size;r++) for(let c=0;c<=size-3;c++){
    const b=get(r,c); if(isBlocked(b)) continue;
    let len=1; for(let i=c+1;i<size;i++){ if(get(r,i)===b) len++; else break; }
    if(len>=3){ for(let i=0;i<len;i++) matches.add(`${r},${c+i}`); c+=len-1; lastMatchVH.h=true; }
  }

  if(checkOnly) return matches.size>0;
  if(matches.size>0){
    // é€šå¸¸ãƒãƒƒãƒãªã®ã§ã‚¢ã‚¤ãƒ†ãƒ å°‚ç”¨ãƒ•ãƒ©ã‚°ã¯ã‚¯ãƒªã‚¢
    lastShuraItemKind = null;
    lastShuraItemMask  = null;

    // â˜…ã‚«ã‚¹ã‚±ãƒ¼ãƒ‰æ™‚ï¼š4å€‹/5å€‹ãƒãƒƒãƒã§ã‚‚ ã—ã‚…ã‚‰ã¡ã‚ƒã‚“ï¼ãƒ¬ã‚¯ã—ã‚…ã‚‰ ã‚’ç”Ÿæˆäºˆç´„
    if (isCascadeMatch){
      let bestSize = 0;
      let bestPos = null;
      for (const key of matches){
        const [mr, mc] = key.split(",").map(Number);
        const sizeAt = getMatchSizeAt(mr, mc);
        if (sizeAt > bestSize){
          bestSize = sizeAt;
          bestPos = { r: mr, c: mc };
        }
      }
      if (bestSize >= 4 && bestPos){
        pendingShuraItemPos = bestPos;
        pendingShuraItem = (bestSize >= 5) ? "REKUSHURA" : "SHURACHAN";
      }
    }

    vanishMask = matches; animState="vanish"; vanishP=0;
    // æ¶ˆå»SEï¼ˆAï¼‰
    Sound.play('pop',1.0);
    if(lastMatchVH.v) Sound.play('vertical', .9);
    if(lastMatchVH.h) Sound.play('horizontal', .9);
    // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”Ÿæˆï¼ˆBé¢¨ï¼šæ–¬æ’ƒï¼‹ç²’å­ï¼‰
    createSlashEffects(matches);
    createParticles(matches);
    return true;
  }
  return false;
}

/* ãƒ©ãƒ³ã‚¯é€²æ—ãƒ»ãƒœã‚¤ã‚¹ (çœç•¥: å¤‰æ›´ãªã—) */
function updateRank(){ /* (çœç•¥: å¤‰æ›´ãªã—) */
  if(rankIndex<MAX_RANK_INDEX && rankProgress>=RANK_THRESH[rankIndex]){
    rankProgress=0; rankIndex++;
    // ãƒ©ãƒ³ã‚¯ã‚¢ãƒƒãƒ—ã—ãŸã®ã§ã€ç›´å¾Œã®ã‚³ãƒ³ãƒœæŠ€ãƒœã‚¤ã‚¹ã‚’æŠ‘åˆ¶
    if (typeof suppressComboVoice !== 'undefined') {
      suppressComboVoice = true;
    }
    /* ensure Unknown gate resets */
    try{
      if (typeof MAX_RANK_INDEX!=='undefined' && rankIndex===MAX_RANK_INDEX){
        // ãƒ©ãƒ³ã‚¯MAXã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«åˆ°é”ã—ãŸç¬é–“ã€
        // ã¾ã ä¸€åº¦ã‚‚MAXè§£æ”¾ã—ã¦ã„ãªã„å ´åˆã ã‘ é—˜å€¤ã‚«ã‚¦ãƒ³ã‚¿ã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹
        if (typeof hasReachedMaxRank!=='undefined' && !hasReachedMaxRank){
          if (typeof unknownStageProgress!=='number') unknownStageProgress = 0;
          else unknownStageProgress = 0;
          try{
            if (typeof store!=='undefined' && store.set) store.set('unknownStageProgress', 0);
          }catch(_){}
        }
        // ã™ã§ã« hasReachedMaxRank ãŒ true ã®å ´åˆã¯ã€ä½•ã‚‚ãƒªã‚»ãƒƒãƒˆã—ãªã„ï¼ˆã‚¢ã‚¤ã‚³ãƒ³ã‚’æ¶ˆã•ãªã„ï¼‰
      }
    }catch(_){}
    const vId = `vo_rank${Math.min(rankIndex,4)}`;
    try{ window.playVoiceById && window.playVoiceById(vId); }catch(_){ }
    Sound.play('bell', 1.0); // ãƒ©ãƒ³ã‚¯ã‚¢ãƒƒãƒ—æ™‚ã€é˜ã‚’åŒæ™‚å†ç”Ÿ
  }
  // juso_spawn è§£æ”¾ã¯å®Ÿéš›ã®å‡ºç¾æ™‚ã«è¡Œã†ï¼ˆãƒ©ãƒ³ã‚¯åˆ°é”ã§ã¯è¡Œã‚ãªã„ï¼‰
  updateScoresUI();
}

/* æ¶ˆå»â†’è½ä¸‹ (çœç•¥: å¤‰æ›´ãªã—) */
const SEED_BASE_CHANCE = 0.06;

function addCell(set, r, c){ /* (çœç•¥: å¤‰æ›´ãªã—) */
  if(r>=0 && r<size && c>=0 && c<size) set.add(`${r},${c}`);
}
function applySpecialGimmicks(baseMatches){
  // ç‰¹æ®Šé§’ã‚®ãƒŸãƒƒã‚¯ã®æ¶ˆå»ç¯„å›²ã‚’è¿½åŠ ã™ã‚‹ã€‚
  // è¦ä»¶ï¼šãƒŸãƒŸãƒƒã‚¯/ãƒã‚ªãƒ¬ãƒˆãƒ­/ãƒ¬ã‚¯ã‚¤ã‚¨ãƒ ã¯ã€Œç§»å‹•ã—ãŸé§’ï¼ˆåˆ°é”å…ˆï¼‰ã€ã‚’ä¸­å¿ƒã«ç™ºå‹•ã—ã€
  // ãƒãƒƒãƒå†…ã«è¤‡æ•°ã®ç‰¹æ®Šé§’ãŒå«ã¾ã‚Œã¦ã‚‚åˆ—/è¡ŒãŒéå‰°ã«å¢—ãˆãªã„ã‚ˆã†ã«ã™ã‚‹ã€‚
  const extra = new Set();

  // ã¾ãšã€Œä»Šå›ã®ç™ºå‹•ä¸­å¿ƒã€ã‚’æ±ºã‚ã‚‹ï¼ˆæœ€å„ªå…ˆï¼šãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå‹•ã‹ã—ãŸåˆ°é”å…ˆãŒç‰¹æ®Šé§’ã§ã€ã‹ã¤ baseMatches ã«å«ã¾ã‚Œã‚‹å ´åˆï¼‰
  let anchor = null;
  try{
    if (lastMoveAnchor){
      const ar = lastMoveAnchor.r|0, ac = lastMoveAnchor.c|0;
      const key = ar + "," + ac;
      const sym = get(ar, ac);
      if (sym && SPECIALS.includes(sym) && baseMatches && typeof baseMatches.has === 'function' && baseMatches.has(key)){
        anchor = { r: ar, c: ac, sym };
      }
    }
  }catch(_){}

  // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šbaseMatches å†…ã§æœ€åˆã«è¦‹ã¤ã‹ã£ãŸç‰¹æ®Šé§’
  if (!anchor && baseMatches){
    try{
      for (const pos of baseMatches){
        const [r,c]=pos.split(',').map(Number);
        const sym=get(r,c);
        if (sym && SPECIALS.includes(sym)){
          anchor = { r, c, sym };
          break;
        }
      }
    }catch(_){}
  }
  if (!anchor) return extra;

  const r = anchor.r, c = anchor.c, b = anchor.sym;

  if (b==="S_BIR"){ // ãƒŸãƒŸãƒƒã‚¯ï¼šç¸¦ä¸€åˆ—ã®ã¿ï¼ˆä¸­å¿ƒåˆ—ï¼‰
    for(let rr=0; rr<size; rr++) addCell(extra, rr, c);
  }
  else if (b==="S_NE0"){ // ãƒã‚ªãƒ¬ãƒˆãƒ­ï¼šç„¡æ¡ä»¶ã§ç¸¦ä¸‰åˆ—ï¼ˆä¸­å¿ƒï¼‹ä¸¡éš£ï¼‰
    for(let rr=0; rr<size; rr++){
      addCell(extra, rr, c-1);
      addCell(extra, rr, c);
      addCell(extra, rr, c+1);
    }
  }
  else if (b==="S_SHU"){ // ã‚·ãƒ³ã‚®ãƒ¥ãƒ©ï¼šå††å½¢ï¼ˆåŠå¾„2ï¼‰
    for(let rr=r-2; rr<=r+2; rr++) for(let cc=c-2; cc<=c+2; cc++){
      const dx=cc-c, dy=rr-r;
      if(dx*dx+dy*dy<=4) addCell(extra, rr, cc);
    }
  }
  else if (b==="S_REQ"){ // ãƒ¬ã‚¯ã‚¤ã‚¨ãƒ ï¼šç§»å‹•é§’ã‚’ä¸­å¿ƒã«ã€Œæ¨ªåˆ—ï¼‹ä¸Šä¸‹éš£ã€(ï¼3è¡Œ)
    for(let cc=0; cc<size; cc++){
      addCell(extra, r-1, cc);
      addCell(extra, r,   cc);
      addCell(extra, r+1, cc);
    }
  }
  else if (b==="S_UNK"){ // ã‚¢ãƒ³ãƒã‚¦ãƒ³ï¼šæ–œã‚Ã—2
    for(let k=-size; k<=size; k++){
      addCell(extra, r+k, c+k);
      addCell(extra, r+k, c-k);
    }
  }
  return extra;
}

function resolveVanishAndDrop(){ /* (çœç•¥: å¤‰æ›´ãªã—) */
  if(!vanishMask) return;
  registerComboStep();
 // â˜…åŒä¸€ vanish ã‚µã‚¤ã‚¯ãƒ«ä¸­ã«åŒã˜ãŠé‚ªé­”ã¸è¤‡æ•°å›ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å…¥ã‚Œãªã„ãŸã‚ã®ãƒ¡ãƒ¢
  const damagedThisVanish = new Set();

  // â˜…ã—ã‚…ã‚‰ã¡ã‚ƒã‚“åå­—ã«ã‚ˆã‚‹ vanish ã‹ã©ã†ã‹ã‚’åˆ¤å®šï¼ˆâ€œä»Šå›ã® vanishMask ãŒåå­—ãƒã‚¹ã‚¯ãã®ã‚‚ã®â€ã®æ™‚ã ã‘ trueï¼‰
  const isShuraCrossVanish = (function(){
    try{
      if (lastShuraItemKind !== "SHURACHAN") return false;
      if (!lastShuraItemMask || !vanishMask) return false;
      if (lastShuraItemMask.size !== vanishMask.size) return false;
      for (const p of vanishMask){
        if (!lastShuraItemMask.has(p)) return false;
      }
      return true;
    }catch(_){ return false; }
  })();
  const specialsHit = new Set();
  if (!isShuraCrossVanish){
    vanishMask.forEach(pos=>{
      const [r,c] = pos.split(',').map(Number);
      const b = get(r,c);
      if (b && SPECIALS.includes(b)) specialsHit.add(b);
    });
    specialsHit.forEach(sym=>{
      // é€šå¸¸æ¶ˆå»ã¨åŒç¨‹åº¦ã®éŸ³é‡ã«çµ±ä¸€
      if (sym==="S_BIR" || sym==="S_NE0")      Sound.play('vertical', 0.9);
      else if (sym==="S_REQ")                  Sound.play('horizontal', 0.9);
      else if (sym==="S_SHU")                  Sound.play('circle', 0.9);
      else if (sym==="S_UNK")                  Sound.play('cross', 0.9);
    });


    // â˜…ãƒ¬ãƒ™ãƒ«3ï¼šä¿®ç¾…ç‹ä¸¸ã®æ¶ˆå»ã‚¹ã‚­ãƒ«ç™ºå‹•æ™‚ï¼ˆS_BIR/S_NE0/S_SHU/S_REQ/S_UNKï¼‰ã«
    // ï¼ˆç¢ºèªç”¨ï¼‰ç‰¹æ®Šé§’æ¶ˆå»æ™‚ã®ç™½ã‚ªãƒ¼ãƒ­ãƒ©ï¼æ³¢ç´‹ï¼ˆspawnFlameRippleså«ã‚€ï¼‰ã‚’ç„¡åŠ¹åŒ–
    if (specialsHit && specialsHit.size){
      try{
        if (specialsHit && specialsHit.has('S_UNK')) triggerAurora(true);
        triggerBgPulse();      // èƒŒæ™¯è„ˆå‹•ã ã‘ã¯æ®‹ã™
      }catch(_){}
    }

    /* === Unknown é—˜å€¤ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆï¼ˆMAXç›´å‰ã®ã¿ï¼‰ === */
    try{
      if (specialsHit && specialsHit.has && specialsHit.has("S_UNK")){
        if (typeof rankIndex!=='undefined' && typeof MAX_RANK_INDEX!=='undefined' && rankIndex===MAX_RANK_INDEX && !hasReachedMaxRank){
          if (typeof unknownStageProgress!=='number') unknownStageProgress = Number(unknownStageProgress)||0;
          unknownStageProgress += 1;
          try{ if (typeof store!=='undefined' && store.set) store.set('unknownStageProgress', unknownStageProgress); }catch(_){}
          try{ if (typeof updateScoresUI==='function') updateScoresUI(); }catch(_){}
          try{ if (typeof maybeReachMax==='function') maybeReachMax(); }catch(_){}
        }
      }
    }catch(_){}
  }

  // â˜…ã—ã‚…ã‚‰ã¡ã‚ƒã‚“åå­—ç”±æ¥ã® vanish ã®å ´åˆã€SPECIALS ã®ã‚¹ã‚­ãƒ«ã¯ç™ºå‹•ã•ã›ãªã„
  const extra = isShuraCrossVanish ? new Set() : applySpecialGimmicks(vanishMask);
  extra.forEach(p=> vanishMask.add(p));

  const safeMask = new Set(vanishMask);


  if (lastShuraItemKind && safeMask.size > 0){
    try{
      createShuraItemBurstEffects(safeMask, lastShuraItemKind);
      createSlashEffects(safeMask);
    }catch(_){}
  }
  // ç‰¹æ®Šé§’ã‚®ãƒŸãƒƒã‚¯ï¼ˆãƒŸãƒŸãƒƒã‚¯/ãƒã‚ªãƒ¬ãƒˆãƒ­/ã‚·ãƒ³ã‚®ãƒ¥ãƒ©/ãƒ¬ã‚¯ã‚¤ã‚¨ãƒ /ã‚¢ãƒ³ãƒã‚¦ãƒ³ï¼‰ãŒçµ¡ã‚€æ¶ˆå»ï¼š
  // specialsHit åˆ¤å®šãŒç’°å¢ƒå·®ã§å–ã‚Šã“ã¼ã™å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€æ¶ˆå»ãƒã‚¹ã‚¯å†…ã«ç‰¹æ®Šé§’ãŒå«ã¾ã‚Œã‚‹ã‹ã§ã‚‚åˆ¤å®šã™ã‚‹ã€‚
  if (!isShuraCrossVanish){
    let hasSpecialInMask = false;
    try{
      const SPECIALS = new Set(['S_BIR','S_NE0','S_SHU','S_REQ','S_UNK']);
      for (const p of safeMask){
        const [r,c]=p.split(',').map(Number);
        const sym=get(r,c);
        if (SPECIALS.has(sym)){ hasSpecialInMask = true; break; }
      }
    }catch(_){ }
    const isSpecialCycle = (specialsHit && specialsHit.size) || hasSpecialInMask;
    if (isSpecialCycle){
      createSlashEffects(vanishMask,'special');
      if (extra.size) createParticles(extra);
    }
  }

  vanishMask.forEach(pos=>{
    const [r,c]=pos.split(',').map(Number);
    const b=get(r,c);
    if(b){
      score += 10;
      if(SPECIALS.includes(b)){
        score += SPECIAL_POINTS[b];
      }
    }
    // å‘¨å›²ã®å‘ªè©›ãƒ–ãƒ­ãƒƒã‚¯ã¸ãƒ€ãƒ¡ãƒ¼ã‚¸
    for(let dr=-1; dr<=1; dr++){
      for(let dc=-1; dc<=1; dc++){
        if(!dr && !dc) continue;
        const tr=r+dr, tc=c+dc;
        if(JUSOS.includes(get(tr,tc)) && jusoHP[tr] && jusoHP[tr][tc]>0){
          // â˜…åŒã˜åº§æ¨™ã«ã“ã®ã‚µã‚¤ã‚¯ãƒ«ã§æ—¢ã«å½“ã¦ã¦ã„ãªã„ã‹ãƒã‚§ãƒƒã‚¯
          const key = tr + ',' + tc;
          if (!damagedThisVanish.has(key)) {
            jusoHP[tr][tc]--;
            damagedThisVanish.add(key);
            triggerJusoShake(tr, tc, 1.0);
          }
          if (jusoHP[tr][tc]===0){
            // â˜…ã“ã®ã‚»ãƒ«ã¯ã€Œæ¶ˆå»ã«ã‚ˆã‚‹nullåŒ–ã€ã ã¨ãƒãƒ¼ã‚¯ã™ã‚‹
            (window.__jusoEraseSet ||= new Set()).add(tr + ',' + tc);
            set(tr,tc,null);
            jusoHP[tr][tc] = 0;
            score += 100;
            Sound.play('vertical');
          } else {
            Sound.play('rumble');
          }
        }
      }
    }

    // ã—ã‚…ã‚‰ã¡ã‚ƒã‚“ï¼ãƒ¬ã‚¯ã—ã‚…ã‚‰ï¼šè¿½åŠ ã§å‘ªè©›ã‚’å‰Šã‚‹ï¼ˆç›¤é¢å…¨ä½“ã‹ã‚‰ï¼‰
    if (b==="SHURACHAN" || b==="REKUSHURA"){
      try{
        const extraHits = (b==="SHURACHAN") ? 1 : 3;
        const candidates = [];
        for(let rr=0; rr<size; rr++){
          for(let cc=0; cc<size; cc++){
            const bb = get(rr,cc);
            if(JUSOS.includes(bb) && jusoHP[rr] && jusoHP[rr][cc]>0){
              const key2 = rr + ',' + cc;
              if (!damagedThisVanish.has(key2)){
                candidates.push({rr,cc,key:key2});
              }
            }
          }
        }
        for(let n=0; n<extraHits && candidates.length>0; n++){
          const idxPick = Math.floor(Math.random()*candidates.length);
          const picked = candidates.splice(idxPick,1)[0];
          const rr = picked.rr, cc = picked.cc, key = picked.key;
          damagedThisVanish.add(key);
          jusoHP[rr][cc]--;
          triggerJusoShake(rr,cc,1.0);
          if (jusoHP[rr][cc] <= 0){
            jusoHP[rr][cc] = 0;
            (window.__jusoEraseSet ||= new Set()).add(rr + ',' + cc);
            set(rr,cc,null);
            score += 100;
            Sound.play('vertical');
          } else {
            Sound.play('rumble');
          }
        }
      }catch(_){}
    }

    if (JUSOS.includes(b)) { jusoHP[r][c] = 0; }
    set(r,c,null);
  });

  // â˜…ãƒ¬ã‚¯Ã—ã—ã‚…ã‚‰ï¼šç¬¬1æ®µéšï¼ˆåå­—ï¼‰æ¶ˆå»å¾Œã«ã€ç¬¬2æ®µéšï¼ˆåŒç¨®å…¨æ¶ˆå»ï¼‰ã‚’â€œè½ä¸‹å‰â€ã«å®Ÿè¡Œã™ã‚‹
  if (lastRekCrossCombo && rekCrossStage === 1){
    try{
      const syms = Array.isArray(rekCrossSyms) ? rekCrossSyms : [];
      const sset = new Set(syms);
      const second = new Set();
      if (sset.size > 0){
        for(let rr=0; rr<size; rr++){
          for(let cc=0; cc<size; cc++){
            const sym = get(rr,cc);
            if (sset.has(sym)) second.add(rr + "," + cc);
          }
        }
      }
      if (second.size > 0){
        // ç¬¬2æ®µéšã®è¦–è¦šï¼†SEï¼ˆç¬¬1æ®µéšã¨åˆ†é›¢ã—ã¦è¦‹ãˆã‚‹ã‚ˆã†ã«ï¼‰
        try{ Sound.play('cross', 0.9); }catch(_){}
        // ç¬¬2æ®µéšã‚‚ç¬¬1æ®µéšã¨åŒç¨‹åº¦ã®è¡¨ç¤ºæ™‚é–“ãƒ»å­˜åœ¨æ„Ÿã«ã™ã‚‹ï¼ˆã—ã‚…ã‚‰/ãƒ¬ã‚¯ã®å°‚ç”¨æ¼”å‡ºã‚’æµç”¨ï¼‰
        try{
          const kind = lastShuraItemKind || "SHURACHAN";
          createShuraItemBurstEffects(second, kind);
        }catch(_){}
        try{ createSlashEffects(second); createParticles(second); }catch(_){}

        vanishMask = second;
        vanishP = 0;
        animState = "vanish";
        rekCrossStage = 2;
        return; // è½ä¸‹ã¯ç¬¬2æ®µéšã®å¾Œã«ã¾ã¨ã‚ã¦è¡Œã†
      } else {
        rekCrossStage = 0;
        rekCrossSyms = null;
        lastRekCrossCombo = false;
      }
    }catch(_){
      rekCrossStage = 0;
      rekCrossSyms = null;
      lastRekCrossCombo = false;
    }
  }

  // ç¬¬2æ®µéšãŒçµ‚ã‚ã£ãŸå¾Œã¯é€šå¸¸å‡¦ç†ã¸æˆ»ã™ï¼ˆè½ä¸‹â†’é€£é–ã¸ï¼‰
  if (lastRekCrossCombo && rekCrossStage === 2){
    rekCrossStage = 0;
    rekCrossSyms = null;
    lastRekCrossCombo = false;
  }

  if (specialsHit.size > 0) {
    rankProgress++;
  }

  const prevRank = rankIndex;
  updateRank();

  if(rankIndex > prevRank){
    const all = new Set();
    for(let r=0;r<size;r++){
      for(let c=0;c<size;c++){
        if(get(r,c)!==null) all.add(`${r},${c}`);
      }
    }
    if(all.size>0){
      vanishMask = all;
      animState = "vanish";
      vanishP = 0;
      lastMatchVH.v = true;
      lastMatchVH.h = false;
      createSlashEffects(all);
      return;
    }
  }

  vanishMask = null;
  prepareDrop();
  animState = "drop";
  maybeSpawnObstacles();
}

/* â˜…ã‚¯ãƒƒã‚·ãƒ§ãƒ³è½ä¸‹ç”¨ã®é€Ÿåº¦é…åˆ—ã¨å®šæ•° (çœç•¥: å¤‰æ›´ãªã—) */
let yVel = [];
const GRAVITY = 0.045;
const BOUNCE  = 0.25;
const VEL_EPS = 0.6;

function prepareDrop(){ /* (çœç•¥: å¤‰æ›´ãªã—) */

  // â˜…ã—ã‚…ã‚‰ã¡ã‚ƒã‚“ï¼ãƒ¬ã‚¯ã—ã‚…ã‚‰ï¼š4å€‹/5å€‹ãƒãƒƒãƒã«ã‚ˆã‚‹ã‚¢ã‚¤ãƒ†ãƒ å‡ºç¾ï¼ˆç§»å‹•é§’ã®æœ€çµ‚ä½ç½®ï¼‰
  if (pendingShuraItem && pendingShuraItemPos){
    try{
      const sr = pendingShuraItemPos.r;
      const sc = pendingShuraItemPos.c;
      if (sr>=0 && sr<size && sc>=0 && sc<size){
        if (get(sr,sc)===null){
          set(sr,sc,pendingShuraItem);
          if (!jusoHP[sr]) jusoHP[sr] = [];
          jusoHP[sr][sc] = 0;
          unlockCharBySpawn(pendingShuraItem);
          // â˜…ã‚¢ã‚¤ãƒ†ãƒ å‡ºç¾æ™‚ã®ãƒãƒƒãƒ—ãªæ¼”å‡º
          try{
            createShuraItemParticles(pendingShuraItem, sr, sc);
          }catch(_){}
        }
      }
    }catch(_){}
    pendingShuraItem = null;
    pendingShuraItemPos = null;
  }

  // é€šå¸¸ãƒ‰ãƒ­ãƒƒãƒ—ã§ã¯å°‚ç”¨ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
  lastShuraItemKind = null;
  if (lastShuraItemMask) lastShuraItemMask = null;

  for(let c=0;c<size;c++){
    let empty=size-1;
    for(let r=size-1;r>=0;r--){
      const b=get(r,c);
      if(b!==null){
        if(r!==empty){
          set(empty,c,b); set(r,c,null);
          if (!jusoHP[empty]) jusoHP[empty] = [];
          if (!jusoHP[r])     jusoHP[r]     = [];
          jusoHP[empty][c] = jusoHP[r][c] || 0;
          jusoHP[r][c] = 0;
          if(!yAnim[empty]) yAnim[empty]=[];
          if(!yVel[empty])  yVel[empty] =[];
          yAnim[empty][c] = -(empty-r)*tileSize;
          yVel[empty][c]  = 0;
          if(!yVel[r]) yVel[r]=[];
          yVel[r][c]=0;
        }
        empty--;
      }
    }
  }
  for(let c=0;c<size;c++){
    let emptyCount=0;
    for(let r=0;r<size;r++) if(get(r,c)===null) emptyCount++;
    for(let r=0;r<emptyCount;r++){
      let nb=getInitialBlock();
      if(Math.random()<SEED_BASE_CHANCE){
        nb = (rankIndex===MAX_RANK_INDEX && selectedSpecialOverride)
             ? selectedSpecialOverride
             : SPECIALS[Math.min(rankIndex, SPECIALS.length-1)];
        Sound.play('shine', 0.7);
      }
      set(r,c,nb);
      if (nb==="SHURACHAN" || nb==="REKUSHURA"){ unlockCharBySpawn(nb); }
      if (!jusoHP[r]) jusoHP[r] = [];
      jusoHP[r][c] = 0;
      if(!yAnim[r]) yAnim[r]=[];
      if(!yVel[r])  yVel[r] =[];
      yAnim[r][c] = -(emptyCount-r)*tileSize;
      yVel[r][c]  = 0;
    }
    for(let r=emptyCount;r<size;r++){
      if(!yAnim[r]) yAnim[r]=[];
      if(!yVel[r])  yVel[r] =[];
      yAnim[r][c] = yAnim[r][c] || 0;
      yVel[r][c]  = yVel[r][c]  || 0;
    }
  }
  Sound.play('whoosh',0.6);
}

/* ãŠé‚ªé­”ç”Ÿæˆ (çœç•¥: å¤‰æ›´ãªã—) */
function maybeSpawnObstacles(){ /* (çœç•¥: å¤‰æ›´ãªã—) */
  if(rankIndex<1) return;
  if(Math.random()>0.16) return;
  const n = 1 + (Math.random()<0.35?1:0);
  let k=0, guard=100;
  while(k<n && guard--){
    const r=Math.floor(Math.random()*size), c=Math.floor(Math.random()*size);
    const cur=get(r,c); if(!cur || JUSOS.includes(cur)) continue;
    const pool = ["J_NEM", "J_SHI", "J_PRO"];
    const pick = pool[Math.floor(Math.random()*pool.length)];
    set(r,c,pick); if(!jusoHP[r]) jusoHP[r]=[]; jusoHP[r][c]=(pick==="J_NEM"?1:(pick==="J_SHI"?3:5)); k++;
  }
  // å‘ªè©›ãƒ–ãƒ­ãƒƒã‚¯ãŒå®Ÿéš›ã«ç›¤é¢ã¸å‡ºç¾ã—ãŸã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§å›³é‘‘ã‚’è§£æ”¾
  try{
    if (k>0 && typeof unlockedChars!=='undefined'){
      if (!unlockedChars.juso_spawn){
        unlockedChars.juso_spawn = true;
        if (typeof store!=='undefined' && store.set){
          store.set("unlockedChars", unlockedChars);
        }
      }
    }
  }catch(_){}
}

/* æ–¬æ’ƒï¼†ç²’å­ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ (çœç•¥: å¤‰æ›´ãªã—) */
function createSlashEffects(matches, mode){ /* (çœç•¥: å¤‰æ›´ãªã—) */
  const slashMode = mode || 'normal';
  const target = (slashMode === 'special') ? specialSlashes : slashes;

  // ãã‚Œãã‚Œç‹¬ç«‹ã«ç®¡ç†ï¼ˆé€šå¸¸æ–¬æ’ƒãŒå¾Œç¶šã§ç™ºç«ã—ã¦ã‚‚ã€ç‰¹æ®Šæ–¬æ’ƒãŒä¸Šæ›¸ãã§æ¶ˆãˆãªã„ã‚ˆã†ã«ã™ã‚‹ï¼‰
  target.length = 0;

  const col = (slashMode==='special')
    ? {outer:'rgba(140,30,40,0.25)', inner:'rgba(170,10,30,0.9)'}
    : null;

  matches.forEach(p=>{
    const [r,c]=p.split(',').map(Number);
    const cx=c*tileSize+tileSize/2, cy=r*tileSize+tileSize/2;
    target.push({col: col, x:cx,y:cy,dir:'h',t:0});
    target.push({col: col, x:cx,y:cy,dir:'v',t:0});
  });
}
function createParticles(matches){ /* (çœç•¥: å¤‰æ›´ãªã—) */
  particles=[];
  matches.forEach(p=>{
    const [r,c]=p.split(',').map(Number);
    const cx=c*tileSize+tileSize/2, cy=r*tileSize+tileSize/2;
    for(let i=0;i<8;i++){
      particles.push({
        x:cx, y:cy,
        vx:(Math.random()-0.5)*tileSize*0.18,
        vy:(Math.random()-0.5)*tileSize*0.18,
        life:0, maxLife:18
      });
    }
  });
}

/* æç”» (çœç•¥: å¤‰æ›´ãªã—) */
const SWAP_ANIM_TIME=0.15*60, VANISH_ANIM_TIME=0.25*60;




function drawShuraCracks(){
  // ä¿®ç¾…ç‹ä¸¸ã‚¹ã‚­ãƒ«ã§æ¶ˆå»ã•ã‚Œã‚‹é§’ã«ã€Œé»’ã„é„ï¼‹èµ¤ã„äº€è£‚ã€ã‚’é‡ã­ã€è¦–èªæ€§ã‚’ä¸Šã’ã‚‹
  if(!shuraCracks.length) return;
  ctx.save();
  for(const e of shuraCracks){
    const t = e.life / e.maxLife;
    const fade = (1 - t);
    const aSmoke = 0.85 * fade;
    const aCrack = 1.0  * fade;

    const x0 = e.x - tileSize/2;
    const y0 = e.y - tileSize/2;

    // é»’ã„é„ï¼ˆä¸­å¿ƒæ¿ƒãã€å¤–å´ã«æ‹¡æ•£ï¼‰
    ctx.save();
    ctx.globalCompositeOperation = 'source-over';
    const g = ctx.createRadialGradient(e.x, e.y, tileSize*0.10, e.x, e.y, tileSize*0.65);
    g.addColorStop(0, `rgba(0,0,0,${0.55*aSmoke})`);
    g.addColorStop(0.55, `rgba(0,0,0,${0.22*aSmoke})`);
    g.addColorStop(1, `rgba(0,0,0,0)`);
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.rect(x0, y0, tileSize, tileSize);
    ctx.fill();
    ctx.restore();

    // èµ¤ã„äº€è£‚ï¼ˆç´°ã„ç·šï¼‹å¤–å´ã®æš—èµ¤ã‚°ãƒ­ã‚¦ï¼‰
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    // å¤–å´ã‚°ãƒ­ã‚¦
    ctx.lineWidth = Math.max(2.2, tileSize*0.075);
    ctx.strokeStyle = `rgba(90,10,20,${0.35*aCrack})`;
    ctx.beginPath();
    for(const p of e.paths){
      ctx.moveTo(p[0].x, p[0].y);
      for(let k=1;k<p.length;k++) ctx.lineTo(p[k].x, p[k].y);
    }
    ctx.stroke();

    // å†…å´ã®é®®çƒˆãªèµ¤
    ctx.lineWidth = Math.max(1.6, tileSize*0.040);
    ctx.strokeStyle = `rgba(220,70,80,${aCrack})`;
    ctx.beginPath();
    for(const p of e.paths){
      ctx.moveTo(p[0].x, p[0].y);
      for(let k=1;k<p.length;k++) ctx.lineTo(p[k].x, p[k].y);
    }
    ctx.stroke();
    ctx.restore();

    e.life++;
  }
  shuraCracks = shuraCracks.filter(e=>e.life < e.maxLife);
  ctx.restore();
}

function drawSlashes(){
  const prevComp = ctx.globalCompositeOperation;
  const prevAlpha = ctx.globalAlpha;
  if(!slashes.length && !specialSlashes.length) return;

  ctx.save();
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';

  // ç«¯ã‚’ç´°ãï¼ä¸­å¿ƒã‚’å°‘ã—å¤ªãã—ã€å…¨ä½“é•·ã•ã‚’ç´„8%çŸ­ç¸®ï¼ˆæ ¼å­æ„Ÿä½æ¸›ï¼‰
  const strokeTaper = (s, baseW, strokeStyle, comp, alpha, shadowBlur, shadowColor, tPhase)=>{
    // v77ç›¸å½“ï¼šç«¯å…ˆãŒâ€œã³ã‚ˆãƒ¼â€ã¨ä¼¸ã³ã‚‹ï¼ˆtã«å¿œã˜ã¦é•·ããªã‚‹ï¼‰ï¼‹ã‚ãšã‹ãªã‚ªãƒ¼ãƒãƒ¼ã‚·ãƒ¥ãƒ¼ãƒˆ
    const ph = (typeof tPhase === 'number') ? Math.max(0, Math.min(1, tPhase)) : 0;
    // åŸºæœ¬é•·ï¼ˆä¸­å¿ƒâ†’ç«¯ï¼‰ï¼šåˆæœŸçŸ­ã‚â†’çµ‚ç›¤ã§é•·ã
    const lenBase = tileSize * (0.30 + ph * 1.10);  // 0.30ã€œ1.40 tileSize
    const overshoot = 1 + 0.14 * Math.sin(Math.PI * ph); // ä¸­ç›¤ã§å°‘ã—ä¼¸ã³ã‚‹
    const len = lenBase * overshoot;

    // ç«¯ã‚’çŸ­ãã—æ ¼å­æ„Ÿã‚’æŠ‘ãˆã‚‹ï¼ˆä¸­å¿ƒå¤ªã®é ˜åŸŸã‚’åºƒã’ã€ç«¯åŒºé–“ã‚’çŸ­ç¸®ï¼‰
    const mid = len * 0.82;
    const tip = len * 0.90;

    const wThin  = Math.max(1, baseW * 0.82);
    const wTip   = Math.max(1, wThin * 0.60);
    const wThick = Math.max(1, baseW * 1.10);

    ctx.globalCompositeOperation = comp || 'source-over';
    ctx.globalAlpha = (alpha!=null) ? alpha : 1;
    ctx.shadowBlur = shadowBlur || 0;
    ctx.shadowColor = shadowColor || 'rgba(0,0,0,0)';
    ctx.strokeStyle = strokeStyle;

    // ends (thin) - inner part
    ctx.lineWidth = wThin;
    ctx.beginPath();
    if (s.dir === 'h'){
      ctx.moveTo(s.x - tip, s.y); ctx.lineTo(s.x - mid, s.y);
      ctx.moveTo(s.x + mid, s.y); ctx.lineTo(s.x + tip, s.y);
    } else {
      ctx.moveTo(s.x, s.y - tip); ctx.lineTo(s.x, s.y - mid);
      ctx.moveTo(s.x, s.y + mid); ctx.lineTo(s.x, s.y + tip);
    }
    ctx.stroke();

    // ends (tip) - extra thin
    ctx.lineWidth = wTip;
    ctx.beginPath();
    if (s.dir === 'h'){
      ctx.moveTo(s.x - len, s.y); ctx.lineTo(s.x - tip, s.y);
      ctx.moveTo(s.x + tip, s.y); ctx.lineTo(s.x + len, s.y);
    } else {
      ctx.moveTo(s.x, s.y - len); ctx.lineTo(s.x, s.y - tip);
      ctx.moveTo(s.x, s.y + tip); ctx.lineTo(s.x, s.y + len);
    }
    // fix vertical last line: canvas lineTo signature
    // We'll correct below after insert.
    ctx.stroke();

    // center (thick)
    ctx.lineWidth = wThick;
    ctx.beginPath();
    if (s.dir === 'h'){ ctx.moveTo(s.x - mid, s.y); ctx.lineTo(s.x + mid, s.y); }
    else             { ctx.moveTo(s.x, s.y - mid); ctx.lineTo(s.x, s.y + mid); }
    ctx.stroke();
  };
  // èµ¤åå­—ï¼ˆç‰¹æ®Šé§’ï¼‰ç”¨ï¼šè² è·è»½æ¸›ç‰ˆï¼ˆç«¯ã®åˆ†å‰²æç”»ã‚’çœç•¥ã—ã€ã¼ã‹ã—ã‚‚è»½é‡åŒ–ï¼‰
  const strokeRedFast = (s, w, colInner, tPhase)=>{
    const ph = (typeof tPhase === 'number') ? Math.max(0, Math.min(1, tPhase)) : 0;
    const lenBase = tileSize * (0.30 + ph * 1.10);
    const overshoot = 1 + 0.14 * Math.sin(Math.PI * ph);
    const len = lenBase * overshoot;

    // ç«¯çŸ­ç¸®ï¼ˆæ ¼å­æ„Ÿä½æ¸›ï¼‰ã¯ç¶­æŒã€‚ãŸã ã—åˆ†å‰²ç·šã¯æã‹ãšä¸€æœ¬åŒ–ï¼ˆè»½é‡ï¼‰
    const mid = len * 0.82;

    // å¤–å´ï¼ˆé»’ã„é„ï¼‰â€” æœ€åˆã®æ•°ãƒ•ãƒ¬ãƒ¼ãƒ ã ã‘æç”»ï¼ˆå¾ŒåŠã¯é„ãªã—ï¼‰
    if (ph < 0.35){
      ctx.globalCompositeOperation = 'source-over';
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 14;
      ctx.shadowColor = 'rgba(0,0,0,0.65)';
      ctx.strokeStyle = 'rgba(40,20,20,0.40)';
      ctx.lineWidth = Math.max(2, w * 2.1);
      ctx.beginPath();
      if (s.dir === 'h'){ ctx.moveTo(s.x - mid, s.y); ctx.lineTo(s.x + mid, s.y); }
      else             { ctx.moveTo(s.x, s.y - mid); ctx.lineTo(s.x, s.y + mid); }
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.shadowColor = 'rgba(0,0,0,0)';
    }

    // å†…å´ï¼ˆèµ¤ç·šï¼‰â€” ã¼ã‹ã—ç„¡ã—ã§ä¸€æœ¬
    ctx.shadowBlur = 0;
    ctx.shadowColor = 'rgba(0,0,0,0)';
    ctx.strokeStyle = colInner;
    ctx.lineWidth = Math.max(1.5, w);
    ctx.beginPath();
    if (s.dir === 'h'){ ctx.moveTo(s.x - mid, s.y); ctx.lineTo(s.x + mid, s.y); }
    else             { ctx.moveTo(s.x, s.y - mid); ctx.lineTo(s.x, s.y + mid); }
    ctx.stroke();
  };


  const drawList = (list)=>{
    for(const s of list){
      const t = Math.min(1, s.t);
      let w = Math.max(2, 6 - t*5);

      if (s.kind === 'shuraCross'){
        const alpha = 0.75 * (1 - t);
        const outerW = w * 2.0;
        // æ°´è‰²ã‚°ãƒ­ã‚¦åå­—ï¼ˆå¾“æ¥ç¶­æŒï¼‰
        strokeTaper(s, outerW, `rgba(60,150,255,${alpha * 0.6})`, 'lighter', 1, 0, 'rgba(0,0,0,0)', t);
        strokeTaper(s, w,      `rgba(120,255,255,${alpha})`,     'lighter', 1, 0, 'rgba(0,0,0,0)', t);
      } else if (s.col){
        // ç‰¹æ®Šé§’ èµ¤åå­—ï¼šè² è·è»½æ¸›ç‰ˆï¼ˆv77ã®ä¼¸é•·æ„Ÿã¯ç¶­æŒï¼‰
        strokeRedFast(s, w, s.col.inner, t);
      } else {
        // é€šå¸¸æ¶ˆå»ï¼šç™½å›ºå®š
        strokeTaper(s, w, "rgba(255,255,255,0.85)", 'source-over', 1, 0, 'rgba(0,0,0,0)', t);
      }

      s.t += 0.12;
    }
    return list.filter(s=>s.t < 1.0);
  };

  slashes = drawList(slashes);
  specialSlashes = drawList(specialSlashes);

  ctx.restore();
  ctx.globalCompositeOperation = prevComp;
  ctx.globalAlpha = prevAlpha;
}
function drawFlames(){
  if (!flameParts.length) return;
  ctx.save();
  ctx.globalCompositeOperation = 'source-over';
  for (const f of flameParts){
    const t = f.life / f.maxLife;
    const a = 1.05 * (1 - t * 0.75);      // å…‰ã‚’ã‚„ã‚„å¼·ã‚ï¼‹æ¸›è¡°ã‚’ã‚†ã£ãã‚Šã«
    const grow = 1 - t * 0.35;            // ã‚†ã£ãã‚Šå°ã•ããªã‚‹

    // è‰²å‘³ï¼šå…¨ä½“çš„ã«èµ¤å¯„ã‚Šã€ã‚¨ãƒƒã‚¸ã®èµ¤ã‚’å¼·ã‚ã‚‹
    let r, g, b;
    if (f.hell){
      // æ¥­ç«ï¼šæ·±ã„èµ¤ã€œãƒã‚¼ãƒ³ã‚¿å¯„ã‚Š
      r = 248 + Math.random()*7;
      g = 50 + Math.random()*30;
      b = 70 + Math.random()*50;
    } else {
      // é€šå¸¸ç«èŠ±ï¼šèµ¤ã¿ã®å¼·ã„ã‚ªãƒ¬ãƒ³ã‚¸ã€œé»„è‰²
      r = 255;
      g = 140 + Math.random()*50;
      b = 25 + Math.random()*25;
    }
    // é€£é–3ã€œ5ã®ç«èŠ±ã¯ã€Œä¸Šæ˜‡ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«åŒç­‰ã€ã®ç™ºå…‰æ„Ÿï¼ˆç™½èŠ¯â†’é»„ç™½â†’æ©™â†’é€æ˜ï¼‰ã«ã™ã‚‹
    if (!f.hell && (f.level >= 3 && f.level <= 5)){
      const rr = f.size * grow * 2.4; // v3: ã‚µã‚¤ã‚ºç¸®å°(ç´„0.7å€)
      const gg = ctx.createRadialGradient(f.x, f.y, 0, f.x, f.y, rr);
      gg.addColorStop(0.00, `rgba(255,255,250,${Math.min(1, a*1.05)})`);
      gg.addColorStop(0.20, `rgba(255,245,205,${Math.min(1, a*0.95)})`);
      gg.addColorStop(0.55, `rgba(255,175,80,${Math.min(1, a*0.70)})`);
      gg.addColorStop(1.00, `rgba(30,5,0,0)`);
      ctx.fillStyle = gg;
      ctx.beginPath();
      ctx.arc(f.x, f.y, rr, 0, Math.PI * 2);
      ctx.fill();
    } else {
      ctx.fillStyle = `rgba(${r|0},${g|0},${b|0},${a})`;
      ctx.beginPath();
      ctx.arc(f.x, f.y, f.size * grow, 0, Math.PI * 2);
      ctx.fill();
    }

// å››æ–¹å…«æ–¹ã«æ•£ã‚Šã¤ã¤ã€ãµã‚ãµã‚ã¨é•·ãæ¼‚ã†ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³
    f.x += f.vx;
    f.y += f.vy;

    // å¾ã€…ã«æ¸›é€Ÿï¼ˆãµã‚ãµã‚æ„Ÿï¼‰
    f.vx *= 0.97;
    f.vy *= 0.97;

    // ã‚ãšã‹ã«ä¸Šæ–¹å‘ã¸æµã‚Œã‚‹ãƒ‰ãƒªãƒ•ãƒˆ
    f.y -= tileSize * 0.002;

    // æºã‚‰ã
    f.x += Math.sin(f.life * 0.18) * 0.18;
    f.y += Math.cos(f.life * 0.14) * 0.14;

    f.life++;
  }
  flameParts = flameParts.filter(f => f.life < f.maxLife);
  ctx.restore();
}



function drawFlamePillars(){
  if (!flamePillars.length) return;
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  for (const p of flamePillars){
    const t = p.life / p.maxLife;
    const alpha = 0.55 * (1 - t);
    const height = p.maxHeight * (0.4 + 0.6 * (1 - t));
    const baseY = logicalSize;
    const topY = baseY - height;

    const grad = ctx.createLinearGradient(p.x, topY, p.x, baseY);
    grad.addColorStop(0.0, `rgba(255, 220, 160, ${alpha * 0.0})`);
    grad.addColorStop(0.3, `rgba(255, 200, 120, ${alpha * 0.6})`);
    grad.addColorStop(0.7, `rgba(255, 120, 60, ${alpha * 0.9})`);
    grad.addColorStop(1.0, `rgba(220, 40, 20, ${alpha})`);

    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.rect(p.x - p.width/2, topY, p.width, height);
    ctx.fill();

    p.life++;
  }
  flamePillars = flamePillars.filter(p => p.life < p.maxLife);
  ctx.restore();
}

function drawFlameRipples(){
  if (!flameRipples.length) return;
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  for (const r of flameRipples){
    const t = r.life / r.maxLife;
    const radius = r.radius + r.maxRadius * t;
    const alpha = 0.6 * (1 - t);
    if (alpha <= 0) { r.life = r.maxLife; continue; }

    ctx.strokeStyle = `rgba(255, 140, 60, ${alpha})`;
    ctx.lineWidth = tileSize * (0.10 + 0.06 * (1 - t));
    ctx.beginPath();
    ctx.arc(r.cx, r.cy, radius, 0, Math.PI * 2);
    ctx.stroke();

    r.life++;
  }
  flameRipples = flameRipples.filter(r => r.life < r.maxLife);
  ctx.restore();
}



function drawFireRains(){
  if (!flameRains.length) return;
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  for (const f of flameRains){
    const t = f.life / f.maxLife;
    const alpha = 0.9 * (1 - t);
    const len = f.length * (0.8 + 0.2 * (1 - t));

    const a = (f.hell ? alpha * 0.95 : alpha);
    // å¤–å´ï¼ˆè‰²ï¼‰ï¼‹å†…å´ï¼ˆç™½èŠ¯ï¼‰ã§ã€Œå¼·ã„å…‰ã€ã‚’ä½œã‚‹
    const x2 = f.x + f.vx * 0.4;
    const y2 = f.y + len;
    ctx.beginPath();
    ctx.moveTo(f.x, f.y);
    ctx.lineTo(x2, y2);
    ctx.strokeStyle = `rgba(${f.r|0},${f.g|0},${f.b|0},${a*0.75})`;
    ctx.lineWidth = f.width * 1.7;
    ctx.stroke();
    ctx.strokeStyle = `rgba(170,10,30,${a})`;
    ctx.lineWidth = Math.max(0.6, f.width * 0.65);
    ctx.stroke();

    f.x += f.vx;
    f.y += f.vy;
    f.life++;
  }
  flameRains = flameRains.filter(f => f.life < f.maxLife && f.y < logicalSize + tileSize);
  ctx.restore();
}

function drawParticles(){ /* (ã—ã‚…ã‚‰ã¡ã‚ƒã‚“ï¼ãƒ¬ã‚¯ã—ã‚…ã‚‰ç”¨ã®â˜…ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å¯¾å¿œç‰ˆ) */
  if(!particles.length) return;
  ctx.save();
  ctx.globalCompositeOperation='lighter';
  for(const p of particles){
    const t = p.life / p.maxLife;
    const alpha = isKanki ? (0.8*(1-t)) : (0.9*(1-t));
    let col = null;
    if (p.color){
      col = p.color;
      ctx.fillStyle = `rgba(${col.r},${col.g},${col.b},${alpha})`;
      ctx.strokeStyle = `rgba(${col.r},${col.g},${col.b},${alpha})`;
    } else {
      ctx.fillStyle = isKanki ? `rgba(180,220,255,${alpha})` : `rgba(220,40,40,${alpha})`;
      ctx.strokeStyle = ctx.fillStyle;
    }
    const rad = Math.max(1, 3 - 2*t);
    // â˜…ã—ã‚…ã‚‰ã¡ã‚ƒã‚“ï¼ãƒ¬ã‚¯ã—ã‚…ã‚‰ç”±æ¥ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã¯å°ã•ãªâ˜…å‹ã§æç”»
    if (p.kind === "shura" || p.kind === "rekushura"){
      const sz = rad * 1.7 + 1.5; // ä¸€å›ã‚Šå¤§ããªâ˜…ã«
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(p.x,     p.y - sz);
      ctx.lineTo(p.x,     p.y + sz);
      ctx.moveTo(p.x - sz, p.y);
      ctx.lineTo(p.x + sz, p.y);
      ctx.stroke();
    } else {
      ctx.beginPath();
      ctx.arc(p.x, p.y, rad, 0, Math.PI*2);
      ctx.fill();
    }
    p.x += p.vx; p.y += p.vy; p.vy += 0.05; p.life++;
  }
  particles=particles.filter(p=>p.life<p.maxLife);
  ctx.restore();
}


function drawTrails(){ /* ãƒ¬ãƒ™ãƒ«1ï¼šã—ã‚…ã‚‰ã¡ã‚ƒã‚“ï¼ãƒ¬ã‚¯ã—ã‚…ã‚‰ç”¨ã®æ®‹å…‰ã®å°¾ï¼ˆv2ã®ç´„åŠåˆ†ã®å¼·ã•ï¼‰ */
  if(!trails.length) return;
  ctx.save();
  ctx.globalCompositeOperation='lighter';
  for(const tr of trails){
    const t = tr.life / tr.maxLife;
    const alpha = 0.35 * (1 - t);
    const len = tr.length * (1 + 0.10*Math.sin(tr.life*0.25));
    const baseW = tileSize * 0.10;
    const w = baseW * (1 - t);
    if (w <= 0.1){ tr.life = tr.maxLife; continue; }
    ctx.strokeStyle = `rgba(120,255,255,${alpha})`;
    ctx.lineWidth = w;
    ctx.beginPath();
    const steps = 10;
    for(let i=0;i<=steps;i++){
      const u = (i/steps - 0.5);
      let px = tr.x, py = tr.y;
      if (tr.dir === 'h') px += u * len;
      else               py += u * len;
      const wobble = Math.sin(tr.phase + u*6 + tr.life*0.2) * tileSize*0.08 * (1-t);
      if (tr.dir === 'h') py += wobble;
      else               px += wobble;
      if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
    }
    ctx.stroke();
    tr.life++;
  }
  trails = trails.filter(tr => tr.life < tr.maxLife);
  ctx.restore();
}

function triggerAurora(force, anchor, chainLevelOverride){ /* ãƒ¬ãƒ™ãƒ«2/3ç”¨ã‚ªãƒ¼ãƒ­ãƒ©ç”Ÿæˆï¼ˆå…ƒã®ç´„3åˆ†ã®2ã®å¼·ã•ï¼‰ */
  const centerX = (anchor && typeof anchor.x==='number') ? anchor.x : (logicalSize/2);
  const centerY = (anchor && typeof anchor.y==='number') ? anchor.y : (logicalSize/2);
  const baseLen = Math.sqrt(logicalSize*logicalSize*2) * 1.2;
  const strength = force ? 1.0 : 0.8; // ãƒ¬ãƒ™ãƒ«2: 0.8, ãƒ¬ãƒ™ãƒ«3: 1.0

  // ãƒ¬ãƒ™ãƒ«2ï¼ˆforce=falseï¼‰ï¼šç‰‡å´ã®æ–œã‚ãƒ“ãƒ¼ãƒ ã®ã¿
  // ãƒ¬ãƒ™ãƒ«3ï¼ˆforce=trueï¼‰ï¼šå·¦å³åå¯¾æ–œã‚ã®2æ–¹å‘ã«ä¼¸ã³ã‚‹ã€ŒXã€å­—ãƒ“ãƒ¼ãƒ 
  const baseAngles = force ? [-Math.PI/4, Math.PI/4] : [-Math.PI/4];
  const beamsPerDir = force ? 1 : 2;

  const newBeams = [];

  for(const baseAng of baseAngles){
    for(let i=0;i<beamsPerDir;i++){
      const ang = baseAng + (Math.random()*0.25 - 0.125);
      const beam = {
        angle: ang,
        cx: centerX,
        cy: centerY,
        length: baseLen * (0.9 + Math.random()*0.3),
        width: tileSize * (1.2 + Math.random()*0.4) * strength,
        life: 0,
        maxLife: 22 + (i*4),
        strength
      };
      auroraBeams.push(beam);
      newBeams.push(beam);
    }
  }
  auroraTriggeredThisMove = true;

  // â˜…é€£é–ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ãŸç«ã®ç²‰ç”Ÿæˆï¼ˆ3ã€œ6ä»¥ä¸Šï¼‰ã€‚ã‚ªãƒ¼ãƒ­ãƒ©ãƒ©ã‚¤ãƒ³ä¸Šã‹ã‚‰ç™ºç”Ÿã€‚
  try{
    const rawLevel = (typeof chainLevelOverride==='number' && isFinite(chainLevelOverride)) ? chainLevelOverride : (comboCount || 3);
    const chainLevel = Math.max(3, Math.min(6, rawLevel)); // 3ã€œ6ã«ä¸¸ã‚ã‚‹
    // 6é€£é–ï¼ˆæ…Ÿå“­å‰£ãƒ»æ•µåœ‹é™ä¼ ç›¸å½“ï¼‰ã§ã¯ã€ã‚ªãƒ¼ãƒ­ãƒ©ãƒ“ãƒ¼ãƒ è‡ªä½“ã‚‚åœ°ç„å¯„ã‚Šã®è‰²ã«ã™ã‚‹
    if (chainLevel >= 6){
      for (const b of newBeams){
        if (b) b.hell = true;
      }
    }
    spawnFlamesFromAurora(newBeams, chainLevel);
    // ä¿®ç¾…ç‹ä¸¸å¿…æ®ºï¼ˆforce=trueï¼‰ã®ã¨ãã ã‘ã€ç”»é¢å…¨ä½“ã«ç«ã®ç²‰ã®æ³¢ç´‹ã‚’è¿½åŠ 
    if (force){
      spawnFlameRipples();
    }
  }catch(_){}
}

/**
 * é€£é–ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦ã€ã€Œç„šãç«ã®ç°ã€ãŒèˆã†ç«ã®ç²‰ï¼‹6é€£é–ä»¥ä¸Šã§æ¥­ç«ã‚’æ··ãœã‚‹ã€‚
 * ç«ã®ç²‰ã¯ã‚ªãƒ¼ãƒ­ãƒ©ãƒ“ãƒ¼ãƒ ã®ãƒ©ã‚¤ãƒ³ä¸Šã‹ã‚‰ç™ºç”Ÿã•ã›ã‚‹ã€‚
 */

function spawnFlamesFromAurora(beams, level){
  if (!beams || !beams.length) return;
  const MAX_FLAME_PARTS = ((typeof IS_IOS!=="undefined"&&IS_IOS)?140:220);
  if (flameParts.length >= MAX_FLAME_PARTS) return;

  // 3:8 / 4:12 / 5:16 / 6:20 + æ¥­ç«ãƒœãƒ¼ãƒŠã‚¹ â†’ å…¨ä½“ã‚’3å€
  const baseCount = (level === 3) ? 14 : (8 + (level - 3) * 4);
  const extraHell = (level >= 6) ? 6 : 0;
  const totalBase = baseCount + extraHell;
  const totalCount = totalBase * 3; // è¦‹ãŸç›®ã‚’æ´¾æ‰‹ã«ã™ã‚‹ãŸã‚3å€

  const perBeam = Math.max(1, Math.floor(totalCount / beams.length));

  for (const b of beams){
    const dirx = Math.cos(b.angle);
    const diry = Math.sin(b.angle);

    for (let i = 0; i < perBeam; i++){
      // ãƒ“ãƒ¼ãƒ ã®é•·ã•ã®ä¸­ã»ã© Â±50% ã«ã°ã‚‰æ’’ãï¼ˆç™ºç”Ÿä½ç½®ã¯ã‚ªãƒ¼ãƒ­ãƒ©ã®è»Œè·¡ä¸Šï¼‰
      const u = (Math.random() - 0.5) * b.length;
      const sx = b.cx + dirx * u;
      const sy = b.cy + diry * u;

      // å››æ–¹å…«æ–¹ã«æ•£ã‚‹ãŒã€å…¨ä½“ã¨ã—ã¦ã‚†ã£ãã‚Šã‚ã«èˆã†
      const speed = tileSize * 0.12 * (0.6 + Math.random()*0.8);
      const ang = Math.random() * Math.PI * 2;
      const vx = Math.cos(ang) * speed;
      const vy = Math.sin(ang) * speed * 0.8;

      const isHell = (level >= 6) && (Math.random() < 0.35); // ä¸€éƒ¨ã‚’ã€Œæ¥­ç«ã€æ‰±ã„

      // ã‚µã‚¤ã‚ºã‚’å¤§ãƒ»ä¸­ãƒ»å°ã§æ··åœ¨ã•ã›ã‚‹ï¼ˆå¤§ã‚µã‚¤ã‚ºã¯ç¾çŠ¶ç¶­æŒï¼‰
      const rTier = Math.random();
      let baseSize, jitter;
      if (rTier < 0.25){
        // å°ã•ã‚ã®ç«èŠ±
        baseSize = isHell ? 2.4 : 1.8;
        jitter   = isHell ? 1.1 : 0.9;
      } else if (rTier < 0.75){
        // ä¸­ãã‚‰ã„ã®ç«èŠ±
        baseSize = isHell ? 3.6 : 2.6;
        jitter   = isHell ? 2.0 : 1.6;
      } else {
        // å¤§ãã„ç«èŠ±ï¼ˆç¾çŠ¶ã®ã‚µã‚¤ã‚ºæ„Ÿã‚’ç¶­æŒï¼‰
        baseSize = isHell ? 4.5 : 3.2;
        jitter   = isHell ? 3.5 : 2.5;
      }

      flameParts.push({
        x: sx,
        y: sy,
        vx,
        vy,
        life: 0,
        maxLife: isHell ? (55 + Math.random()*25) : (42 + Math.random()*18), // å°‘ã—é•·ã‚ã«æ®‹ã™
        size: baseSize + Math.random()*jitter,
        hell: isHell,
        level: level
      });
    }
  }

  // ãƒ¬ãƒ™ãƒ«6ä»¥ä¸Šã§ã¯ç”»é¢ç«¯ã«æ¥­ç«ã®ç«æŸ±ï¼‹ç«ã®é›¨ã‚’è¿½åŠ 
  if (level >= 6){
    spawnFirePillars(level);
    spawnFireRain(level);
  }
}



function spawnFirePillars(level){
  const colsPerSide = 2 + (level > 6 ? 1 : 0); // ãƒ¬ãƒ™ãƒ«6ã§2æœ¬/å´ã€7ä»¥ä¸Šãªã‚‰3æœ¬/å´
  const marginX = tileSize * 0.6;
  const pitch = tileSize * 0.9;
  const usableHeight = logicalSize * 0.65;

  for (const side of [-1, 1]){
    for (let i = 0; i < colsPerSide; i++){
      const offset = marginX + pitch * i;
      const x = (side < 0) ? offset : (logicalSize - offset);
      const maxHeight = usableHeight * (0.7 + Math.random()*0.3);
      const width = tileSize * (0.5 + Math.random()*0.4);
      flamePillars.push({
        x,
        width,
        maxHeight,
        life: 0,
        maxLife: (level >= 6 ? (50 + Math.random()*20) * 2 : (50 + Math.random()*20))
      });
    }
  }
}

function spawnFlameRipples(){
  const centerX = logicalSize / 2;
  const centerY = logicalSize / 2;
  const layers = 3;
  for (let i = 0; i < layers; i++){
    flameRipples.push({
      cx: centerX,
      cy: centerY,
      radius: tileSize * 0.4 * i,
      maxRadius: logicalSize * (0.55 + i * 0.12),
      life: 0,
      maxLife: 45 + i * 8
    });
  }
}

// ãƒ¬ãƒ™ãƒ«6ä»¥ä¸Šå°‚ç”¨ï¼šç”»é¢å…¨ä½“ã«ã€Œç«ã®é›¨ã€ã‚’é™ã‚‰ã›ã‚‹
function spawnFireRain(level){
  const MAX_RAIN = ((typeof IS_IOS!=="undefined"&&IS_IOS)?140:220);
  if (flameRains.length >= MAX_RAIN) return;

  const count = 90 + Math.max(0, level - 6) * 20; // ã ã„ãŸã„90æœ¬å‰å¾Œ

  for (let i = 0; i < count; i++){
    const x = Math.random() * logicalSize;
    const y = -tileSize * (0.5 + Math.random() * 3.0); // ç”»é¢ä¸Šéƒ¨ã®å¤–ã‹ã‚‰é™ã£ã¦ãã‚‹
    const vy = tileSize * (0.25 + Math.random() * 0.25);
    const vx = tileSize * (Math.random() * 0.10 - 0.05); // ã‚ãšã‹ã«æ–œã‚
    const length = tileSize * (0.6 + Math.random() * 0.6);
    const width  = tileSize * (0.04 + Math.random() * 0.03);

    // 6é€£é–ä»¥ä¸Šï¼ˆæ…Ÿå“­å‰£ãƒ»æ•µåœ‹é™ä¼ï¼‰ã§ã¯ã€Œå…‰ã‚‰ãªã„èµ¤é»’ã€ã‚’å¼·åˆ¶
    const isHell = (level >= 6);
    let r, g, b;
    if (isHell){
      // åœ°ç„ç«ï¼ˆå¼·ã„å…‰èŠ¯ï¼‹èµ¤æ©™ã®ç¸ï¼‰
      r = 255;
      g = 80  + Math.random()*90;
      b = 20  + Math.random()*40;
    } else {
      // é€šå¸¸ï¼ˆå¾“æ¥ã®ç‚è‰²ï¼‰
      r = 255;
      g = 160 + Math.random()*60;
      b = 60  + Math.random()*40;
    }

    flameRains.push({
      x, y, vx, vy,
      life: 0,
      // é™ã£ã¦ã„ã‚‹æ™‚é–“ã‚’ã€Œãƒ¬ãƒ™ãƒ«6ä»¥ä¸Šã¯2å€ã€ã«å»¶é•·ï¼ˆé€Ÿåº¦ã¯å¤‰ãˆãšã€é™ã‚Šç¶šã‘ã‚‹æ™‚é–“ã ã‘ã‚’å»¶é•·ï¼‰
      maxLife: (level >= 6 ? (60 + Math.random()*25) * 2 : (60 + Math.random()*25)),
      length,
      width,
      r, g, b,
      hell: isHell
    });
  }
}
function drawAurora(){
  if(!auroraBeams.length) return;
  ctx.save();
  ctx.globalCompositeOperation='lighter';
  for(const b of auroraBeams){
    const t = b.life / b.maxLife;
    const alphaBase = 0.20 * b.strength; // å…ƒã®ç´„3åˆ†ã®2ç¨‹åº¦ã‚’æƒ³å®š
    const alpha = alphaBase * (1 - t);
    if (alpha <= 0){ b.life = b.maxLife; continue; }
    ctx.save();
    ctx.translate(b.cx, b.cy);
    ctx.rotate(b.angle);
    const grad = ctx.createLinearGradient(-b.length/2, 0, b.length/2, 0);

    const isHellAurora = !!b.hell; // 6é€£é–ä»¥ä¸Šã§ä»˜ä¸ã•ã‚Œã‚‹ãƒ•ãƒ©ã‚°

    if (isHellAurora){
      // åœ°ç„å‘³ã®å¼·ã„èµ¤é»’ç³»ã‚ªãƒ¼ãƒ­ãƒ©ã®æŸ±
      grad.addColorStop(0.0, `rgba(0,0,0,0)`);
      grad.addColorStop(0.25, `rgba(90,10,20,${alpha * 0.7})`);
      grad.addColorStop(0.6, `rgba(210,20,20,${alpha})`);
      grad.addColorStop(1.0, `rgba(0,0,0,0)`);
    } else if (isKanki){
      // æ­“å–œãƒ¢ãƒ¼ãƒ‰æ™‚ï¼šä¸­å¿ƒã®ç™½ã•ã‚’å°‘ã—æŠ‘ãˆã€ç›¤é¢ãŒè¦‹ãˆã‚‹ã‚ˆã†ã«ã‚¢ãƒ«ãƒ•ã‚¡ã‚’æ§ãˆã‚ã«ã™ã‚‹
      const aK = alpha * 0.6;
      grad.addColorStop(0, `rgba(120,255,255,0)`);
      grad.addColorStop(0.5, `rgba(220,240,255,${aK})`);
      grad.addColorStop(1, `rgba(255,180,220,0)`);
    } else {
      grad.addColorStop(0, `rgba(40,0,80,0)`);
      grad.addColorStop(0.5, `rgba(140,40,160,${alpha})`);
      grad.addColorStop(1, `rgba(220,40,80,0)`);
    }
    ctx.fillStyle = grad;
    const width = b.width * (1 + 0.25*Math.sin(b.life*0.25));
    ctx.fillRect(-b.length/2, -width/2, b.length, width);
    ctx.restore();
    b.life++;
  }
  auroraBeams = auroraBeams.filter(b => b.life < b.maxLife);
  ctx.restore();
}

function getPulseMode(){
  // isKanki ãŒ true = æ­“å–œ, false = ç„¦åœŸ, ãã‚Œä»¥å¤–ã« Jubille/è¶…è¶ŠãŒã‚ã‚Œã°ãã¡ã‚‰ã‚’å„ªå…ˆ
  try{
    const w = window || {};
    const jub = !!(w.isJubilee || (''+(w.currentMode||'')).toLowerCase().includes('jubilee'));
    if (jub) return 'choetsu';
  }catch(_){}
  return isKanki ? 'kanki' : 'shodo';
}

function triggerBgPulse(){
  // èƒŒæ™¯è„ˆå‹•ã¯ã€Œç™ºå‹•ã—ã¦ã„ã‚‹ã®ãŒåˆ†ã‹ã‚‹ã€ç¨‹åº¦ã«ã‚„ã‚„å¼·ã‚
  bgPulse = { mode: getPulseMode(), life: 0, maxLife: 70 };
}

function drawBgPulse(){
  if (!bgPulse) return;
  const t = bgPulse.life / bgPulse.maxLife;
  const alpha = 0.9 * (1 - t);
  if (alpha <= 0){
    bgPulse = null;
    return;
  }
  const cx = logicalSize/2;
  const cy = logicalSize/2;
  ctx.save();
  ctx.globalCompositeOperation='lighter';
  if (bgPulse.mode === 'kanki'){
    const grad = ctx.createRadialGradient(cx,cy,0,cx,cy,logicalSize*0.85);
    grad.addColorStop(0, `rgba(230,255,255,${alpha})`);
    grad.addColorStop(1, `rgba(0,0,0,0)`);
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,logicalSize,logicalSize);
  } else if (bgPulse.mode === 'shodo'){
    const grad = ctx.createRadialGradient(cx,cy,0,cx,cy,logicalSize*0.9);
    grad.addColorStop(0, `rgba(160,0,0,${alpha*0.9})`);
    grad.addColorStop(1, `rgba(0,0,0,0)`);
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,logicalSize,logicalSize);
  } else { // choetsu
    ctx.fillStyle = `rgba(255,255,255,${alpha*0.7})`;
    ctx.fillRect(0,0,logicalSize,logicalSize);
  }
  ctx.restore();
  bgPulse.life++;
  if (bgPulse.life >= bgPulse.maxLife) bgPulse = null;
}

function drawBlock(r,c,x,y,a=1){ /* (çœç•¥: å¤‰æ›´ãªã—) */
  const b=get(r,c); if(b===null) return;
  // --- JUSO éœ‡ãˆã‚ªãƒ•ã‚»ãƒƒãƒˆ ---
  if (Array.isArray(JUSOS) && JUSOS.includes(b)) {
    const pow = (jusoShake && jusoShake[r] ? jusoShake[r][c] : 0) || 0;
    if (pow > 0){
      const t = performance.now()/1000;
      const amp = 3 * pow; // æœ€å¤§3pxç›¸å½“æºã‚Œå¼·åº¦
      x += Math.sin(t*36 + (r*7+c)) * amp;
      y += Math.cos(t*36 + (r*11+c)) * amp * 0.6;
    }
  }
  ctx.save(); ctx.globalAlpha=a;
  const img=IMG[b]; const s=tileSize*0.9, off=tileSize*0.05;
  if(img&&img.complete) ctx.drawImage(img,x+off,y+off,s,s);
  else{ ctx.fillStyle='#444'; ctx.fillRect(x,y,tileSize,tileSize); }
  if (JUSOS.includes(b) && jusoHP[r][c] > 0) {
    const hpText = String(jusoHP[r][c]);
    ctx.font = `bold ${tileSize * 0.3}px sans-serif`;
    ctx.textAlign = 'right';
    ctx.textBaseline = 'alphabetic';
    const pad = tileSize * 0.08;
    const tx = x + tileSize - pad;
    const ty = y + tileSize - pad;
    ctx.lineWidth = tileSize * 0.08;
    ctx.strokeStyle = '#993333';
    ctx.strokeText(hpText, tx, ty);
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.fillText(hpText, tx, ty);
  }
  ctx.restore();
}

function decayJusoShake(){
  if(!jusoShake || !jusoShake.length) return;
  // æ¯ãƒ•ãƒ¬ãƒ¼ãƒ ã‚†ã£ãã‚Šæ¸›è¡°
  for(let r=0;r<size;r++){
    for(let c=0;c<size;c++){
      const v = jusoShake[r][c];
      if(v>0.001){ jusoShake[r][c] = v * 0.88; if(jusoShake[r][c]<0.001) jusoShake[r][c]=0; }
    }
  }
}


function drawChainAfterglowEmbers(){
  if (!chainAfterglowEmbers || chainAfterglowEmbers.length===0) return;

  ctx.save();

  const now = performance.now();

  // ç›¤é¢å¹…ã„ã£ã±ã„ã®ä¸Šæ˜‡ã€Œå…‰ã®å±¤ã€ï¼ˆé€£é–4ä»¥ä¸Šï¼‰
  if (chainAfterglowSheets && chainAfterglowSheets.length){
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    for (let i=chainAfterglowSheets.length-1;i>=0;i--){
      const s = chainAfterglowSheets[i];
      s.life -= 1;
      const tS = 1 - (s.life / s.maxLife); // 0â†’1
      const yCeil = logicalSize * 0.00; // ä¸Šæ˜‡æœ€ä¸Šå€¤ï¼šç›¤é¢100%ï¼ˆä¸Šç«¯ã¾ã§ï¼‰
      const pRise = Math.min(1, tS / 0.55); // ä¸Šæ˜‡ã¯å¯¿å‘½å‰åŠã§å®Œäº†ã•ã›ã‚‹
      const y0 = logicalSize - (pRise * (logicalSize - yCeil));
      const h  = logicalSize * 0.55;

      // ç™½é£›ã³é˜²æ­¢ï¼šé€£é–4ã¯æ§ãˆã‚ã€5ã§ä¸­ã€6+ã§å¼·ã‚ï¼ˆãŸã ã—ä¸Šé™ã‚ã‚Šï¼‰
      const aMax = (s.chain >= 6) ? 0.26 : (s.chain === 5 ? 0.44 : 0.18); // é€£é–5ã®ç™½ã„å…‰ç­‹ã¯é€æ˜åº¦ã‚’å€ã«
      let aS = aMax * Math.pow(1 - tS, 1.35);
      if (aS < 0) aS = 0;

      const g = ctx.createLinearGradient(0, y0+h, 0, y0);
      g.addColorStop(0, `rgba(255,255,255,0)`);
      g.addColorStop(0.35, `rgba(255,255,255,${aS*0.35})`);
      g.addColorStop(0.65, `rgba(255,255,255,${aS})`);
      g.addColorStop(1, `rgba(255,255,255,0)`);

      ctx.fillStyle = g;
      ctx.fillRect(0, y0, logicalSize, h);

      if (s.life <= 0){
        chainAfterglowSheets.splice(i,1);
      }
    }
    ctx.restore();
  }

  // ç«ã®ç²‰ã¯ç™ºå…‰ã•ã›ã‚‹ï¼ˆä»–æ¼”å‡ºã«å½±éŸ¿ã—ãªã„ã‚ˆã†ãƒ­ãƒ¼ã‚«ãƒ«ã«é™å®šï¼‰
  ctx.globalCompositeOperation = "lighter";

  const cx = logicalSize*0.5;
  const cy = logicalSize*0.48;

  for (let i=chainAfterglowEmbers.length-1;i>=0;i--){
    const e = chainAfterglowEmbers[i];
    e.life -= 1;
    const t = 1 - (e.life / e.maxLife); // 0â†’1

    // â‘£ é€£é–4ï¼šå¾ŒåŠã®é£›æ•£ãªã—ï¼ˆä¸Šæ˜‡â†’å¾ŒåŠãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆï¼‰
    if (e.chain === 4){
      // é€Ÿåº¦ãƒ»å‘ãã¯å…ƒã®ä¸Šæ˜‡æŒ™å‹•ã®ã¾ã¾ï¼ˆã“ã“ã§ã¯è¿½åŠ ã®åŠ›ã‚’ä¸ãˆãªã„ï¼‰
    } else if (e.chain >= 5){
      // â‘¤ é€£é–5ä»¥ä¸Šï¼šä¸Šæ˜‡ â†’ æºœã‚ â†’ ä¸­å¤®çªé¢¨ã§æ”¾å°„çŠ¶ã«ä¸€æ–‰é£›æ•£
      // æºœã‚ï¼ˆé€Ÿåº¦ã‚’æ®ºã—ã¦é™æ­¢ã«è¿‘ã¥ã‘ã‚‹ï¼‰
      if (!e.exploded && now >= (e.explodeAt - 120) && now < e.explodeAt){
        e.vx *= 0.25;
        e.vy *= 0.25;
      }

      // é£›æ•£ï¼ˆ1å›ã ã‘ï¼‰ã€‚ä¸Šæ–¹å‘ã‚‚ä¸è¶³ã—ãªã„ã‚ˆã†ã«ä¸Šå‘ããƒã‚¤ã‚¢ã‚¹ã‚’å…¥ã‚Œã‚‹
      if (!e.exploded && now >= e.explodeAt){
        e.exploded = true;

                // â‘¤/â‘¥ é€£é–5ä»¥ä¸Šï¼šä¸Šæ˜‡â†’å¾ŒåŠã¯æ”¾å°„çŠ¶ã«é£›æ•£ï¼ˆå…ƒã®æŒ™å‹•ï¼‰
        if (e.chain >= 5){
          const ang = Math.random() * Math.PI * 2;
          const mag = 3.8 + Math.random()*3.2;
          e.vx = Math.cos(ang) * mag;
          e.vy = Math.sin(ang) * mag;
          // â€œä¸­å¤®ã‹ã‚‰ã®çªé¢¨â€æ„Ÿï¼šå…¨ä½“ã‚’å°‘ã—ä¸Š
          e.vy -= 0.8;
        }

      }
    }

    // å…±é€šï¼šç‰©ç†
    e.vy += 0.006;         // ã‚ãšã‹ãªé‡åŠ›
    e.vx *= (e.chain === 4 ? 0.992 : 0.985);         // ç©ºæ°—æŠµæŠ—ï¼ˆé€£é–4ã¯ãµã‚ãµã‚åºƒã‚ï¼‰
    e.vy *= 0.990;

    e.x += e.vx;
    e.y += e.vy;

    // ä¸Šæ˜‡æœ€ä¸Šå€¤ï¼šç›¤é¢100%ï¼ˆä¸Šç«¯ã¾ã§ï¼‰ã«ç¢ºå®Ÿã«åˆ°é”ã•ã›ã‚‹
    const yCeil = logicalSize * 0.00;
    if (!e.reachedCeil){
      // ä¸Šæ˜‡ãŒå¤±é€Ÿã—ã¦ã‚‚ã€å¤©äº•åˆ°é”ã¾ã§ã¯ä¸Šå‘ãã‚’ä¿è¨¼
      if (e.chain === 4){
        if (e.vy > -0.95) e.vy = -0.95 - Math.random()*0.55;
      } else {
        if (e.vy > -0.55) e.vy = -0.55 - Math.random()*0.45;
      }
      if (e.y <= yCeil){
        e.reachedCeil = true;
        e.y = yCeil;
      }
    }

    // â€œé€ã‘ãªã„ç«èŠ±æ„Ÿâ€ï¼šåºç›¤ã‚’å¼·ãã€å¾ŒåŠã¯ç´ æ—©ãè½ã¨ã™
    let a = (t < 0.55) ? (0.95 - 0.25*t) : (0.60 * (1 - (t-0.55)/0.45));
    // ãƒãƒ©ãƒãƒ©ï¼ˆè¼åº¦ã‚†ã‚‰ãï¼‰
    a *= (0.78 + 0.22*Math.sin(e.flick + t*18.0));
    if (a < 0) a = 0;

    // é€£é–4ã¯ã€Œå›è»¢ãƒ»ç¸®å°ã€ã•ã›ãšã€å¾ŒåŠã ã‘ç´ ç›´ã«ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
    if (e.chain === 4){
      // é€£é–4ã¯ç›¤é¢ã‚’ç™½é£›ã³ã§è¦†ã‚ãªã„ã‚ˆã†ã€æ˜åº¦ã‚’æŠ‘ãˆã¦å¾ŒåŠã®ã¿ç´ ç›´ã«ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
      a = (t < 0.60) ? 0.40 : (0.40 * (1 - (t-0.60)/0.40));
      if (a < 0) a = 0;
    }


    // ç›¤é¢å¹…ã¾ã§åºƒã’ã‚‹ä¸Šæ˜‡ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã¯ã€ç™½é£›ã³ã‚’é¿ã‘ã‚‹ãŸã‚é€£é–5ä»¥ä¸Šã«é™å®š
    const r = (e.chain === 3) ? e.r0 : (e.r0 * (t < 0.18 ? (1.25 - t*1.2) : (1.0 - (t-0.18)*0.35))); // â‘¢/â‘£ç”¨ï¼ˆ3ã¯ç¸®å°ã•ã›ãªã„ï¼‰
    const g = ctx.createRadialGradient(e.x, e.y, 0, e.x, e.y, r*3.0);

    if (e.chain >= 6){
      // é€£é–6ä»¥ä¸Šï¼šç™½èŠ¯â†’é’ç™½â†’èµ¤â†’é€æ˜ï¼ˆå¼·ã„å…‰ã¨åœ°ç„æ„Ÿï¼‰
      g.addColorStop(0.0, `rgba(255,255,255,${Math.min(1,a*1.0)})`);
      g.addColorStop(0.22,`rgba(210,245,255,${Math.min(1,a*0.95)})`);
      g.addColorStop(0.55,`rgba(255,70,40,${Math.min(1,a*0.75)})`);
      g.addColorStop(1.0, `rgba(0,0,0,0)`);
    } else {
      // ç™½èŠ¯â†’é»„ç™½â†’æ©™â†’é€æ˜ï¼ˆå¤–å‘¨ã‚’æ—©ãé€æ˜ã¸è½ã¨ã—ã¦â€œè‰²æ°´åŒ–â€å›é¿ï¼‰
      g.addColorStop(0.0, `rgba(255,255,245,${Math.min(1,a*1.0)})`);
      g.addColorStop(0.22,`rgba(255,240,190,${Math.min(1,a*0.95)})`);
      g.addColorStop(0.55,`rgba(255,165,70,${Math.min(1,a*0.70)})`);
      g.addColorStop(1.0, `rgba(30,5,0,0)`);
    }

    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(e.x, e.y, r*2.2, 0, Math.PI*2);
    ctx.fill();

    if (e.life <= 0 || e.y < -40 || e.x < -60 || e.x > logicalSize+60){
      chainAfterglowEmbers.splice(i,1);
    }
  }

  ctx.restore();
}

function drawGame(){ /* (çœç•¥: å¤‰æ›´ãªã—) */
  decayJusoShake();
  ctx.clearRect(0,0,logicalSize,logicalSize);
  const bg=IMG.BG; if(bg&&bg.complete&&bg.naturalWidth>0){
    for(let r=0;r<size;r++) for(let c=0;c<size;c++){
      ctx.drawImage(bg,0,0,bg.naturalWidth,bg.naturalHeight,c*tileSize,r*tileSize,tileSize,tileSize);
    }
  }
  if(!isKanki){ ctx.save(); ctx.fillStyle='rgba(60,0,0,0.22)'; ctx.fillRect(0,0,logicalSize,logicalSize); ctx.restore(); }

  for(let r=0;r<size;r++) for(let c=0;c<size;c++){
    if(get(r,c)===null) continue;
    let x=c*tileSize, y=r*tileSize, a=1, ty=0;
    if(animState==="vanish" && vanishMask && vanishMask.has(`${r},${c}`)) a = 1-vanishP;
    if(animState==="drop" && yAnim[r][c]!==0) ty = yAnim[r][c];
    if(animState==="swap" && swapPair){
      const {p1,p2,p,back}=swapPair; const prog=Math.min(1,p/(SWAP_ANIM_TIME)), e=Math.sin(prog*Math.PI/2);
      if(r===p1.r&&c===p1.c){ x+=(back?(p2.c-p1.c)*tileSize*(1-e):(p2.c-p1.c)*tileSize*e);
                               y+=(back?(p2.r-p1.r)*tileSize*(1-e):(p2.r-p1.r)*tileSize*e); }
      if(r===p2.r&&c===p2.c){ x+=(back?(p1.c-p2.c)*tileSize*(1-e):(p1.c-p2.c)*tileSize*e);
                               y+=(back?(p1.r-p2.r)*tileSize*(1-e):(p1.r-p2.r)*tileSize*e); }
    }
    drawBlock(r,c,x,y+ty,a);
  }
  // èƒŒæ™¯è„ˆå‹• â†’ æ–¬æ’ƒ â†’ æ®‹å…‰ã®å°¾ â†’ ç«æŸ± â†’ ç«ã®é›¨ â†’ æ³¢ç´‹ â†’ ã‚ªãƒ¼ãƒ­ãƒ© â†’ ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ« ã®é †ã§å‰æ™¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’æç”»
  // 6é€£é–ä»¥ä¸Šã®æ²ˆé»™ãƒ•ãƒ¬ãƒ¼ãƒ ä¸­ã¯ã€å‰æ™¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’æã‹ãšï¼ˆ=æ›´æ–°ã‚‚æ­¢ã¾ã‚Šï¼‰ç›¤é¢ã®è¦–èªæ€§ã¨å®‰å®šæ€§ã‚’å„ªå…ˆ
  const __now = (typeof performance!=='undefined' && performance.now) ? performance.now() : Date.now();
  const __freeze = (__now < comboFreezeUntil);
  if (!__freeze){
    drawBgPulse();
    try{ drawSlashes(); }catch(_){ }
  // ç‰¹æ®Šé§’æ¶ˆå»å¯¾è±¡ã®è¦–èªæ€§ï¼ˆé»’é„ï¼‹ä½å½©åº¦èµ¤äº€è£‚ï¼‰
  try{ drawShuraCracks(); }catch(_){ }
    drawTrails();
    drawFlames();
    drawFlamePillars();
    drawFireRains();
    drawChainAfterglowEmbers(); // â˜…é€£é–çµ‚äº†ã®æ®‹éŸ¿
    drawFlameRipples();
    drawAurora();
    drawParticles();
  }
if(animState==="swap" && swapPair){
    const {p1,p2,p,back}=swapPair; const prog=Math.min(1,p/(SWAP_ANIM_TIME)), e=Math.sin(prog*Math.PI/2);
    let x1=p1.c*tileSize+(back?(p2.c-p1.c)*tileSize*(1-e):(p2.c-p1.c)*tileSize*e);
    let y1=p1.r*tileSize+(back?(p2.r-p1.r)*tileSize*(1-e):(p2.r-p1.r)*tileSize*e);
    drawBlock(p1.r,p1.c,x1,y1,1);
    let x2=p2.c*tileSize+(back?(p1.c-p2.c)*tileSize*(1-e):(p1.c-p2.c)*tileSize*e);
    let y2=p2.r*tileSize+(back?(p1.r-p2.r)*tileSize*(1-e):(p1.r-p2.r)*tileSize*e);
    drawBlock(p2.r,p2.c,x2,y2,1);
  }
}

/* ã‚¹ãƒ¯ãƒƒãƒ—ï½ãƒ«ãƒ¼ãƒ— (çœç•¥: å¤‰æ›´ãªã—) */
function canSwapAndMatch(r1,c1,r2,c2){ /* (çœç•¥: å¤‰æ›´ãªã—) */
  if(JUSOS.includes(get(r1,c1))||JUSOS.includes(get(r2,c2))){
    if (JUSOS.includes(get(r1,c1))) triggerJusoShake(r1,c1, 1.0);
    if (JUSOS.includes(get(r2,c2))) triggerJusoShake(r2,c2, 1.0);
    Sound.play('not', 1.0);
    return false;
  }
  swap(r1,c1,r2,c2);
  const has = !!findMatches(true);
  swap(r1,c1,r2,c2);
  return has;
}
function swapAndStart(r1,c1,r2,c2){ /* (çœç•¥: å¤‰æ›´ãªã—) */
  resetComboForNewMove();
  swapPair={p1:{r:r1,c:c1},p2:{r:r2,c:c2},p:0,back:false};
  lastMoveAnchor={r:r2,c:c2};
  animState="swap";
  userGesture();
}

/* â˜…ã—ã‚…ã‚‰ã¡ã‚ƒã‚“ï¼ãƒ¬ã‚¯ã—ã‚…ã‚‰ç”¨ãƒ˜ãƒ«ãƒ‘ãƒ¼ */

// æŒ‡å®šãƒã‚¹ã‚’ä¸­å¿ƒã¨ã—ãŸã€Œãã®ãƒã‚¹ã‚’å«ã‚€ãƒãƒƒãƒã®æ¶ˆå»å€‹æ•°ã€ã‚’è¿”ã™
// ç›´ç·š 4,5 ã ã‘ã§ãªã Lå­— / Tå­— (åˆè¨ˆ5) ã‚‚æ¤œå‡ºã™ã‚‹ãŸã‚ã€ç¸¦æ¨ªã‚’åˆç®—ã™ã‚‹ã€‚
function getMatchSizeAt(r,c){
  const sym = get(r,c);
  if (!sym || JUSOS.includes(sym) || sym==="SHURACHAN" || sym==="REKUSHURA") return 0;

  let up=0, down=0, left=0, right=0;
  for(let rr=r-1; rr>=0   && get(rr,c)===sym; rr--) up++;
  for(let rr=r+1; rr<size && get(rr,c)===sym; rr++) down++;
  for(let cc=c-1; cc>=0   && get(r,cc)===sym; cc--) left++;
  for(let cc=c+1; cc<size && get(r,cc)===sym; cc++) right++;

  const lenV = up + 1 + down;
  const lenH = left + 1 + right;
  let total = 0;
  if (lenV>=3) total += lenV;
  if (lenH>=3) total += lenH;
  if (lenV>=3 && lenH>=3) total -= 1; // ä¸­å¿ƒã‚’äºŒé‡ã‚«ã‚¦ãƒ³ãƒˆã—ãªã„

  return total;
}

// ãƒ¬ã‚¯ã—ã‚…ã‚‰ or ã—ã‚…ã‚‰ã¡ã‚ƒã‚“ã¨ã€Œé€šå¸¸é§’ã€ã‚’ã‚¹ãƒ¯ãƒƒãƒ—ã—ãŸã¨ãã®åŸºæœ¬ãƒã‚¹ã‚¯
function buildShuraItemMask(sym, r, c, targetSym){
  if (!targetSym || JUSOS.includes(targetSym) || targetSym==="SHURACHAN" || targetSym==="REKUSHURA") return null;

  const mask = new Set();

  if (sym==="SHURACHAN"){
    // åå­—å…¨æ¶ˆã—ï¼ˆè¡Œï¼‹åˆ—ï¼‰ï¼‹å·»ãè¾¼ã¾ã‚ŒãŸ ã—ã‚…ã‚‰ã¡ã‚ƒã‚“ ã‚‚é€£é–ç™ºå‹•
    const queue = [];
    const visited = new Set();
    const startKey = r + "," + c;
    queue.push(startKey);
    while (queue.length){
      const key = queue.shift();
      if (visited.has(key)) continue;
      visited.add(key);
      const parts = key.split(",");
      const cr = parseInt(parts[0], 10);
      const cc0 = parseInt(parts[1], 10);
      // æ¨ªæ–¹å‘
      for (let cc=0; cc<size; cc++){
        const k = cr + "," + cc;
        mask.add(k);
        const symAt = get(cr, cc);
        if (symAt === "SHURACHAN" && !visited.has(k)) queue.push(k);
      }
      // ç¸¦æ–¹å‘
      for (let rr=0; rr<size; rr++){
        const k = rr + "," + cc0;
        mask.add(k);
        const symAt = get(rr, cc0);
        if (symAt === "SHURACHAN" && !visited.has(k)) queue.push(k);
      }
    }
  } else if (sym==="REKUSHURA"){
    // ç›¸æ‰‹ã®é§’ã¨åŒã˜ç¨®é¡ã‚’ç›¤é¢ã‹ã‚‰å…¨ã¦æ¶ˆå»ï¼‹ã‚¢ã‚¤ãƒ†ãƒ æœ¬ä½“
    for(let rr=0; rr<size; rr++){
      for(let cc=0; cc<size; cc++){
        if(get(rr,cc)===targetSym){
          mask.add(rr + "," + cc);
        }
      }
    }
    mask.add(r + "," + c);
  } else {
    return null;
  }

  if (mask.size===0) return null;
  return mask;
}

// æ¶ˆå»ãƒã‚¹ã‚¯ï¼ˆ"r,c" ã® Setï¼‰ã‹ã‚‰ã€é€£é–æ¼”å‡ºã®ä¸­å¿ƒåº§æ¨™ï¼ˆç›¤é¢åº§æ¨™ï¼‰ã‚’ç®—å‡º
function computeMaskCenter(mask){
  try{
    if(!mask || mask.size===0) return { x: logicalSize/2, y: logicalSize/2 };
    let sx=0, sy=0, n=0;
    mask.forEach(pos=>{
      const parts = (''+pos).split(',');
      if(parts.length!==2) return;
      const r = Number(parts[0]), c = Number(parts[1]);
      if (isNaN(r) || isNaN(c)) return;
      sx += c*tileSize + tileSize/2;
      sy += r*tileSize + tileSize/2;
      n++;
    });
    if(!n) return { x: logicalSize/2, y: logicalSize/2 };
    return { x: sx/n, y: sy/n };
  }catch(_){
    return { x: logicalSize/2, y: logicalSize/2 };
  }
}


// ã—ã‚…ã‚‰ã¡ã‚ƒã‚“ï¼ãƒ¬ã‚¯ã—ã‚…ã‚‰å°‚ç”¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ï¼ˆè»½é‡ï¼‰
function createShuraItemParticles(kind, r, c){
  const cx = c*tileSize + tileSize/2;
  const cy = r*tileSize + tileSize/2;
  const count = 12; // é€šå¸¸ã‚ˆã‚Šå°‘ãªã‚ã§è»½é‡åŒ–
  let palette;
  if (kind==="SHURACHAN"){
    // æ°´è‰²ï¼‹èµ¤
    palette = [
      {r:120, g:200, b:255},
      {r:255, g:80,  b:140}
    ];
  } else {
    // é’ï¼‹èµ¤
    palette = [
      {r:80,  g:120, b:255},
      {r:255, g:80,  b:140}
    ];
  }
  for(let i=0;i<count;i++){
    const ang = Math.random()*Math.PI*2;
    const spd = tileSize*(0.10 + Math.random()*0.06);
    const vx  = Math.cos(ang)*spd;
    const vy  = Math.sin(ang)*spd;
    const col = palette[Math.floor(Math.random()*palette.length)];
    particles.push({
      x: cx,
      y: cy,
      vx,
      vy,
      life: 0,
      maxLife: 22,
      color: col,
      kind: (kind==="SHURACHAN" ? "shura" : "rekushura")
    });
  }
}

function gameLoop(){ /* (çœç•¥: å¤‰æ›´ãªã—) */
  if(paused) return;
  // === 6é€£é–ä»¥ä¸Šï¼šæ²ˆé»™ãƒ•ãƒ¬ãƒ¼ãƒ å¾Œã«é€£é–æ¼”å‡ºã‚’é–‹å§‹ï¼ˆå®‰å®šå„ªå…ˆï¼‰ ===
  try{
    const now = (typeof performance!=='undefined' && performance.now) ? performance.now() : Date.now();
    if (pendingComboAurora && now >= pendingComboAuroraDue){
      pendingComboAurora = false;
      pendingComboAuroraDue = 0;
      triggerAurora(false, pendingComboAnchor || comboEffectAnchor, pendingComboLevel || 6);
      pendingComboLevel = 0;
      pendingComboAnchor = null;
    }
  }catch(_){}
  drawGame();
  switch(animState){
    case "swap":
      if(swapPair){
        swapPair.p++;
        if(swapPair.p>=SWAP_ANIM_TIME){
       

function createShuraItemBurstEffects(mask, kind){
  // ç‰¹æ®Šé§’ï¼ˆãƒŸãƒŸãƒƒã‚¯/ãƒã‚ªãƒ¬ãƒˆãƒ­/ã‚·ãƒ³ã‚®ãƒ¥ãƒ©/ãƒ¬ã‚¯ã‚¤ã‚¨ãƒ /ã‚¢ãƒ³ãƒã‚¦ãƒ³ï¼‰ãŒæƒã£ãŸæ™‚ã‚‚åå­—ã‚’èµ¤ç³»ã«
  const isSpecialKindForRed = (kind==='S_BIR' || kind==='S_NE0' || kind==='S_SHU' || kind==='S_REQ' || kind==='S_UNK');
  const specialCol = isSpecialKindForRed ? {outer:'rgba(140,30,40,0.25)', inner:'rgba(170,10,30,0.9)'} : null;
  if (!mask || !kind) return;
  const palette = (kind==="SHURACHAN")
    ? [{r:120,g:200,b:255},{r:255,g:80,b:140}]
    : [{r:80,g:120,b:255},{r:255,g:80,b:140}];

  // ã—ã‚…ã‚‰ã¡ã‚ƒã‚“ï¼ãƒ¬ã‚¯ã—ã‚…ã‚‰ã®æ¶ˆå»ç¯„å›²ã™ã¹ã¦ã«â˜…ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ï¼‹æ°´è‰²ã‚°ãƒ­ã‚¦åå­—ï¼‹æ®‹å…‰ã®å°¾
  mask.forEach(pos=>{
    const parts = pos.split(',');
    if (parts.length!==2) return;
    const r = Number(parts[0]), c = Number(parts[1]);
    if (isNaN(r) || isNaN(c)) return;
    const cx = c*tileSize + tileSize/2;
    const cy = r*tileSize + tileSize/2;

    // æ°´è‰²ã‚°ãƒ­ã‚¦ã®åå­—ï¼ˆã—ã‚…ã‚‰ã¡ã‚ƒã‚“ï¼ãƒ¬ã‚¯ã—ã‚…ã‚‰å°‚ç”¨ï¼‰
    slashes.push({col: specialCol, x:cx,y:cy,dir:'h',t:0,kind:'shuraCross'});
    slashes.push({col: specialCol, x:cx,y:cy,dir:'v',t:0,kind:'shuraCross'});

    // â˜…ãƒ¬ãƒ™ãƒ«1ï¼šã—ã‚…ã‚‰ã¡ã‚ƒã‚“ï¼ãƒ¬ã‚¯ã—ã‚…ã‚‰ã®åå­—ã‹ã‚‰æ®‹å…‰ãƒˆãƒ¬ã‚¤ãƒ«ã‚’ç”Ÿæˆï¼ˆv2ã®ç´„åŠåˆ†ï¼‰
    const trailLen = tileSize * 1.2;
    const trailLife = 30; // è¡¨ç¤ºæ™‚é–“ã‚’å°‘ã—å»¶é•·
    const baseTrail = { x: cx, y: cy, length: trailLen, life: 0, maxLife: trailLife, phase: Math.random()*Math.PI*2 };
    trails.push(Object.assign({ dir: 'h' }, baseTrail));
    trails.push(Object.assign({ dir: 'v' }, baseTrail));

    // å¯æ„›ã„â˜…ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ï¼ˆæ§ãˆã‚ãªæ•°ã§è² è·è»½æ¸›ï¼‰
    const baseCount = 4;
    for(let i=0;i<baseCount;i++){
      const ang = Math.random()*Math.PI*2;
      const spd = tileSize*(0.07 + Math.random()*0.05);
      const vx  = Math.cos(ang)*spd;
      const vy  = Math.sin(ang)*spd;
      const col = palette[Math.floor(Math.random()*palette.length)];
      particles.push({
        x: cx,
        y: cy,
        vx,
        vy,
        life: 0,
        maxLife: 20,
        color: col,
        kind: (kind==="SHURACHAN" ? "shura" : "rekushura")
      });
    }
  });
}

   const {p1,p2,back}=swapPair;
          if(!back){
            swap(p1.r,p1.c,p2.r,p2.c);

            const b1 = get(p1.r,p1.c);
            const b2 = get(p2.r,p2.c);
            const isItem1 = (b1==="SHURACHAN" || b1==="REKUSHURA");
            const isItem2 = (b2==="SHURACHAN" || b2==="REKUSHURA");

            // â˜…ãŠé‚ªé­”ã¨ã‚¢ã‚¤ãƒ†ãƒ ã®ã‚¹ãƒ¯ãƒƒãƒ—ã¯ç„¡åŠ¹ï¼ˆå…ƒã«æˆ»ã™ï¼‰
            if ((isItem1 || isItem2) && (JUSOS.includes(b1) || JUSOS.includes(b2))){
              swap(p1.r,p1.c,p2.r,p2.c);
              swapPair.p=0;
              swapPair.back=true;
            } else if (isItem1 || isItem2){
              // â˜…ã‚¢ã‚¤ãƒ†ãƒ åŒå£«ï¼ã‚¢ã‚¤ãƒ†ãƒ ï¼‹é€šå¸¸é§’ã®ã‚¹ãƒ¯ãƒƒãƒ—
              let mask = null;
              let particleKind = null;
              lastRekCrossCombo = false;
              // ã—ã‚…ã‚‰Ã—ã—ã‚…ã‚‰ â†’ ä¸¡æ–¹ã®ä½ç½®ã§åå­—ï¼ˆåˆæˆï¼‰
              if (b1==="SHURACHAN" && b2==="SHURACHAN"){
                mask = new Set();
                const addCross = (rr,cc)=>{
                  for(let x=0;x<size;x++) mask.add(rr + "," + x);
                  for(let y=0;y<size;y++) mask.add(y + "," + cc);
                };
                addCross(p1.r,p1.c);
                addCross(p2.r,p2.c);
                particleKind = "SHURACHAN";
              }
              // ãƒ¬ã‚¯Ã—ãƒ¬ã‚¯ â†’ ç›¤é¢ã®ã€Œå…¨ç¨®é¡ã€ã‚’ä¸€æ–‰ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ï¼ˆå…¨æ¶ˆå»ï¼‰
              else if (b1==="REKUSHURA" && b2==="REKUSHURA"){
                lastRekCrossCombo = false;
                mask = new Set();
                // ç›¤é¢ä¸Šã® null ã§ãªã„å…¨ã¦ã®é§’ã‚’ä¸€åº¦ã«æ¶ˆå»
                for(let rr=0; rr<size; rr++){
                  for(let cc=0; cc<size; cc++){
                    if (get(rr,cc) !== null){
                      mask.add(rr + "," + cc);
                    }
                  }
                }
                // å…¨æ¶ˆå» â†’ ãã®å¾Œã®è½ä¸‹ï¼†è‡ªç„¶é€£é–ã§ã€Œç›¤é¢ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ã€æ¼”å‡º
                particleKind = "REKUSHURA";
              }
              // ãƒ¬ã‚¯Ã—ã—ã‚…ã‚‰ or ã—ã‚…ã‚‰Ã—ãƒ¬ã‚¯ â†’ ã€Œåå­—æ¶ˆå» â†’ æ¶ˆãˆãŸè‰²ã®å…¨æ¶ˆå»ï¼ˆ2æ®µéšæ¼”å‡ºï¼‰ã€
              else if ((b1==="REKUSHURA" && b2==="SHURACHAN") || (b2==="REKUSHURA" && b1==="SHURACHAN")){
                // ãƒ¬ã‚¯Ã—ã—ã‚…ã‚‰ / ã—ã‚…ã‚‰Ã—ãƒ¬ã‚¯ï¼š2æ®µéš
                // 1) ã—ã‚…ã‚‰ã¡ã‚ƒã‚“åŸºæº–ã®åå­—æ¶ˆå»ï¼ˆå·»ãè¾¼ã¾ã‚ŒãŸ ã—ã‚…ã‚‰ã¡ã‚ƒã‚“ ã‚‚é€£é–ç™ºå‹•ï¼‰
                // 2) åå­—ã§æ¶ˆãˆãŸé€šå¸¸é§’ã®ç¨®é¡ã‚’ãƒˆãƒªã‚¬ãƒ¼ã¨ã—ã¦ã€ç›¤é¢ã‹ã‚‰åŒç¨®ã‚’å…¨æ¶ˆå»ï¼ˆresolveVanishAndDropå†…ã§ç¬¬2æ®µéšã‚’å®Ÿè¡Œï¼‰
                lastRekCrossCombo = true;
                rekCrossStage = 1;
                rekCrossSyms = null;

                const crossMask = new Set();
                const shuraPos = (b1 === "SHURACHAN") ? p1 : p2;
                const triggerSyms = new Set();

                const queue = [];
                const visited = new Set();
                const startKey = shuraPos.r + "," + shuraPos.c;
                queue.push(startKey);

                while (queue.length){
                  const key = queue.shift();
                  if (visited.has(key)) continue;
                  visited.add(key);
                  const parts = key.split(",");
                  const cr = parseInt(parts[0], 10);
                  const cc0 = parseInt(parts[1], 10);

                  // æ¨ªæ–¹å‘
                  for (let x=0; x<size; x++){
                    const k = cr + "," + x;
                    crossMask.add(k);
                    const sym = get(cr, x);
                    if (NORMALS.includes(sym)) triggerSyms.add(sym);
                    if (sym === "SHURACHAN" && !visited.has(k)) queue.push(k);
                  }
                  // ç¸¦æ–¹å‘
                  for (let y=0; y<size; y++){
                    const k = y + "," + cc0;
                    crossMask.add(k);
                    const sym = get(y, cc0);
                    if (NORMALS.includes(sym)) triggerSyms.add(sym);
                    if (sym === "SHURACHAN" && !visited.has(k)) queue.push(k);
                  }
                }

                // ãƒ¬ã‚¯ã—ã‚…ã‚‰ï¼†ã—ã‚…ã‚‰ã¡ã‚ƒã‚“è‡ªèº«ã‚‚ç¢ºå®Ÿã«ç¬¬1æ®µéšã§æ¶ˆã™
                crossMask.add(p1.r + "," + p1.c);
                crossMask.add(p2.r + "," + p2.c);

                // ç¬¬2æ®µéšç”¨ã«ã€Œãƒˆãƒªã‚¬ãƒ¼ç¨®é¡ã€ã‚’ä¿å­˜ï¼ˆã“ã®ç¬é–“ã®åå­—å·»ãè¾¼ã¿åŸºæº–ï¼‰
                rekCrossSyms = Array.from(triggerSyms);

                // ç¬¬1æ®µéšæ¼”å‡ºï¼šåå­—ã ã‘å…ˆã«å…‰ã‚‰ã›ã‚‹ï¼ˆã—ã‚…ã‚‰ã¡ã‚ƒã‚“ã‚«ãƒ©ãƒ¼ï¼‰
                try{
                  if (crossMask && crossMask.size > 0){
                    createShuraItemBurstEffects(crossMask, "SHURACHAN");
                  }
                }catch(_){}

                // å®Ÿéš›ã®æ¶ˆå»ãƒã‚¹ã‚¯ã¯ç¬¬1æ®µéšï¼ˆåå­—ï¼‰ã®ã¿
                mask = crossMask;
                particleKind = "REKUSHURA";
              }
              // ã‚¢ã‚¤ãƒ†ãƒ ï¼‹é€šå¸¸é§’ï¼ˆç‰‡å´ã®ã¿ã‚¢ã‚¤ãƒ†ãƒ ï¼‰
              else{
                let itemSym, itemPos, targetSym;
                if (isItem1 && !isItem2){
                  itemSym = b1; itemPos = p1; targetSym = b2;
                } else if (isItem2 && !isItem1){
                  itemSym = b2; itemPos = p2; targetSym = b1;
                }
                if (itemSym){
                  mask = buildShuraItemMask(itemSym, itemPos.r, itemPos.c, targetSym);
                  particleKind = itemSym;
                }
              }

              if (mask && mask.size>0){
                vanishMask = mask;
                // â˜…é€£é–æ¼”å‡ºã®ä¸­å¿ƒã‚’ã€Œä»Šå›ã®æ¶ˆå»ç¯„å›²ã€ã«è¿½å¾“
                try{ comboEffectAnchor = computeMaskCenter(mask); }catch(_){ comboEffectAnchor = { x: logicalSize/2, y: logicalSize/2 }; }
// â˜…ã—ã‚…ã‚‰ã¡ã‚ƒã‚“ï¼ãƒ¬ã‚¯ã—ã‚…ã‚‰å°‚ç”¨ã®æ¶ˆå»ãƒ•ãƒ©ã‚°ã‚’è¨˜éŒ²
                lastShuraItemKind = particleKind || "SHURACHAN";
                lastShuraItemMask  = new Set(mask);
                swapPair = null;
                animState = "vanish";
                vanishP = 0;
                try{
                  // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã¯ä»£è¡¨1ç‚¹ï¼ˆã‚¹ãƒ¯ãƒƒãƒ—å¾Œã®ä¸­å¤®ä»˜è¿‘ï¼‰ã‹ã‚‰ã®ã¿ç™ºç”Ÿã•ã›ã¦è»½é‡åŒ–
                  const centerR = Math.floor((p1.r + p2.r)/2);
                  const centerC = Math.floor((p1.c + p2.c)/2);
                  createShuraItemParticles(lastShuraItemKind, centerR, centerC);
                  // â˜…æ¶ˆå»ç¯„å›²å…¨ä½“ã«ã‚‚æ˜Ÿãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ï¼‹ç™½åå­—ï¼ˆ2æ®µéšæ¼”å‡ºå¯¾å¿œï¼‰
                  const isRekCross = (lastShuraItemKind === "REKUSHURA" && lastRekCrossCombo);
                  if (isRekCross){
                    // åå­—ã¯ã™ã§ã« crossMask ã§å…ˆã«å…‰ã‚‰ã›ã¦ã„ã‚‹ã®ã§ã€å…¨ä½“æ¼”å‡ºã¯å°‘ã—é…ã‚‰ã›ã‚‹
                    setTimeout(()=>{
                      try{
                        createShuraItemBurstEffects(lastShuraItemMask, lastShuraItemKind);
                      }catch(_){}
                    }, 420);
                  } else {
                    try{
                      createShuraItemBurstEffects(lastShuraItemMask, lastShuraItemKind);
                    }catch(_){}
                  }
                  // â˜…ãƒ¬ã‚¯ã—ã‚…ã‚‰ç³»ãƒãƒ¼ã‚¹ãƒˆæ™‚ã¯å°‚ç”¨ã‚¸ãƒ³ã‚°ãƒ«ï¼ˆitemskillï¼‰ã‚’å„ªå…ˆ
                  try{
                    let seName = 'item';
                    if (lastShuraItemKind === "REKUSHURA"){
                      seName = 'itemskill';
                    }
                    Sound.play(seName,1.0);
                  }catch(_){ }
                }catch(_){}
              } else {
                // ç„¡åŠ¹ãªã‚¹ãƒ¯ãƒƒãƒ—ã ã£ãŸã®ã§å…ƒã«æˆ»ã™
                swap(p1.r,p1.c,p2.r,p2.c);
                swapPair.p=0;
                swapPair.back=true;
              }
            } else {
              // â˜…é€šå¸¸ã‚¹ãƒ¯ãƒƒãƒ—ï¼š4å€‹/5å€‹ãƒãƒƒãƒã«ã‚ˆã‚‹ã‚¢ã‚¤ãƒ†ãƒ ç”Ÿæˆäºˆç´„
              let bestSize = 0;
              let bestPos = null;
              const size1 = getMatchSizeAt(p1.r,p1.c);
              if (size1>bestSize){ bestSize=size1; bestPos=p1; }
              const size2 = getMatchSizeAt(p2.r,p2.c);
              if (size2>bestSize){ bestSize=size2; bestPos=p2; }

              const hasMatch = findMatches(true);
              if (hasMatch){
                // ãƒãƒƒãƒãŒæˆç«‹ã—ãŸã¨ãã®ã¿ã‚¢ã‚¤ãƒ†ãƒ ç”Ÿæˆã‚’äºˆç´„
                pendingShuraItem    = null;
                pendingShuraItemPos = null;
                if (bestSize>=5){
                  pendingShuraItem    = "REKUSHURA";
                  pendingShuraItemPos = { r: bestPos.r, c: bestPos.c };
                } else if (bestSize>=4){
                  pendingShuraItem    = "SHURACHAN";
                  pendingShuraItemPos = { r: bestPos.r, c: bestPos.c };
                }
                findMatches(false);
                swapPair=null;
                animState="vanish";
              } else {
                // ãƒãƒƒãƒä¸æˆç«‹ï¼šã‚¢ã‚¤ãƒ†ãƒ äºˆç´„ã‚‚ç„¡åŠ¹
                pendingShuraItem    = null;
                pendingShuraItemPos = null;
                swap(p1.r,p1.c,p2.r,p2.c);
                swapPair.p=0;
                swapPair.back=true;
              }
            }
          }else{ swapPair=null; animState="idle"; }
        }
      }
      break;
    case "vanish":
      vanishP += (1/VANISH_ANIM_TIME); if(vanishP>=1){ resolveVanishAndDrop(); }
      break;
    case "drop":
      let done=true;
      for(let r=0;r<size;r++) for(let c=0;c<size;c++){
        if(yAnim[r][c]!==0 || yVel[r][c]!==0){
          const g = GRAVITY*tileSize;
      yVel[r][c] += g;
      yVel[r][c] *= 0.88;
      if (yAnim[r][c] + yVel[r][c] >= 0){
        yAnim[r][c] = 0;
        yVel[r][c]  = 0;
      } else {
        yAnim[r][c] += yVel[r][c];
      }
          if(yAnim[r][c]!==0 || yVel[r][c]!==0) done=false;
        }
      }
      if(done){
        if(findMatches(true)){
          isCascadeMatch = true;
          findMatches(false);
          isCascadeMatch = false;
          animState="vanish";
        }
        else { animState="idle"; endComboIfAny(); }
      }
      break;
  }
  requestAnimationFrame(gameLoop);
}

/* ã‚·ãƒ£ãƒƒãƒ•ãƒ« (çœç•¥: å¤‰æ›´ãªã—) */
function hasPossibleMoves(){ /* (çœç•¥: å¤‰æ›´ãªã—) */
  for(let r=0;r<size;r++) for(let c=0;c<size;c++){
    if(c+1<size && canSwapAndMatch(r,c,r,c+1)) return true;
    if(r+1<size && canSwapAndMatch(r,c,r+1,c)) return true;
  }
  return false;
}
function shuffleBoard(){ /* (çœç•¥: å¤‰æ›´ãªã—) */
  // â˜…ã‚·ãƒ£ãƒƒãƒ•ãƒ«å‰ã«ã€å‘ªè©›ãƒ–ãƒ­ãƒƒã‚¯ã‚’å°‘ã—ã ã‘å‰Šã£ã¦è©°ã¾ã‚Šã‚’ç·©å’Œã™ã‚‹
  try{
    if (Array.isArray(board) && Array.isArray(jusoHP) && Array.isArray(JUSOS)){
      const candidates = [];
      for(let r=0;r<size;r++){
        for(let c=0;c<size;c++){
          const b = board[r][c];
          if (JUSOS.includes(b) && jusoHP[r] && jusoHP[r][c] > 0){
            candidates.push({r,c});
          }
        }
      }
      if (candidates.length > 0){
        const pick = candidates[Math.floor(Math.random()*candidates.length)];
        const rr = pick.r, cc = pick.c;
        if (jusoHP[rr][cc] > 0){
          jusoHP[rr][cc]--;
          if (jusoHP[rr][cc] <= 0){
            jusoHP[rr][cc] = 0;
            (window.__jusoEraseSet ||= new Set()).add(rr + ',' + cc);
            set(rr,cc,null);
          }
        }
      }
    }
  }catch(_){}

  const maxTries=300; let tries=0;
  do{
    // ç›¤é¢ã¨å‘ªè©›ãƒ–ãƒ­ãƒƒã‚¯HPãƒ»ã‚·ã‚§ã‚¤ã‚¯ã‚’ã¾ã¨ã‚ã¦ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã™ã‚‹
    const flatCells = [];
    for(let r=0;r<size;r++){
      for(let c=0;c<size;c++){
        flatCells.push({
          b: board[r][c],
          hp: (jusoHP && jusoHP[r]) ? jusoHP[r][c] || 0 : 0,
          shake: (jusoShake && jusoShake[r]) ? jusoShake[r][c] || 0 : 0
        });
      }
    }
    for(let i=flatCells.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      const tmp = flatCells[i];
      flatCells[i] = flatCells[j];
      flatCells[j] = tmp;
    }
    for(let r=0,k=0;r<size;r++){
      for(let c=0;c<size;c++,k++){
        const cell = flatCells[k];
        board[r][c] = cell.b;
        if (!jusoHP[r]) jusoHP[r] = [];
        if (!jusoShake[r]) jusoShake[r] = [];
        jusoHP[r][c] = cell.hp;
        jusoShake[r][c] = cell.shake;
      }
    }
    // JUSOä»¥å¤–ã®ãƒã‚¹ã«ã¯HPã‚’æ®‹ã•ãšã€JUSOã«ã¯æœ€ä½HPã‚’å†è¨­å®š
    try{
      if (jusoHP && JUSOS){
        for(let r=0;r<size;r++){
          if (!jusoHP[r]) jusoHP[r] = [];
          for(let c=0;c<size;c++){
            const b = board[r][c];
            if (!JUSOS.includes(b)){
              // éå‘ªè©›ãƒã‚¹ã«ã¯HPã‚’æ®‹ã•ãªã„
              jusoHP[r][c] = 0;
            } else {
              // å‘ªè©›ãƒã‚¹ãªã®ã«HPãŒæ¬ è½ã—ã¦ã„ãŸå ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’å¾©å…ƒ
              if (!jusoHP[r][c] || jusoHP[r][c] <= 0){
                jusoHP[r][c] = (b==="J_NEM"?1:(b==="J_SHI"?3:5));
              }
            }
          }
        }
      }
    }catch(_){}
    tries++;
  }while((findMatches(true)||!hasPossibleMoves()) && tries<maxTries);
  updateStatus("status: ç›¤é¢ã‚’ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã—ã¾ã—ãŸã€‚");
  if (typeof setComboText === 'function'){
    try { setComboText("ç›¤é¢ã‚’ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã—ã¾ã—ãŸã€‚"); } catch(_){}
  }
  animState="drop"; prepareDrop();
}

/* èµ·å‹• (çœç•¥: å¤‰æ›´ãªã—) */
function initGame(reset=false){ /* (çœç•¥: å¤‰æ›´ãªã—) */
const parentW = 480;
  logicalSize = Math.floor(480/size)*size;
  tileSize = logicalSize/size;
  DPR=(window.matchMedia&&window.matchMedia('(max-width: 900px)').matches)?Math.min(((typeof IS_IOS!=="undefined"&&IS_IOS)?1.5:2),(window.devicePixelRatio||1)):Math.max(2,Math.min(3,(window.devicePixelRatio||1)));
  canvas.width=logicalSize*DPR; canvas.height=logicalSize*DPR; ctx.setTransform(1,0,0,1,0,0); ctx.scale(DPR,DPR);
  canvas.style.width = logicalSize + 'px'; canvas.style.height = 'auto';
  if(reset) initBoard();
  updateScoresUI(); setMode('kanki');
  if(!reset) gameLoop();
}
function startUp(){ loadImages(()=>{ initGame(true); updateStatus("status: game loaded. ready to play."); gameLoop(); }); }

/* ã‚¤ãƒ™ãƒ³ãƒˆ (èª¿æ•´) */
canvas.addEventListener('mousedown',e=>onStart(e.clientX,e.clientY));
canvas.addEventListener('mousemove',e=>onMove(e.clientX,e.clientY));
canvas.addEventListener('mouseup',onEnd);
canvas.addEventListener('mouseleave',onEnd);
canvas.addEventListener('touchstart',e=>{ e.preventDefault(); onStart(e.touches[0].clientX,e.touches[0].clientY); });
canvas.addEventListener('touchmove',e=>{ e.preventDefault(); onMove(e.touches[0].clientX,e.touches[0].clientY); });
canvas.addEventListener('touchend',onEnd);

/* â˜…ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹å†…ã®ãƒœã‚¿ãƒ³ã«è¨­å®š */
$indexBtn.addEventListener('click', openIndexModal);

/* èƒŒæ™¯ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹å‡¦ç† */
$howtoModal?.addEventListener('click', (event) => {
  if (event.target === $howtoModal) {
    window.closeHowto();
  }
});
$charModal?.addEventListener('click', (event) => {
  if (event.target === $charModal) {
    closeCharModal();
  }
});
$indexModal?.addEventListener('click', (event) => {
  if (event.target === $indexModal) {
    closeIndexModal();
  }
});


window.addEventListener('beforeunload', ()=>{ /* (çœç•¥: å¤‰æ›´ãªã—) */
  store.set("score",score); store.set("rankIndex",rankIndex); store.set("rankProgress",rankProgress);
  // â˜…ãƒ©ãƒ³ã‚¯MAXåˆ°é”ãƒ•ãƒ©ã‚°ã‚’ä¿å­˜
  store.set("hasReachedMaxRank", hasReachedMaxRank);
});

startUp();

/* === ALL MAX UNLOCK (click title when MAX reached) === */
const ALLMAX_PASSCODE = "chiecho"; // changeable later
const ALLMAX_UNLOCK_KEY = "allmaxUnlocked";

(function(){
  function qs(id){ return document.getElementById(id); }

  function openAllMax(){
    const overlay = qs("allmaxOverlay");
    const input   = qs("allmaxInput");
    const error   = qs("allmaxError");
    const img     = qs("allmaxImage");
    const area    = qs("allmaxInputArea");
    if (!overlay || !input || !error || !img || !area) return;

    overlay.style.display = "flex";
    overlay.setAttribute("aria-hidden","false");
    error.style.display = "none";
    area.style.display = "flex";
    img.style.display = "none";
    // éš ã—ç”»åƒï¼šé–‹ããŸã³ã« src ã‚’æ¶ˆã—ã¦ãŠãï¼ˆãƒ‘ã‚¹é€šéã¾ã§ãƒ­ãƒ¼ãƒ‰ã—ãªã„ï¼‰
    img.removeAttribute("src");
    input.value = "";
    // æ°¸ç¶šã‚¢ãƒ³ãƒ­ãƒƒã‚¯æ¸ˆã¿ãªã‚‰å…¥åŠ›ä¸è¦ã§ç”»åƒã‚’è¡¨ç¤º
    try{
      if (localStorage.getItem(ALLMAX_UNLOCK_KEY) === "1"){
        // æ­£è§£æ™‚ã¨åŒã˜çŠ¶æ…‹ã‚’ä½œã‚‹ï¼ˆsrcã¯å¿…è¦ãªã‚‰ã‚»ãƒƒãƒˆï¼‰
        error.style.display = "none";
        area.style.display = "none";
        if (!img.getAttribute("src")){
          img.onerror = ()=>{ img.onerror = null; img.src = "allmax.png"; };
          img.src = "images/allmax.png";
        }
        try{ overlay.classList.add("allmax-unlocked"); }catch(_){ }
      }
    }catch(_){ }

    input.focus();
  }

  function closeAllMax(){
    const overlay = qs("allmaxOverlay");
    if (!overlay) return;

    // reset UI state
    try{ overlay.classList.remove("allmax-unlocked"); }catch(_){}
    const img   = qs("allmaxImage");
    const area  = qs("allmaxInputArea");
    const input = qs("allmaxInput");
    const error = qs("allmaxError");

    if (img){
      img.style.display = "none";
      img.removeAttribute("src");
    }
    if (area) area.style.display = "flex";
    if (input) input.value = "";
    if (error) error.style.display = "none";

    overlay.style.display = "none";
    overlay.setAttribute("aria-hidden","true");
  }

  function armAllMaxUI(){
    const title = qs("titleLabel");
    if (!title) return;

    // hasReachedMaxRank ã¯æ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯ã®æ°¸ç¶šãƒ•ãƒ©ã‚°
    if (typeof hasReachedMaxRank !== "undefined" && hasReachedMaxRank){
      title.classList.add("allmax-ready");
      title.onclick = openAllMax;
    } else {
      title.classList.remove("allmax-ready");
      title.onclick = null;
    }
  }

  document.addEventListener("DOMContentLoaded", ()=>{
    const input = qs("allmaxInput");
    const error = qs("allmaxError");
    const img   = qs("allmaxImage");
    const area  = qs("allmaxInputArea");
    const close = qs("allmaxClose");
    const overlay = qs("allmaxOverlay");

    if (close) close.addEventListener("click", closeAllMax);
    if (overlay) overlay.addEventListener("click", (e)=>{ if (e.target === overlay) closeAllMax(); });

    if (input){
      const okBtn = qs("allmaxOkBtn");
      const submitAllMaxCode = ()=>{
        if (!area || !img || !error) return;
        const v = (input.value || "").trim();

        if (v === ALLMAX_PASSCODE){
          // æ­£è§£ï¼šã“ã®æ™‚ç‚¹ã§åˆã‚ã¦ç”»åƒã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¦è¡¨ç¤º
          error.style.display = "none";
          area.style.display = "none";

          // src æœªè¨­å®šãªã‚‰è¨­å®šï¼ˆimages/ ã‚’å„ªå…ˆã—ã€å¤±æ•—æ™‚ã¯åŒéšå±¤ã¸ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
          if (!img.getAttribute("src")){
            img.onerror = ()=>{ img.onerror = null; img.src = "allmax.png"; };
            img.src = "images/allmax.png";
          }
          try{ overlay && overlay.classList.add("allmax-unlocked"); }catch(_){ }
          try{ localStorage.setItem(ALLMAX_UNLOCK_KEY, "1"); }catch(_){ }
          // è¡¨ç¤ºã¯CSSåˆ¶å¾¡
          
        } else {
          // ä¸æ­£è§£ï¼šç”»åƒã¯çµ¶å¯¾ã«å‡ºã•ãªã„
          try{ overlay && overlay.classList.remove("allmax-unlocked"); }catch(_){ }
          img.style.display = "none";
          img.removeAttribute("src");
          error.style.display = "block";
        }
      };

      input.addEventListener("keydown", (e)=>{
        if (e.key === "Enter") submitAllMaxCode();
      });
      if (okBtn) okBtn.addEventListener("click", submitAllMaxCode);
    }armAllMaxUI();

    // updateScoresUI ãŒå‘¼ã°ã‚Œã‚‹ãŸã³ã« MAX çŠ¶æ…‹ãŒåæ˜ ã•ã‚Œã‚‹ã‚ˆã†ã€ãƒ©ãƒƒãƒ—ã™ã‚‹
    if (typeof window.updateScoresUI === "function" && !window.__allmax_wrapped){
      const _orig = window.updateScoresUI;
      window.updateScoresUI = function(){
        const r = _orig.apply(this, arguments);
        try{ armAllMaxUI(); }catch(_){}
        return r;
      };
      window.__allmax_wrapped = true;
    }
  });

  // maybeReachMax å†…ã§ hasReachedMaxRank ãŒ true ã«ãªã£ãŸç›´å¾Œã‚‚åæ˜ ã•ã›ãŸã„ã®ã§ã€playFinalRankMAXCeremony ãŒã‚ã‚‹å ´åˆã¯ãã‚Œã‚‚ãƒ©ãƒƒãƒ—
  try{
    if (typeof window.playFinalRankMAXCeremony === "function" && !window.__allmax_ceremony_wrapped){
      const _c = window.playFinalRankMAXCeremony;
      window.playFinalRankMAXCeremony = function(){
        const r = _c.apply(this, arguments);
        try{ setTimeout(()=>{ try{ armAllMaxUI(); }catch(_){} }, 0); }catch(_){}
        return r;
      };
      window.__allmax_ceremony_wrapped = true;
    }
  }catch(_){}
})();

</script>
<!-- >>> CHAR MODAL Z-INDEX & DOM FIX PATCH (added by ChatGPT) >>> -->
<style>
/* Ensure modal overlays are fixed to viewport and stack correctly */
.modal-overlay { position: fixed; inset: 0; display: none; justify-content: center; align-items: center; z-index: 10000; }
#indexModal { z-index: 10010; }
#charModal, #howtoModal { z-index: 10012; } /* character/howto always above index */

/* hide debug status */
#status{ display:none !important; }
</style>
<script>
document.addEventListener('DOMContentLoaded', function () {
  try {
    var cm = document.getElementById('charModal');
    if (cm && cm.parentElement !== document.body) {
      document.body.appendChild(cm);
    }
    var hm = document.getElementById('howtoModal');
    if (hm && hm.parentElement !== document.body) {
      document.body.appendChild(hm);
    }
  } catch (e) { console && console.warn('Modal relocation patch error:', e); }
});
</script>
<script>
window.addEventListener("DOMContentLoaded", () => {
  const howtoBtn = document.getElementById("openHowtoBtn");
  if (howtoBtn) {
    howtoBtn.addEventListener("click", () => {
      openHowto();
    });
  }
});

</script>
<script>
/* ============================================================
   æ“ä½œèª¬æ˜ãƒ¢ãƒ¼ãƒ€ãƒ«ï¼ˆHowtoï¼‰â€” å®‰å…¨ãƒ»åŒ…æ‹¬ç‰ˆ
   - openHowto()/closeHowto() ã‚’æä¾›ï¼ˆæœªå®šç¾©ã§ã‚‚å‹•ãï¼‰
   - ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¨ã®é€£æºï¼ˆãƒãƒ¼ã‚ºçŠ¶æ…‹ã®ä¿å­˜/å¾©å¸°ï¼‰ã‚’è€ƒæ…®
   - å¤–å´ã‚¯ãƒªãƒƒã‚¯/Escã§ã‚¯ãƒ­ãƒ¼ã‚º
   - ç”»åƒé…åˆ—ãŒç©ºã§ã‚‚è½ã¡ãªã„ãƒ•ã‚§ã‚¤ãƒ«ã‚»ãƒ¼ãƒ•
   ============================================================ */
(function(){
  // æ—¢ã«å®šç¾©æ¸ˆã¿ãªã‚‰ä¸Šæ›¸ãã—ãªã„ï¼ˆä¸è¦ãªã‚‰ã“ã® if ã‚’æ¶ˆã—ã¦ã‚‚OKï¼‰
  if (typeof window.openHowto === 'function' && typeof window.closeHowto === 'function') return;

  // æ—¢å­˜ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«æƒ³å®šï¼ˆãƒ•ã‚¡ã‚¤ãƒ«å†…ã«å®šç¾©æ¸ˆã¿ï¼‰
  // paused, togglePause, isIndexOpen, wasPausedBeforeChildModal
  // HOWTO_IMAGES, HOWTO_CAPTIONS, showHowtoPage, howtoIdx
  // DOM
  const $indexModal = document.getElementById('indexModal');
  const $howtoModal = document.getElementById('howtoModal');
  const $howtoImg = document.getElementById('howtoImg');
  const $howtoCounter = document.getElementById('howtoCounter');
  const $howtoPrev = document.getElementById('howtoPrev');
  const $howtoNext = document.getElementById('howtoNext');
  const $openHowtoBtn = document.getElementById('openHowtoBtn');

  // å­˜åœ¨ã—ãªã„å ´åˆã§ã‚‚è½ã¡ãªã„ã‚ˆã†ã«
  window.HOWTO_IMAGES = Array.isArray(window.HOWTO_IMAGES) ? window.HOWTO_IMAGES : [];
  window.HOWTO_CAPTIONS = Array.isArray(window.HOWTO_CAPTIONS) ? window.HOWTO_CAPTIONS : [];
  window.howtoIdx = typeof window.howtoIdx === 'number' ? window.howtoIdx : 0;

  // ç”»åƒãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ï¼ˆæ—¢å­˜ã® showHowtoPage ãŒã‚ã‚Œã°ãã‚Œã‚’ä½¿ã†ï¼‰
  function render(i){
    if (typeof window.showHowtoPage === 'function') {
      window.showHowtoPage(i);
      return;
    }
    // æœ€ä½é™ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ï¼ˆshowHowtoPage ãŒç„¡ã„å ´åˆç”¨ï¼‰
    const imgs = window.HOWTO_IMAGES, caps = window.HOWTO_CAPTIONS;
    const len = imgs.length;
    if (!$howtoImg || !$howtoCounter || !len) {
      if ($howtoImg) { $howtoImg.removeAttribute('src'); $howtoImg.alt = 'æ“ä½œèª¬æ˜ã®ç”»åƒãŒã‚ã‚Šã¾ã›ã‚“ã€‚'; }
      if ($howtoCounter) $howtoCounter.textContent = '0 / 0';
      if ($howtoPrev) $howtoPrev.style.display = 'none';
      if ($howtoNext) $howtoNext.style.display = 'none';
      return;
    }
    window.howtoIdx = (i + len) % len;
    if ($howtoImg) {
      $howtoImg.src = imgs[window.howtoIdx];
      $howtoImg.alt = (caps[window.howtoIdx] || 'æ“ä½œèª¬æ˜');
    }
    if ($howtoCounter) $howtoCounter.textContent = (window.howtoIdx + 1) + ' / ' + len;
    if ($howtoPrev) $howtoPrev.style.display = '';
    if ($howtoNext) $howtoNext.style.display = '';
  }

  // é–‹ã
  window.openHowto = function openHowto(){
    try {
      // å­ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ãå‰ã®ãƒãƒ¼ã‚ºçŠ¶æ…‹ã‚’ä¿å­˜ã—ã€å¿…ãšãƒãƒ¼ã‚ºã¸
      window.wasPausedBeforeChildModal = typeof window.wasPausedBeforeChildModal === 'boolean'
        ? window.wasPausedBeforeChildModal
        : false;
      window.wasPausedBeforeChildModal = !!window.paused;
      if (!window.paused && typeof window.togglePause === 'function') window.togglePause();

      // åˆæœŸãƒšãƒ¼ã‚¸ã«ã—ã¦è¡¨ç¤º
      window.howtoIdx = 0;
      render(window.howtoIdx);

      if ($howtoModal) {
        $howtoModal.hidden = false;
        $howtoModal.classList.add('open');
      }
      if ($indexModal) $indexModal.style.filter = ((typeof IS_IOS!=="undefined"&&IS_IOS)?"none":"blur(4px)");
    } catch(e){ console.error('[openHowto] ', e); }
  };

  // é–‰ã˜ã‚‹
  window.closeHowto = function closeHowto(){
    // â˜…SE: pushï¼ˆHowtoé–‰ã˜ã‚‹ï¼‰
  try{ onClickSE && onClickSE(); }catch(e){};
  try{ onClickSE && onClickSE(); }catch(e){}; try {
      if ($howtoModal) {
        $howtoModal.classList.remove('open');
        $howtoModal.hidden = true;
      }
      if ($indexModal) $indexModal.style.filter = 'none';

      // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒé–‰ã˜ã¦ã„ã‚‹ãªã‚‰ã€å…ƒã®ãƒãƒ¼ã‚ºçŠ¶æ…‹ã«å¾©å¸°
      if (!window.isIndexOpen && typeof window.togglePause === 'function') {
        if (window.paused && !window.wasPausedBeforeChildModal) {
          window.togglePause(); // å†é–‹
        }
      }
    } catch(e){ console.error('[closeHowto] ', e); }
  };

  // å‰/æ¬¡ï¼ˆæ—¢ã«å®šç¾©æ¸ˆã¿ãªã‚‰ä¸Šæ›¸ãã—ãªã„ï¼‰
  if (typeof window.prevHowtoPage !== 'function') {
    window.prevHowtoPage = function prevHowtoPage(){
      if (!Array.isArray(window.HOWTO_IMAGES) || window.HOWTO_IMAGES.length === 0) return;
      window.howtoIdx = (window.howtoIdx - 1 + window.HOWTO_IMAGES.length) % window.HOWTO_IMAGES.length;
      render(window.howtoIdx);
    };
  }
  if (typeof window.nextHowtoPage !== 'function') {
    window.nextHowtoPage = function nextHowtoPage(){
      if (!Array.isArray(window.HOWTO_IMAGES) || window.HOWTO_IMAGES.length === 0) return;
      window.howtoIdx = (window.howtoIdx + 1) % window.HOWTO_IMAGES.length;
      render(window.howtoIdx);
    };
  }

  // ã‚¯ãƒªãƒƒã‚¯ãƒ»ã‚­ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ï¼ˆå†ªç­‰ï¼‰
  if ($howtoModal) {
    $howtoModal.addEventListener('click', function(e){
      // ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤é ˜åŸŸã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹
      if (e.target === $howtoModal) window.closeHowto();
    });
  }
  document.addEventListener('keydown', function(e){
    if (e.key === 'Escape' && $howtoModal && !$howtoModal.hidden) {
      window.closeHowto();
    }
  });

  // å¿µã®ãŸã‚ãƒœã‚¿ãƒ³ã«ã‚‚ãƒã‚¤ãƒ³ãƒ‰ï¼ˆHTMLå´ã« onclick ãŒã‚ã£ã¦ã‚‚é‡è¤‡å®Ÿè¡Œã—ãªã„ï¼‰
  if ($openHowtoBtn) {
    $openHowtoBtn.addEventListener('click', function(ev){
      // HTMLã® onclick="openHowto()" ã¨äºŒé‡å‘¼ã³å‡ºã—ã«ãªã£ã¦ã‚‚å•é¡Œãªã„ã‚ˆã†ã«
      // åŒä¸€ãƒ•ãƒ¬ãƒ¼ãƒ å†…ã§äºŒåº¦ç›®ä»¥é™ã¯ç„¡è¦–ï¼ˆæ—¢ã«é–‹ã„ã¦ã„ã‚Œã° returnï¼‰
      if ($howtoModal && !$howtoModal.hidden) return;
      window.openHowto();
    });
  }
})();
</script>

</script>

<!-- removed broken howto push SE binder -->

<script>
(function(){
  function ensureAudio(id, src){
    var el = document.getElementById(id);
    if (!el) {
      el = document.createElement('audio');
      el.id = id;
      el.src = src;
      el.preload = 'auto';
      el.style.display = 'none';
      document.body.appendChild(el);
    }
    return el;
  }
  function seAllowed(){
    if (typeof window.isSEEnabled === 'boolean' && !window.isSEEnabled) return false;
    if (typeof window.seEnabled === 'boolean' && !window.seEnabled) return false;
    if (typeof window.SE_ENABLED === 'boolean' && !window.SE_ENABLED) return false;
    return true;
  }
  window.playSEPush = function(){
    try {
      if (!seAllowed()) return;
      var el = ensureAudio('sePush','audio/se_push.mp3');
      el.currentTime = 0;
      try{ if(window.__getSeEffectiveVol) el.volume = window.__getSeEffectiveVol(); }catch(e){}
      try{ if(window.__playMediaSafe){ window.__playMediaSafe(el); } else { el.play().catch(function(){}); } }catch(e){}
      /* ignore autoplay restrictions */
    } catch(e){}
  };
  window.playSEIndex = function(){
    try {
      if (!seAllowed()) return;
      var el = ensureAudio('seIndex','audio/se_index.mp3');
      el.currentTime = 0;
      try{ if(window.__getSeEffectiveVol) el.volume = window.__getSeEffectiveVol(); }catch(e){}
      try{ if(window.__playMediaSafe){ window.__playMediaSafe(el); } else { el.play().catch(function(){}); } }catch(e){}
      /* ignore autoplay restrictions */
    } catch(e){}
  };

  function bind(){
    try {
      // Howto close buttons -> se_push.mp3
      var howto = document.getElementById('howtoModal');
      if (howto) {
        var closeTargets = howto.querySelectorAll('.close-btn, [data-close], #howtoClose, button[aria-label="Close"], .modal-close');
        closeTargets.forEach(function(btn){
          if (btn && btn.dataset && btn.dataset.seBoundClose !== '1') {
            btn.addEventListener('click', function(){ window.playSEPush && window.playSEPush(); });
            btn.dataset.seBoundClose = '1';
          }
        });
      }

      // Index open button -> se_index.mp3
      var indexBtn = document.getElementById('indexBtn');
      if (indexBtn && indexBtn.dataset.seBoundOpen !== '1') {
        indexBtn.addEventListener('click', function(){ window.playSEIndex && window.playSEIndex(); });
        indexBtn.dataset.seBoundOpen = '1';
      }

      // Index modal close buttons & overlay close -> se_index.mp3
      var indexModal = document.getElementById('indexModal');
      if (indexModal) {
        var idxCloseTargets = indexModal.querySelectorAll('.close-btn, [data-close], #indexClose, button[aria-label="Close"], .modal-close');
        idxCloseTargets.forEach(function(btn){
          if (btn && btn.dataset && btn.dataset.seBoundIdxClose !== '1') {
            btn.addEventListener('click', function(){ window.playSEIndex && window.playSEIndex(); });
            btn.dataset.seBoundIdxClose = '1';
          }
        });
        // Overlay click to close (if implemented) also plays
        if (indexModal.dataset.seBoundOverlay !== '1') {
          indexModal.addEventListener('click', function(e){
            try {
              var panel = indexModal.querySelector('.index-panel');
              if (!panel || !panel.contains(e.target)) {
                window.playSEIndex && window.playSEIndex();
              }
            } catch(_){}
          });
          indexModal.dataset.seBoundOverlay = '1';
        }
      }
    } catch(e){}
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', bind);
  } else {
    bind();
  }
})();
</script>
<script>
(function(){
  function bindCapture(){
    try{
      var btn = document.getElementById('howtoCloseBtn');
      if (btn && btn.dataset.seCap !== '1') {
        btn.addEventListener('click', function(){ window.playSEPush && window.playSEPush(); }, true); // capture
        btn.dataset.seCap = '1';
      }
      var cmBtn = document.querySelector('#charModal .close-btn');
      if (cmBtn && cmBtn.dataset.seCap !== '1') {
        cmBtn.addEventListener('click', function(){ window.playSEPush && window.playSEPush(); }, true);
        cmBtn.dataset.seCap = '1';
      }
    }catch(e){}
  }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', bindCapture);
  else bindCapture();
})();
</script>
<script>
/* === JUSO ã‚·ã‚§ã‚¤ã‚¯åˆ¶å¾¡ === */
function triggerJusoShake(r,c, power=1){
  if(r<0||c<0||r>=size||c>=size) return;
  if(!jusoShake || !jusoShake[r]) return;
  // æ—¢å­˜ã‚ˆã‚Šå¼·ã„ã‚·ã‚§ã‚¤ã‚¯ãŒæ¥ãŸã‚‰ä¸Šæ›¸ãï¼ˆæœ€å¤§1.2ã¾ã§ï¼‰
  jusoShake[r][c] = Math.min(Math.max(jusoShake[r][c], power), 1.2);
}
</script>

<script>
/* ===== Enhancements bundle ===== */
(function(){
  'use strict';

  // ---------- ParticleFX (single canvas, pooled) ----------
  if(!window.ParticleFX){
    var DPR=(window.matchMedia&&window.matchMedia('(max-width: 900px)').matches)?Math.min(((typeof IS_IOS!=="undefined"&&IS_IOS)?1.5:2),(window.devicePixelRatio||1)):Math.max(2,Math.min(3,(window.devicePixelRatio||1)));
var REDUCED=false; try{ REDUCED = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches; }catch(_){}
    var cvs=document.createElement('canvas');
    cvs.id = 'infernoCanvas'; Object.assign(cvs.style,{position:'fixed',inset:'0',pointerEvents:'none',zIndex:1,background:'transparent',display:'none'});
    document.body.appendChild(cvs);
    var ctx=cvs.getContext('2d',{alpha:true});
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    function resize(){ var w=Math.floor(innerWidth*DPR), h=Math.floor(innerHeight*DPR);
      if(cvs.width!==w||cvs.height!==h){ cvs.width=w; cvs.height=h; cvs.style.width=innerWidth+'px'; cvs.style.height=innerHeight+'px'; ctx.setTransform(DPR,0,0,DPR,0,0); } }
    resize(); addEventListener('resize', resize);
    var MAX=120, POOL=new Array(MAX), ACTIVE=[]; for(var i=0;i<MAX;i++) POOL[i]={alive:false};
    function take(){ for(var i=0;i<MAX;i++){ if(!POOL[i].alive) return POOL[i]; } return null; }
    var raf=0, prev=0;
    function loop(ts){ var dt=ts-prev; if(dt>48) dt=48; prev=ts;
      ctx.clearRect(0,0,cvs.width,cvs.height);
      for(var i=ACTIVE.length-1;i>=0;i--){ var p=ACTIVE[i], t=(ts-p.t0)/p.life;
        if(t>=1){ p.alive=false; ACTIVE.splice(i,1); continue; }
        p.vx*=p.drag; p.vy=p.vy*p.drag+p.g; p.x+=p.vx*(dt/16.67); p.y+=p.vy*(dt/16.67);
        ctx.globalCompositeOperation=p.blend; ctx.globalAlpha=(1-t)*p.alpha;
        ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fillStyle=p.color; ctx.fill(); }
      ctx.globalAlpha=1; ctx.globalCompositeOperation='source-over';
      if(!ACTIVE.length){ cancelAnimationFrame(raf); raf=0; cvs.style.display='none'; return; }
      raf=requestAnimationFrame(loop); }
    function burst(mode,x,y){ try{
      var base=REDUCED?8:16, N0= (mode === 'scorched') ? base + 6 : base,
    N= Math.max(1, Math.round(N0 * 1.5));
      for(var i=0;i<N;i++){ var p=take(); if(!p) break;
        var ang=(Math.random()*Math.PI*2);
        var __bias=Math.random();
        var spdBase=(mode==='scorched'?2.4:1.6);
        var spd = (__bias<0.7 ? spdBase*(0.6+Math.random()*0.8) : spdBase*(1.3+Math.random()*1.1));
        var rBase=(mode==='scorched'?2.6:1.4), r=rBase+Math.random()*(mode==='scorched'?1.4:0.8);
        var color,blend,alpha; if(mode==='joy'){ color='rgba(255,245,150,1)'; blend='lighter'; alpha=0.95; }
        else{ var rC=160+Math.floor(Math.random()*80), gC=Math.floor(Math.random()*24), bC=gC; color='rgba('+rC+','+gC+','+bC+',1)'; blend='source-over'; alpha=0.9; }
        var life=(200+Math.random()*160)*2.2, drag=(mode==='joy')?0.92:0.88, g=(mode==='joy')?0.01:0.03;
        p.alive=true; p.x=x; p.y=y; p.vx=Math.cos(ang)*spd; p.vy=Math.sin(ang)*spd; p.r=r; p.t0=performance.now(); p.life=life; p.drag=drag; p.g=g; p.color=color; p.blend=blend; p.alpha=alpha;
        ACTIVE.push(p); }
      if(ACTIVE.length&&!raf){ prev=performance.now(); cvs.style.display='block'; raf=requestAnimationFrame(loop); } }catch(_){} }
    window.ParticleFX={ burstJoy:function(x,y){ burst('joy',x,y); }, burstScorched:function(x,y){ burst('scorched',x,y); } };
  }

  
    
// ---------- Audio unlock on first interaction (iOS-hardened) ----------
(function(){
  var unlocked = false;
  var ctx = null;

  // WebAudio ãƒã‚¹ï¼ˆiOSã§HTMLAudio.volumeãŒåŠ¹ã‹ãªã„ï¼åŠ¹ãã«ãã„ç«¯æœ«å¯¾ç­–ï¼‰
  var masterGain = null, bgmGain = null, seGain = null;
  var srcMap = new WeakMap();

  function ensureGraph(){
    try{
      if (!IS_IOS) return null;
      const AC = window.AudioContext || window.webkitAudioContext;
      // canvasã®2Dã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ(ctx)ã¨è¡çªã—ãªã„ã‚ˆã†AudioContextã¯ audioCtx ã§ç®¡ç†
      let audioCtx = window.__sharedAudioCtx || null;
      if (!audioCtx && AC){
        audioCtx = new AC();
        window.__sharedAudioCtx = audioCtx;
      }
      if (!audioCtx) return null;
      if (audioCtx.state === 'suspended'){ try{ audioCtx.resume(); }catch(_){ } }

      if (masterGain) return window.__audioGraph;

      masterGain = audioCtx.createGain();
      bgmGain = audioCtx.createGain();
      seGain  = audioCtx.createGain();
      bgmGain.connect(masterGain);
      seGain.connect(masterGain);
      masterGain.connect(audioCtx.destination);

      // åˆæœŸå€¤ï¼ˆä¿å­˜å€¤ï¼‰ã‚’åæ˜ 
      try{
        bgmGain.gain.value = store.get('bgmVol', BGM_DEFAULT_VOL);
        seGain.gain.value  = store.get('seVol',  SE_DEFAULT_VOL);
      }catch(_){}

      window.__audioGraph = {ctx: audioCtx, master: masterGain, bgm: bgmGain, se: seGain, sources: new Map()};
      // æ—¢å­˜audioè¦ç´ ã‚’æ¥ç¶šï¼ˆiOSã§volumeãŒåŠ¹ã‹ãªã„ã‚±ãƒ¼ã‚¹ç”¨ï¼‰
      try{ connectKnownAudio(); }catch(_){}
      return window.__audioGraph;
    }catch(_){
      return null;
    }
  }

  function unlock(){
    if (unlocked) return;
    unlocked = true;
    resumeCtx();
    connectKnownAudio();
    try{ if (typeof unlockAllSE === 'function') unlockAllSE(); }catch(_){}
    primeBGM();
    try{ __applySeVolume && __applySeVolume(); }catch(_){ }
    try{ __applyBgmVolume && __applyBgmVolume(); }catch(_){ }
    detach();
  }

  function detach(){
    window.removeEventListener('pointerdown', unlock, true);
    window.removeEventListener('touchstart', unlock, true);
    window.removeEventListener('touchend', unlock, true);
    window.removeEventListener('keydown', unlock, true);
  }

  window.addEventListener('pointerdown', unlock, true);
  window.addEventListener('touchstart', unlock, true);
  window.addEventListener('touchend', unlock, true);
  window.addEventListener('keydown', unlock, true);

  window.addEventListener('pageshow', function(){
    resumeCtx();
    if (typeof ensureBGMAlive === 'function') ensureBGMAlive();
  });

  document.addEventListener('visibilitychange', function(){
    if (!document.hidden){
      resumeCtx();
      if (typeof ensureBGMAlive === 'function') ensureBGMAlive();
    }
  });

  window.ensureBGMAlive = window.ensureBGMAlive || function(){
    try{
      if (typeof currentBGM !== 'function') return;
      var el = currentBGM();
      if (!el) return;
      if (el.paused){
        var p = el.play();
        if (p && p.catch) p.catch(function(){});
      }
    }catch(_){}
  };

  if (isIOS && !window.__patchedPlay){
    window.__patchedPlay = true;
    var _origPlay = HTMLMediaElement.prototype.play;
    HTMLMediaElement.prototype.play = function(){
      var ret;
      try{ ret = _origPlay.call(this); }catch(e){ ret = Promise.reject(e); }
      if (ret && ret.catch){
        ret.catch(function(){
          var self = this;
          var once = function(){
            try{ _origPlay.call(self); }catch(_){}
            cleanup();
          };
          function cleanup(){
            window.removeEventListener('pointerdown', once, true);
            window.removeEventListener('touchend', once, true);
            window.removeEventListener('keydown', once, true);
          }
          window.addEventListener('pointerdown', once, true);
          window.addEventListener('touchend', once, true);
          window.addEventListener('keydown', once, true);
        }.bind(this));
      }
      return ret;
    };
  }
})();
// ---------- Helper: grid cell center -> screen ----------
  if(!window.gridCellCenterToScreen){
    window.gridCellCenterToScreen=function(r,c){ try{ var canvas=document.getElementById('gameCanvas'); var rect=canvas.getBoundingClientRect(); var size=7, logical=400; var tile=logical/size; var scale=rect.width/logical; return {x:rect.left+(c+0.5)*tile*scale, y:rect.top+(r+0.5)*tile*scale}; }catch(_){ return {x:0,y:0}; } };
  }

  // ---------- Hook set() to emit particles when JUSO becomes null ----------
  (function hookSet(retry){
    retry=retry||0;
    if(typeof window.set==='function' && typeof window.get==='function'){
      if(window.__setHooked) return; window.__setHooked=true;
      var _set=window.set, _get=window.get;
      var J = (Array.isArray(window.JUSOS) ? window.JUSOS.slice() : ["J_NEM","J_SHI","J_PRO"]);
      window.set=function(r,c,v){
        try{
          var prev=_get(r,c);
          _set(r,c,v);
if(prev && v===null && J.indexOf(prev)>=0 && window.ParticleFX){
 // â˜…ã€Œæ¶ˆå»ã«ã‚ˆã‚‹nullåŒ–ã€ã ã‘ã‚’è¨±å¯
var key = r + ',' + c;
 var ok  = !!(window.__jusoEraseSet && window.__jusoEraseSet.has(key));
if (ok){
 // ä¸€åº¦ä½¿ã£ãŸè¨±å¯ã¯æ¶ˆã™ï¼ˆå¤šé‡ç™ºç«é˜²æ­¢ï¼‰
 window.__jusoEraseSet.delete(key);
 var pos = gridCellCenterToScreen(r,c);
 var __joy = (typeof isKanki !== 'undefined' ? !!isKanki : !!window.isKanki)
                 || !!window.isJubilee
                 || (''+(window.currentMode||'')).toLowerCase().includes('jubilee')
                 || (''+(window.currentMode||'')).toLowerCase().includes('kanki');
     if (__joy) ParticleFX.burstJoy(pos.x, pos.y);
     else       ParticleFX.burstScorched(pos.x, pos.y);
   }
 }


        }catch(e){ try{ _set(r,c,v);}catch(_){ } }
      };
      return;
    }
    if(retry<20) setTimeout(function(){ hookSet(retry+1); }, 80);
  })();

  // ---------- Unknown gating (é—˜å€¤) ----------
  if (typeof window.UNKNOWN_THRESH === 'undefined') { window.UNKNOWN_THRESH = 5; }
  if (typeof window.unknownStageProgress === 'undefined') {
    window.unknownStageProgress = (typeof store !== 'undefined' && store) ? store.get('unknownStageProgress', 0) : 0;
  }
  function maybeReachMax(){
    if (typeof rankIndex !== 'undefined' && typeof MAX_RANK_INDEX !== 'undefined' &&
        rankIndex === MAX_RANK_INDEX && !hasReachedMaxRank) {
      if (unknownStageProgress >= UNKNOWN_THRESH) {
        hasReachedMaxRank = true;
        try{ store && store.set('hasReachedMaxRank', true); }catch(_){}
        try{
          if (window.playVoiceById) window.playVoiceById('vo_rank5');
          else {
            var v5 = document.getElementById('vo_rank5');
            if (v5) { try{ v5.currentTime = 0; }catch(_){ } var pr = v5.play(); if (pr && pr.catch) pr.catch(()=>{}); }
          }
        }catch(_){}
        try{ if (typeof window.playFinalRankMAXCeremony==='function') window.playFinalRankMAXCeremony(); }catch(_){}
        try{ if (typeof playFinalRankMAXCeremony==='function') playFinalRankMAXCeremony(); }catch(_){}
        try{ var row=document.getElementById('rankSelectRow'); if(row){ row.style.display=''; } }catch(_){}
        try{ if(typeof updateScoresUI==='function') updateScoresUI(); }catch(_){}
      }
    }
  }

  // Patch updateScoresUI to show (x/é—˜å€¤) at MAX until reached
  try{
    var usrc = (window.updateScoresUI||function(){}).toString();
    if(usrc.indexOf('unknownStageProgress')===-1){
      window.__updateScoresUI_orig = window.updateScoresUI;
      window.updateScoresUI = function(){
        try{
          __updateScoresUI_orig();
        }catch(e){}
        try{
          var span = document.getElementById('rankProgress'); 
          if(span && typeof rankIndex!=='undefined' && typeof MAX_RANK_INDEX!=='undefined'){
            if (rankIndex===MAX_RANK_INDEX){
              if (hasReachedMaxRank){ span.textContent = 'MAX'; }
              else { span.textContent = '('+unknownStageProgress+'/'+UNKNOWN_THRESH+')'; }
            }
          }
        }catch(_){}
        try{
          // ãƒ©ãƒ³ã‚¯MAXè¡Œã®ã‚¢ã‚¤ã‚³ãƒ³ãƒœã‚¿ãƒ³ãŒæ¶ˆãˆãªã„ã‚ˆã†ã€å¸¸ã«è¡¨ç¤ºã«æˆ»ã™
          var row = document.getElementById('rankSelectRow');
          if(row){
            row.style.display = '';
          }
        }catch(_){}
      };
    }
  }catch(_){}

  // Increase unknown progress when S_UNK triggered inside resolveVanishAndDrop
  (function patchResolve(retry){
    retry=retry||0;
    if(typeof window.resolveVanishAndDrop==='function'){
      if(window.__resolvePatched) return; window.__resolvePatched=true;
      var orig=window.resolveVanishAndDrop;
      window.resolveVanishAndDrop = function(){
        // Before run, snapshot specialsHit size via global hook not available,
        // so we run original and then check globals if present
        orig();
        try{
          // Heuristic: when unknown special triggers, some flag may be set; fallback: increment when rank at MAX and not reached and Sound.cross was played recently is non-trivial -> skip.
          // Instead, rely on gameplay calling applySpecialGimmicks etc. If S_UNK logged to console or stored, this is complex, so keep progress via a helper someone else calls. As backup, we do nothing here.
        }catch(_){}
        maybeReachMax();
      };
      return;
    }
    if(retry<20) setTimeout(function(){ patchResolve(retry+1); }, 120);
  })();

  // ---------- Auto-shuffle (no immediate matches, ensure at least one move) ----------
  function hasAnyMove(){
    if (typeof size==='undefined') return false;
    for (let r=0;r<size;r++){
      for (let c=0;c<size;c++){
        const b = get(r,c); if (!b || (Array.isArray(JUSOS)&&JUSOS.includes(b))) continue;
        const dirs = [[0,1],[1,0]];
        for (const d of dirs){
          const nr=r+d[0], nc=c+d[1];
          if (nr<0||nr>=size||nc<0||nc>=size) continue;
          const b2 = get(nr,nc);
          if (!b2 || (Array.isArray(JUSOS)&&JUSOS.includes(b2))) continue;
          swap(r,c,nr,nc);
          const has = findMatches(true);
          swap(r,c,nr,nc);
          if (has) return true;
        }
      }
    }
    return false;
  }
  window.hasAnyMove = hasAnyMove;
  var __coreShuffleBoard = window.shuffleBoard;
window.shuffleBoard = function(){
    if (window.__shuffling) return;      // äºŒé‡å‘¼ã³å‡ºã—é˜²æ­¢
    window.__shuffling = true;
    try{
      if (typeof updateStatus==='function'){
        updateStatus('status: å‹•ã‹ã›ã‚‹é§’ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã—ã¾ã™');
      }
    }catch(_){}
    try{ Sound.play('whoosh', 1.0); }catch(_){}  // se_whoosh.mp3 å†ç”Ÿï¼ˆæ—¢å­˜ã®SE_BANKã«whooshã‚ã‚Šï¼‰
    setTimeout(function(){  // â† ãƒ¯ãƒ³ã‚¯ãƒƒã‚·ãƒ§ãƒ³ï¼ˆå¾…ã¡æ™‚é–“ã¯å¥½ã¿ã§èª¿æ•´ï¼‰
      try{
        if (typeof __coreShuffleBoard === 'function'){
          __coreShuffleBoard();
        }
      }finally{
        window.__shuffling = false;
      }
    }, 600); // â† ã“ã“ãŒâ€œãƒ¯ãƒ³ã‚¯ãƒƒã‚·ãƒ§ãƒ³â€æ™‚é–“(ms)
  };


  // Hook after maybeSpawnObstacles is called in resolve flow (polling fallback)
  (function checkShuffleLoop(){
    try{
      if (typeof findMatches==='function' && typeof hasAnyMove==='function'){
        if (!findMatches(true) && !hasAnyMove()){
          window.shuffleBoard();
          try{ if (typeof updateStatus==='function') updateStatus('status: ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã—ã¾ã—ãŸ'); }catch(_){}
          if (typeof setComboText === 'function'){
            try { setComboText("ç›¤é¢ã‚’ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã—ã¾ã—ãŸã€‚"); } catch(_){}
          }
        }
      }
    }catch(_){}
    setTimeout(checkShuffleLoop, 1200); // low-frequency check to avoid heavy load
  })();

})();
</script>






<!-- ===== RankMAX Ceremony: inferno + (optional) vignette + shake ===== -->

<!-- ===== /RankMAX Ceremony ===== -->


<script>
(function(){
  if (!/\bdebugload=1\b/.test(location.search)) return;
  window.addEventListener('load', function(){
    var miss = window.__missingAssets || [];
    var box = document.createElement('div');
    box.style.position='fixed'; box.style.right='8px'; box.style.bottom='8px';
    box.style.maxWidth='90vw'; box.style.maxHeight='40vh'; box.style.overflow='auto';
    box.style.background='rgba(0,0,0,0.8)'; box.style.color='#fff';
    box.style.padding='12px'; box.style.fontSize='12px'; box.style.zIndex='99999';
    box.style.borderRadius='8px';
    box.innerHTML = '<b>Missing assets ('+miss.length+')</b><br>'+ miss.map(m=>'<div>'+m+'</div>').join('');
    document.body.appendChild(box);
  });
})();
</script>


<!-- ALL MAX Overlay -->
<div id="allmaxOverlay" aria-hidden="true">
  <div id="allmaxPanel" role="dialog" aria-modal="true">
    <div id="allmaxClose" title="close">âœ•</div>
    <h2>â€• åˆ°é”ã›ã—è€…ã®æ‰‰ â€•</h2>
    <div id="allmaxInputArea">
      <div id="allmaxInputRow">
        <input id="allmaxInput" type="password" placeholder="PASS CODE" autocomplete="off" />
        <button id="allmaxOkBtn" type="button">OK</button>
      </div>
      <div id="allmaxError">è²´æ–¹ã¯"æœªã "ãã®è³‡æ ¼ã‚’å¾—ã¦ã¯ã„ãªã„ã‚ˆã†ã â€¦</div>
    </div>
    <!-- Hidden image: do NOT set src until passcode succeeds -->
    <img id="allmaxImage" alt="ALL MAX" />
  </div>
</div>

</body>
</html>
<script>

// === FIX: reserve fixed area for skill text to prevent layout shift ===
(function(){
  function ensureSkillTextContainer(){
    let c = document.getElementById('skillNameContainer');
    if(!c){
      c = document.createElement('div');
      c.id = 'skillNameContainer';
      const t = document.createElement('div');
      t.id = 'skillNameText';
      c.appendChild(t);
      // append to body overlay layer
      document.body.appendChild(c);
    }
  }
  document.addEventListener('DOMContentLoaded', ensureSkillTextContainer);
})();

</script>

<style>
/* === Mobile only slider styling (forced). PC untouched. ===
   - Track base: neutral
   - Fill only: water-blue
   - Track thickness: 1.5x (6px)
   - Fill follows thumb via CSS var (--fill-pct) updated in JS
   - Thumb centered to track using track height var
*/
:root{ --range-thumb-nudge: 3px; }

@media (max-width: 900px){
  input[type="range"], .slider-hit input[type="range"]{
    -webkit-appearance: none !important;
    appearance: none !important;
    height: 28px !important;
    background: transparent !important;

    /* geometry vars */
    --track-h: 8px;              /* 4px * 1.5 = 6px */
    --fill-pct: 50%;
    --thumb-s: 16px;
    --thumb-nudge-mobile: 0px;   /* å¿…è¦ãªã‚‰ã“ã“ã ã‘å¾®èª¿æ•´ */

    /* fill (ä¼¸ç¸®éƒ¨åˆ†) */
    background-image: linear-gradient(#5ecbff, #5ecbff) !important;
    background-repeat: no-repeat !important;
    background-position: left center !important;
    background-size: var(--fill-pct) var(--track-h) !important;
  }

  /* Track base: neutral */
  input[type="range"]::-webkit-slider-runnable-track,
  .slider-hit input[type="range"]::-webkit-slider-runnable-track{
    height: var(--track-h) !important;
    background: rgba(255,255,255,0.22) !important;
    border: none !important;
    border-radius: 999px !important;
  }

  /* Thumb: blue (centered) */
  input[type="range"]::-webkit-slider-thumb,
  .slider-hit input[type="range"]::-webkit-slider-thumb{
    -webkit-appearance: none !important;
    width: var(--thumb-s) !important;
    height: var(--thumb-s) !important;
    background: #1e90ff !important;
    border: none !important;
    border-radius: 50% !important;
    margin-top: calc((var(--track-h) - var(--thumb-s)) / 2 + var(--thumb-nudge-mobile)) !important;
  }

  /* Firefox (Android) */
  input[type="range"]::-moz-range-track,
  .slider-hit input[type="range"]::-moz-range-track{
    height: var(--track-h) !important;
    background: rgba(255,255,255,0.22) !important;
    border: none !important;
    border-radius: 999px !important;
  }
  input[type="range"]::-moz-range-thumb,
  .slider-hit input[type="range"]::-moz-range-thumb{
    width: var(--thumb-s) !important;
    height: var(--thumb-s) !important;
    background: #1e90ff !important;
    border: none !important;
    border-radius: 50% !important;
    margin-top: calc((var(--track-h) - var(--thumb-s)) / 2 + var(--thumb-nudge-mobile)) !important;
  }
}
</style>



<script>
// === Ensure mobile range fill follows thumb (without changing existing logic) ===
(function(){
  function bindFill(el){
    if(!el) return;
    try{ updateRangeFill(el); }catch(_){}
    el.addEventListener('input', function(){ try{ updateRangeFill(el); }catch(_){} }, {passive:true});
    el.addEventListener('change', function(){ try{ updateRangeFill(el); }catch(_){} }, {passive:true});
  }
  document.addEventListener('DOMContentLoaded', function(){
    bindFill(document.getElementById('bgmSlider'));
    bindFill(document.getElementById('seSlider'));
  });
})();
</script>

